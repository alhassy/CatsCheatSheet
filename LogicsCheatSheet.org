# MA: Copied to dropbox Dec 15 2019

#+TITLE: Logics CheatSheet
#+SUBTITLE: ---Reference Sheet for ‚ÄúWhat I'm Currently Learning‚Äù---
# DATE: << Winter 2019 >> When we don't provide a date, one is provided for us.
# ‚îÄCheatSheet Configurations: Change the first two‚Äº‚îÄ
#+MACRO: URL https://github.com/alhassy/CheatSheet
#+MACRO: blurb Pretty cheat sheets, or ‚Äúreference cards‚Äù, obtainable from Org-mode files. See section [[#getting-started]] below to get started making your own cheat sheets!
#+MACRO: ShowURL @@latex:{\tiny\hspace{6em}\url{ {{{URL}}} } }@@
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] {{{ShowURL}}}
#+EMAIL: alhassy@gmail.com
#+TODO: Todo | spacing begin end LaTeX
#+OPTIONS: d:nil
#+INCLUDE: CheatSheetSetup.org

:Ignore:
Why org-mode? To use org-babel tangle!
#+begin_quote
/‚ÄòWhy‚Äô, said the Dodo, ‚Äòthe best way to explain it is to do it.‚Äô/

---Alice's Adventures in Wonderland
#+end_quote
:End:
* LaTeX Extra, Local, Setup :ignore:

#+LATEX_HEADER: \usepackage{UnicodeSymbols}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

#+LATEX_HEADER: \usepackage{newunicodechar}
#+LATEX_HEADER: \newunicodechar{ùëª}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{‚äï}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{‚âà}{\ensuremath{\approx}}

* COMMENT ~\LaTeX~ commands ‚Ü¶ ~#+latex: \LaTeX~

  Execute the following block, with ~C-c C-c~ anywhere inside it,
  to hide all LaTeX specific items away so that, for example, the generated HTML
  does not show them.

  #+BEGIN_SRC emacs-lisp :results no
(defun my/replace-in-buffer (this that)
  "Replace every occurance of regexp ‚Äòthis‚Äô with ‚Äòthat‚Äô
   in the current buffer."
   (interactive)
   (save-excursion
    (beginning-of-buffer)
    (while (re-search-forward this nil t)
      (replace-match that)
    ))
)

;; Replace newline, any number of space, then room or vspace with a #+latex: beforehand.
(let (this that)
  (dolist (kp '( ( "^[ ]*\\\\room" . "#+latex: \\\\room")
         ( "^[ ]*\\\\vspace" . "#+latex: \\\\vspace")
         ( "^[ ]*\\\\newpage" . "#+latex: \\\\newpage")
         ( "^[ ]*\\\\columnbreak" . "#+latex: \\\\columnbreak")
         ))
    (setq this (car kp))
    (setq that (cdr kp))
    (my/replace-in-buffer this that)
   )
)
  #+END_SRC

  #+RESULTS:

* Definitions

  + Signature :: A pair of sets /Œ£ = (S, Œ©)/ called the /sorts/ and /operations/;
                 each operation is a tuple written /f : s‚ÇÅ √ó ‚ãØ √ó s‚Çô ‚Üí s/
                 where the /s·µ¢/ are sorts. I.e., a hypergraph.

  + Algebra :: An implementation of a signature.

               A Œ£-algebra /A/ is a pair of functions assigning:
    1. A set $A \ s$ to each sort /s/, called the /carrier set of sort s/
    2. A total function /A f : A s‚ÇÅ √ó ‚ãØ √ó A s‚Çô ‚Üí A s/ to each operation
       symbol /f : s‚ÇÅ √ó ‚ãØ √ó s‚Çô ‚Üí s/.

  + Homomorphism :: Mappings between the carrier sets of Œ£-algebras
   that ‚Äúrespect‚Äù the function symbols of Œ£.

                    A Œ£-<<<homomorphism>>> ~h : A ‚ü∂ B~ between two
                    Œ£-algebras ~A~ and ~B~ is a family of functions ~‚àÄ {s}
                    ‚Üí A s ‚Üí B s~ such that for any
                    operation ~f : s‚ÇÅ √ó ‚ãØ  √ó s‚Çô ‚Üí s~, we have
                    ~h‚Çõ (A f (a‚ÇÅ, ‚Ä¶, a‚Çô)) = B f (h‚Çõ‚ÇÅ a‚ÇÅ, ‚Ä¶, h‚Çõ‚Çô a‚Çô)~; i.e.,
                    ~h ‚àò A f = B f ‚àò map h~.

   ( Algebras are functors and homomorphisms are natural transformations! )

 + Abstract data type :: An abstract data type is a class of
        algebras closed under isomorphism.

         An <<<abstract data type>>> for a signature
        Œ£ is a class $ùíû ‚äÜ ùíúùìÅ‚Ñä Œ£$ such that if ~A ‚âÖ B ‚àà ùíû~ then ~A ‚àà ùíû~,
        for any Œ£-algebras ~A~ and ~B~.

       An abstract data type is called /monomorphic/ if all its algebras
        are isomorphic to each other; otherwise it is called
        /polymorphic/.


  | *Academia*     | *Programming*              |
  |--------------+--------------------------|
  | Signatures   | Interface                |
  | Algebra      | Implementation           |
  | Homomorphism | Coherent transformations |
  |              |                          |

* Signature Morphisms

 + Signature morphism :: a signature morphism is a mapping of
      signatures that respects the arity of the operations.

      Since signatures are hypergraph, signature morphisms are
      just hypergraph morphisms: A /signature morphism/ $Œº : Œ£ ‚ü∂ Œ£‚Ä≤$
      is a pair of functions, between sorts and operation symbols, such that
      /f : s‚ÇÅ √ó ‚ãØ √ó s‚Çô ‚Üí s  ‚áí  Œº f : Œº s‚ÇÅ √ó ‚ãØ √ó Œº s‚Çô ‚Üí Œº s/.

      Signature morphisms are simply a change of notation.

+ Reducts :: These are the semantical counterpart of the syntactical notion of
             signature morphisms.

             If /Œº/ : Œ£ ‚Üí Œ£‚Ä≤ and /A‚Ä≤/ is a Œ£‚Ä≤-algebra, then the /Œº-reduct
             of A‚Ä≤/ is the Œ£-algebra /A‚Ä≤ ‚àò Œº/ defined by $(A‚Ä≤ ‚àò Œº)(x) = A‚Ä≤(Œº x)$.

             When Œº is an inclusion, /A‚Ä≤ ‚àò Œº/ simply ‚Äúforgets‚Äù the extra parts /Œ£‚Ä≤ - Œ£/
             and so it is a ‚Äòconstrained‚Äô algebra. Of-course, Œº could be the identity
             and this perception of constrained is void.

             $A‚Ä≤ ‚àò Œº$ is a Œ£-algebra with the semantics of Œ£‚Ä≤-algebra /A‚Ä≤/:
             We ‚Äòpull‚Äô the interpretation of /A‚Ä≤/ ‚Äòback‚Äô along Œº.

             Likewise, the /Œº/-reduct of a Œ£‚Ä≤-homomorphism $h‚Ä≤$ is
             the Œ£-homomorphism $h‚Ä≤_Œº \;:\; A‚Ä≤ ‚àò Œº ‚ü∂ B$ defined by
             $(h‚Ä≤_Œº) \, s\, x = h‚Ä≤_{Œº s}\, x$.

An algebra is also sometimes called a model.
So, if $Œº : Œ£ ‚ü∂ Œ£‚Ä≤$ then $Mod\, Œº : Mod\, Œ£‚Ä≤ ‚ü∂ Mod\, Œ£$
is obtained by using a Œ£‚Ä≤-model to give a Œ£-model whose semantics
are the semantics of the orignal via a change-in-notation Œº.
+ $Mod\, Œº\, A‚Ä≤ = A‚Ä≤ ‚àò Œº$.

* Logics

An /algebra logic, or logic/ for short, /L/ consists of:
- A decidable set /L Œ£/ of ‚Äòformulas‚Äô for each signature Œ£;
  - Signatures provide the non-logical symbols, which
    represent predicates, functions, and constants on the domain of discourse.
- A ‚Äòformula morphism‚Äô, function, /L Œº : L Œ£ ‚ü∂ L Œ£‚Ä≤/ for each signature
  morphism /Œº/ : Œ£ ‚ü∂ Œ£‚Ä≤;
  + This is a way to extend, apply, a signature morphism onto the syntactic formulae.
- A ‚Äòsatisfaction relation‚Äô /_‚ä®_ : ùíúùìÅ‚Ñä Œ£ ‚Üî L Œ£/ for each signature Œ£.
  + One says formula /œï ‚àà L Œ£/ is *valid in Œ£-algebra A*, or
    *A satisfies œï*, if $A ‚ä®_Œ£ œï$.

Such that the following two conditions hold:

1. /Isomorphism Condition:/ Isomorphic algebras satisfy the same formulae.

   For isomorphic Œ£-algebras /A/ and /B/, and formula /œï ‚àà L Œ£/,
   \[ A ‚ä®_Œ£ œï \;‚áî\; B ‚ä®_Œ£ œï \]

2. /Satisfaction Condition:/

   Satisfaction is invariant under change of notation:
   For any signature morphism $Œº : Œ£ ‚ü∂ Œ£‚Ä≤$, formula /œï ‚àà L Œ£/, and
   Œ£‚Ä≤-algebra /A‚Ä≤/, \[A‚Ä≤ ‚àò Œº ‚ä®_Œ£ œï \;‚áî\; A‚Ä≤ ‚ä®_{Œ£‚Ä≤} L Œº \, œï \]

   When we think of Œº as a form of constraints, this says:
       A formula is satisfied in a ‚Äòconstrained‚Äô subpart of an algebra
   iff the algebra satisfies the ‚Äòconstrained‚Äô form of the formula.

   Writing $Sen\, Œº = L\, Œº$ for the sentences, formulae, operation,
   and $Mod\, Œº$ for the reduct; the condition becomes a property of sentences-&-models, of syntax-&-semantics: Satisfaction is invariant under change of notation:
   \[Mod\, Œº\, A‚Ä≤ ‚ä®_Œ£ œï \;‚áî\; A‚Ä≤ ‚ä®_{Œ£‚Ä≤} Sen\, Œº \, œï \]

A logic /L/ is called a /logic with equality/ if, for any signature Œ£ and
any ground terms /t/ and /u/ of the same sort in Œ£, there is a formula,
say $œï_{t,u} ‚àà L\, Œ£$ which is validated as equality by every
Œ£-algebra /A/: \[A ‚ä® œï_{t, u} \;‚áî\; A t \,=\, A u\]

This is a satisfaction-based view of logic; a proof-based view is also possible.

** Institutions

The necessary ingredients for a logic are captured tersely in an [[https://en.wikipedia.org/wiki/Institution_(computer_science)][‚Äúinstitution‚Äù]]
which gives us a category of signatures, a functor $Sen$ that assigns them sentences,
and a functor $Mod$ that assigns them categories, along with satisfication relations.

Alternatively, an institution is a functor from a category of signatures to the
category of [[http://iks.cs.ovgu.de/~till/papers/derived.pdf][rooms]].

* Equational Logic, /EL/

# This logic is defined as follows.

+ Formulae are universally quantified equations:
  \[EL(Œ£) = \{‚àÄ X. t = u ‚ùô \text{X is a set of variables; t and u are Œ£-terms of the same sort using variables X}\}\]

  The =,‚àÄ are meta-symbols; the formulae are just triples $(X, t, u)$
  but we use a suggestive notation for the satisfaction relation below.

+ Formula morphisms apply signature morphisms component-wise:
  \[EL\, Œº \,(‚àÄ X. t = u) \;=\; (‚àÄ Œº(X). Œº t = Œº u)\]

+ A formula is satisfied when all variable assignments result in true equalities:
    $A ‚ä®_Œ£ ‚àÄX.t=u$ if and only if ~A Œ± t = A Œ± u~ for all assignments $Œ± : X ‚Üí A$.

  In-particular, if variables ~X~ have their sorts interpreted by ~A~ as empty
  sets, then there would be no assignments ~Œ±~ to consider, and so the formula would
  be vacuously satisfied.

This is a logic with equality: The equality of /t/ and /u/ is the ground equation
/‚àÄ ‚àÖ. t = u/.

* Conditional Equational Logic, /CEL/

CEL is a mild generalisation of EL that is easier to use.

+ Formulae are universally quantified equations with conjunctive provisos:
  \[CEL(Œ£) = \{‚àÄ X. t‚ÇÅ = u‚ÇÅ ‚àß ‚ãØ ‚àß t‚Çô = u‚Çô \,‚áí\, t‚Çô‚Çä‚ÇÅ = u‚Çô‚Çä‚ÇÅ\}\]
  where each pair ~t·µ¢, u·µ¢~ are terms of the same sort and ~X~ is a set of variables.

  The ‚àÄ,=,‚àß,‚áí are meta-symbols; the formulae are just tuples $(X,
  ((t‚ÇÅ,u‚ÇÅ), ‚Ä¶,(t‚Çô, u‚Çô)),(t, u))$ but we use a suggestive notation for
  the satisfaction relation below.

+ Formula morphisms apply signature morphisms component-wise:
  \[CEL\,Œº\,(‚àÄ X. t‚ÇÅ = u‚ÇÅ ‚àß ‚ãØ ‚àß t‚Çô = u‚Çô \,‚áí\, t‚Çô‚Çä‚ÇÅ = u‚Çô‚Çä‚ÇÅ) \;=\; (‚àÄ
  Œº(X). Œº t‚ÇÅ = Œº u‚ÇÅ ‚àß ‚ãØ ‚àß Œº t‚Çô = Œº u‚Çô \,‚áí\, Œº t‚Çô‚Çä‚ÇÅ = Œº u‚Çô‚Çä‚ÇÅ)\]

+ A formula is satisfied when all variable assignments result in true equalities
  /assuming/ the provisos are all true:

  ~A ‚ä® ‚àÄ X. t‚ÇÅ = u‚ÇÅ ‚àß ‚ãØ ‚àß t‚Çô = u‚Çô ‚áí t‚Çô‚Çä‚ÇÅ = u‚Çô‚Çä‚ÇÅ~ iff for every
  assignment $Œ± : X ‚Üí A$, if $A\, Œ±\, t·µ¢ \;=\; A\, Œ±\, u·µ¢$ for all
  $i : 1..n$, then $A\, Œ±\, t‚Çô‚Çä‚ÇÅ \;=\; A\, Œ±\, u‚Çô‚Çä‚ÇÅ$.

* Predicate Logic, /PL/ and ---/Prop/

PL generalises classical first-order predicate logic for many-sorted algebras.
It's also known as Predicate Calculus.

Formulae œï are defined inductively: ~œï ::= t = u | œï ‚àß œï‚Ä≤ | ¬¨ œï | (‚àÄ x : s. œï)~
 - Provided /t, u/ are Œ£-terms of the same sort; /x/ is a variable; /s/ is a sort.
 - As usual, it is possible to introduce additional logical symbols
   such as $true, false, ‚à®, ‚áí, ‚áî, ‚àÉ$ as abbreviations; e.g., ~true~ is an abbreviation
   for the formula ~t = t~ where ~t~ is a Œ£-term.

The signature morphisms ~PL Œº~ are defined by ‚Äòdistributing‚Äô ~Œº~ over the
metasymbols, down to the terms.

The satisfaction relation is defined by ~A ‚ä® œï~ iff $A\, Œ± \, œï$ is true
for all assignments $Œ± : free-variables(œï) ‚Üí A$, where $A\, Œ±$ extends
to formulae by ‚Äòdistributing‚Äô over the metasymbols =,‚àß,¬¨,‚àÄ to get the
semantical notions of equality, conjunction, negation, and universal
quantification.

PL, FOL, quantifies only variables that range over individuals;
second-order logic, in addition, also quantifies over sets/functions;
third-order logic also quantifies over sets of sets, and so
on. Higher-order logic, HOL, is the union of all nth-order logics and
so admits quantification over sets that are nested arbitrarily deeply.

Propositional logic /Prop/, ‚Äòzero-order logic‚Äô, does not deal with
non-logical objects, predicates about them, or quantifiers.  It is
obtained from PL by ignoring =,‚àÄ, and including variables that may
only take on Boolean values, as well as the constant ~true~.
Satisfication is defined by assignments Œ± to the Boolean values;
whence algebras become irrelevant.

Intuitionistic Logic omits the law of the excluded middle and so connectives
are not interdefinable. It is obtained from PL by omitting ¬¨, and including
‚ä§,‚ä•,‚à®,‚áí,‚àÉ. Furthermore, satisfication is defined to mean a formula is valid
iff it receives the value of the top element for any assignment
and the metasymbols ‚àß,‚à®,‚áí are interpreted in an /arbitrary/ [[https://en.wikipedia.org/wiki/Heyting_algebra][Heyting algebra]]
rather than the classical Boolean algebra ùîπ of truth values.

* Models & Theories

Let /L/ be a logic ---so we can speak of satisfaction---
and let /Œ® ‚äÜ L Œ£/ be a set of formulae over signature Œ£.

+ A Œ£-algebra /A/ is a *model of Œ®* if /A ‚ä® œï/ for each /œï ‚àà Œ®/ ---denoted /A ‚ä® Œ®/.

  Let $Mod_Œ£(Œ®)$ denote all Œ£-algebras that are models of Œ®.

+ The *theory* of a Œ£-algebra /A/ wrt /L/ is the set of formulae modelled by
  /A/: \[ Th_L(A) = \{œï ‚àà L\, Œ£ ‚ùô A ‚ä® œï\} \]

  A theory is ‚Äòlarger‚Äô when the logic is more ‚Äòpowerful‚Äô.

Theorems:
1. $Mod_Œ£(‚àÖ) = ùíúùìÅ‚Ñä Œ£$.
2. $Mod_ùí∞(Œ®)$ is an abstract data type; i.e., it is a class of
   Œ£-algebras that is closed under isomorphism.
3. Homomorphism: $Mod(Œ® ‚à™ Œ®‚Ä≤) = Mod(Œ®) ‚à© Mod(Œ®‚Ä≤)$.
4. Homomorphism: $Th(A ‚à™ B) = Th(A) ‚à© Th(B)$.
5. Antitonicity: $Œ® ‚äÜ Œ®‚Ä≤ ‚áí Mod(Œ®‚Ä≤) ‚äÜ Mod(Œ®)$.
6. Antitonicity: $A ‚äÜ B ‚áí Th(B) ‚äÜ Th(A)$.
7. Theories cannot distinguish between isomorphic algebras:
   $A ‚âÖ B ‚áí Th(A) = Th(B)$.
8. If /L/ is a logic with equality, and if $A$ and $B$ are generated,
   then $A ‚âÖ B ‚áê Th(A) = Th(B)$.

It is possible to show that $Mod$ and $Th$ constitute a Galois connection.

* Logical Consequence ---Semantic Entailment

Let /L/ be a logic ---so we can speak of satisfaction---
and let /Œ® ‚äÜ L Œ£/ be a set of formulae over signature Œ£,
and œï a formula.

+ Say *œï is a logical consequence of Œ®* whenever an algebra models Œ® it also models œï
  ---denoted $Œ® ‚ä®_Œ£ œï$.
+ *œï is valid* whenever it is a logical consequence of the empty set of formulae;
  one also says *œï is a tautology*
  ---denoted $‚ä®_Œ£ œï$.

 Theorems:
  1. Componentwise: /‚ä® œï/ iff /A ‚ä® œï/ for all Œ£-algebras /A/.
  2. Componentwise: $Mod(Œ®) ‚ä® œï$ iff $Œ® ‚ä® œï$.
  3. Empty Inconsistency: If $Mod(Œ®)$ is empty, then $Œ® ‚ä® L\,Œ£$.
  4. A theory is closed under logical consequence.
  5. A theory contains all tautologies.

* Calculi ---Deduction Systems

  A calculus, or ‚Äòproof system‚Äô,
  is an inductive definition of a set of strings ---e.g., formulae---
  whose goal is to /syntactically/ grasp the notion of logical consequence
  and, in principle, permit /mechanical/ proofs of statements such as /Œ® ‚ä® œï/.

** Formal Definition

A *calculus* ùí¶ for a logic /L/ and signature Œ£ is a finite set of
  ‚Äòinference rules‚Äô each of which is a decidable subset of /L(Œ£)‚Åø √ó
  L(Œ£)/ for some /n : ‚Ñï/.

- A rule $\{((œï‚ÇÅ, ‚Ä¶, œï‚Çô), œï) ‚ùô ‚ãØ\}$ is generally presented as
      #+BEGIN_EXAMPLE
    œï‚ÇÅ ‚ãØ œï‚Çô
    ------
      œï
#+END_EXAMPLE

- Rule with /n = 0/ are called ‚Äòaxiom schemas‚Äô, and an element of an axiom scheme is
  called an ‚Äòaxiom‚Äô.

The meaning of a calculus is what it allows to be derived:
*œï is derivable from Œ®*, denoted $Œ® ‚ä¢_ùí¶ œï$, if it is /provable within ùìö/; i.e.,
there is a finite non-empty sequence /œï‚ÇÅ, ‚Ä¶, œï‚Çñ/ with /œï‚Çñ = œï/ and each /œï·µ¢
is either an assumption, /œï·µ¢ ‚àà Œ®/, or is the result of an inference rule applied to previous elements of the sequence; i.e., there are indices $j‚ÇÅ, ‚Ä¶, j‚Çô$
such that $((œï_{j‚ÇÅ}, ‚Ä¶, œï_{j‚Çô}), œï·µ¢)$ is an element of an inference rule of ùìö
---in particular, $œï·µ¢$ could be an axiom.


** Grasping the notion of logical consequence

The purpose of a calculus is to grasp the notion of logical consequence.

Let /Œ® ‚äÜ L(Œ£)/ and /œï ‚àà L(Œ£)/.

+ *ùí¶ is sound* if ùí¶-provability implies logical consequence:
  For any Œ®, œï: \[Œ® ‚ä¢^ùí¶ œï \;‚áí\; Œ® ‚ä® œï\]
+ *ùí¶ is complete* if logical consequence implies ùí¶-provability:
  For any Œ®, œï: \[Œ® ‚ä¢^ùí¶ œï \;‚áê\; Œ® ‚ä® œï\]

** A Nifty Table

| Signature Œ£       | ‚áí | What terms can be formed?                     |
| Logic /L/           | ‚áí | What formulae can be formed? & What is truth? |
| Inference Rules ùí¶ | ‚áí | How are theorems proven?                      |

* spacing COMMENT newpage                                                    :ignore:
#+latex: \newpage
* COMMENT Making README

C-c C-c: Evaluate src block.

:'( For some reason using {{{title}}} below would not work.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.org
     ,# HTML: <h1> Easily Making CheatSheets with Org-mode </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

     :Hide:
     This project is to contain a listing of common results in X Theory.

     ,*The repo contains other articles I've written on X Theory;*
     ,*which may be read in a blog-format at:*
     https://alhassy.github.io/blog/categories/#Xtheory
     :End:

    ,*The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*,
     while below is an unruly html rendition.

     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      ; (org-md-export-to-markdown)
      (org-org-export-to-org)
      )
)
#+END_SRC

#+RESULTS: make-readme
: README.org

* COMMENT footer

The first ‚Äúeval‚Äù below is convenience matter
that should be loaded whenever CheatSheet.org is opened.

The second ‚Äúeval‚Äù makes a README for the repo, whenever the file is opened,
and is then bound to ~f11~ for convenience.

# Local Variables:
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# eval: (local-set-key (kbd "<f11>") '(lambda () (interactive) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# compile-command: (my-org-latex-export-to-pdf)
# End:
