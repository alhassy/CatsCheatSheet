# MA: Copied to dropbox Dec 15 2019

#+TITLE: Logics CheatSheet
#+SUBTITLE: ---Reference Sheet for â€œWhat I'm Currently Learningâ€---
# DATE: << Winter 2019 >> When we don't provide a date, one is provided for us.
# â”€CheatSheet Configurations: Change the first twoâ€¼â”€
#+MACRO: URL https://github.com/alhassy/CheatSheet
#+MACRO: blurb Pretty cheat sheets, or â€œreference cardsâ€, obtainable from Org-mode files. See section [[#getting-started]] below to get started making your own cheat sheets!
#+MACRO: ShowURL @@latex:{\tiny\hspace{6em}\url{ {{{URL}}} } }@@
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] {{{ShowURL}}}
#+EMAIL: alhassy@gmail.com
#+TODO: Todo | spacing begin end LaTeX
#+OPTIONS: d:nil
#+INCLUDE: CheatSheetSetup.org

:Ignore:
Why org-mode? To use org-babel tangle!
#+begin_quote
/â€˜Whyâ€™, said the Dodo, â€˜the best way to explain it is to do it.â€™/

---Alice's Adventures in Wonderland
#+end_quote
:End:
* LaTeX Extra, Local, Setup :ignore:

#+LATEX_HEADER: \usepackage{UnicodeSymbols}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

#+LATEX_HEADER: \usepackage{newunicodechar}
#+LATEX_HEADER: \newunicodechar{ğ‘»}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{âŠ•}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{â‰ˆ}{\ensuremath{\approx}}

* COMMENT ~\LaTeX~ commands â†¦ ~#+latex: \LaTeX~

  Execute the following block, with ~C-c C-c~ anywhere inside it,
  to hide all LaTeX specific items away so that, for example, the generated HTML
  does not show them.

  #+BEGIN_SRC emacs-lisp :results no
(defun my/replace-in-buffer (this that)
  "Replace every occurance of regexp â€˜thisâ€™ with â€˜thatâ€™
   in the current buffer."
   (interactive)
   (save-excursion
    (beginning-of-buffer)
    (while (re-search-forward this nil t)
      (replace-match that)
    ))
)

;; Replace newline, any number of space, then room or vspace with a #+latex: beforehand.
(let (this that)
  (dolist (kp '( ( "^[ ]*\\\\room" . "#+latex: \\\\room")
         ( "^[ ]*\\\\vspace" . "#+latex: \\\\vspace")
         ( "^[ ]*\\\\newpage" . "#+latex: \\\\newpage")
         ( "^[ ]*\\\\columnbreak" . "#+latex: \\\\columnbreak")
         ))
    (setq this (car kp))
    (setq that (cdr kp))
    (my/replace-in-buffer this that)
   )
)
  #+END_SRC

  #+RESULTS:

* Definitions

  + Signature :: A pair of sets /Î£ = (S, Î©)/ called the /sorts/ and /operations/;
                 each operation is a tuple written /f : sâ‚ Ã— â‹¯ Ã— sâ‚™ â†’ s/
                 where the /sáµ¢/ are sorts. I.e., a hypergraph.

  + Algebra :: An implementation of a signature.

               A Î£-algebra /A/ is a pair of functions assigning:
    1. A set $A \ s$ to each sort /s/, called the /carrier set of sort s/
    2. A total function /A f : A sâ‚ Ã— â‹¯ Ã— A sâ‚™ â†’ A s/ to each operation
       symbol /f : sâ‚ Ã— â‹¯ Ã— sâ‚™ â†’ s/.

  + Homomorphism :: Mappings between the carrier sets of Î£-algebras
   that â€œrespectâ€ the function symbols of Î£.

                    A Î£-<<<homomorphism>>> ~h : A âŸ¶ B~ between two
                    Î£-algebras ~A~ and ~B~ is a family of functions ~âˆ€ {s}
                    â†’ A s â†’ B s~ such that for any
                    operation ~f : sâ‚ Ã— â‹¯  Ã— sâ‚™ â†’ s~, we have
                    ~hâ‚› (A f (aâ‚, â€¦, aâ‚™)) = B f (hâ‚›â‚ aâ‚, â€¦, hâ‚›â‚™ aâ‚™)~; i.e.,
                    ~h âˆ˜ A f = B f âˆ˜ map h~.

   ( Algebras are functors and homomorphisms are natural transformations! )

 + Abstract data type :: An abstract data type is a class of
        algebras closed under isomorphism.

         An <<<abstract data type>>> for a signature
        Î£ is a class $ğ’ âŠ† ğ’œğ“â„Š Î£$ such that if ~A â‰… B âˆˆ ğ’~ then ~A âˆˆ ğ’~,
        for any Î£-algebras ~A~ and ~B~.

       An abstract data type is called /monomorphic/ if all its algebras
        are isomorphic to each other; otherwise it is called
        /polymorphic/.


  | *Academia*     | *Programming*              |
  |--------------+--------------------------|
  | Signatures   | Interface                |
  | Algebra      | Implementation           |
  | Homomorphism | Coherent transformations |
  |              |                          |

* Signature Morphisms

 + Signature morphism :: a signature morphism is a mapping of
      signatures that respects the arity of the operations.

      Since signatures are hypergraph, signature morphisms are
      just hypergraph morphisms: A /signature morphism/ $Î¼ : Î£ âŸ¶ Î£â€²$
      is a pair of functions, between sorts and operation symbols, such that
      /f : sâ‚ Ã— â‹¯ Ã— sâ‚™ â†’ s  â‡’  Î¼ f : Î¼ sâ‚ Ã— â‹¯ Ã— Î¼ sâ‚™ â†’ Î¼ s/.

      Signature morphisms are simply a change of notation.

+ Reducts :: These are the semantical counterpart of the syntactical notion of
             signature morphisms.

             If /Î¼/ : Î£ â†’ Î£â€² and /Aâ€²/ is a Î£â€²-algebra, then the /Î¼-reduct
             of Aâ€²/ is the Î£-algebra /Aâ€² âˆ˜ Î¼/ defined by $(Aâ€² âˆ˜ Î¼)(x) = Aâ€²(Î¼ x)$.

             When Î¼ is an inclusion, /Aâ€² âˆ˜ Î¼/ simply â€œforgetsâ€ the extra parts /Î£â€² - Î£/
             and so it is a â€˜constrainedâ€™ algebra. Of-course, Î¼ could be the identity
             and this perception of constrained is void.

             $Aâ€² âˆ˜ Î¼$ is a Î£-algebra with the semantics of Î£â€²-algebra /Aâ€²/:
             We â€˜pullâ€™ the interpretation of /Aâ€²/ â€˜backâ€™ along Î¼.

             Likewise, the /Î¼/-reduct of a Î£â€²-homomorphism $hâ€²$ is
             the Î£-homomorphism $hâ€²_Î¼ \;:\; Aâ€² âˆ˜ Î¼ âŸ¶ B$ defined by
             $(hâ€²_Î¼) \, s\, x = hâ€²_{Î¼ s}\, x$.

An algebra is also sometimes called a model.
So, if $Î¼ : Î£ âŸ¶ Î£â€²$ then $Mod\, Î¼ : Mod\, Î£â€² âŸ¶ Mod\, Î£$
is obtained by using a Î£â€²-model to give a Î£-model whose semantics
are the semantics of the orignal via a change-in-notation Î¼.
+ $Mod\, Î¼\, Aâ€² = Aâ€² âˆ˜ Î¼$.

* Logics

An /algebra logic, or logic/ for short, /L/ consists of:
- A decidable set /L Î£/ of â€˜formulasâ€™ for each signature Î£;
  - Signatures provide the non-logical symbols, which
    represent predicates, functions, and constants on the domain of discourse.
- A â€˜formula morphismâ€™, function, /L Î¼ : L Î£ âŸ¶ L Î£â€²/ for each signature
  morphism /Î¼/ : Î£ âŸ¶ Î£â€²;
  + This is a way to extend, apply, a signature morphism onto the syntactic formulae.
- A â€˜satisfaction relationâ€™ /_âŠ¨_ : ğ’œğ“â„Š Î£ â†” L Î£/ for each signature Î£.
  + One says formula /Ï• âˆˆ L Î£/ is *valid in Î£-algebra A*, or
    *A satisfies Ï•*, if $A âŠ¨_Î£ Ï•$.

Such that the following two conditions hold:

1. /Isomorphism Condition:/ Isomorphic algebras satisfy the same formulae.

   For isomorphic Î£-algebras /A/ and /B/, and formula /Ï• âˆˆ L Î£/,
   \[ A âŠ¨_Î£ Ï• \;â‡”\; B âŠ¨_Î£ Ï• \]

2. /Satisfaction Condition:/

   Satisfaction is invariant under change of notation:
   For any signature morphism $Î¼ : Î£ âŸ¶ Î£â€²$, formula /Ï• âˆˆ L Î£/, and
   Î£â€²-algebra /Aâ€²/, \[Aâ€² âˆ˜ Î¼ âŠ¨_Î£ Ï• \;â‡”\; Aâ€² âŠ¨_{Î£â€²} L Î¼ \, Ï• \]

   When we think of Î¼ as a form of constraints, this says:
       A formula is satisfied in a â€˜constrainedâ€™ subpart of an algebra
   iff the algebra satisfies the â€˜constrainedâ€™ form of the formula.

   Writing $Sen\, Î¼ = L\, Î¼$ for the sentences, formulae, operation,
   and $Mod\, Î¼$ for the reduct; the condition becomes a property of sentences-&-models, of syntax-&-semantics: Satisfaction is invariant under change of notation:
   \[Mod\, Î¼\, Aâ€² âŠ¨_Î£ Ï• \;â‡”\; Aâ€² âŠ¨_{Î£â€²} Sen\, Î¼ \, Ï• \]

A logic /L/ is called a /logic with equality/ if, for any signature Î£ and
any ground terms /t/ and /u/ of the same sort in Î£, there is a formula,
say $Ï•_{t,u} âˆˆ L\, Î£$ which is validated as equality by every
Î£-algebra /A/: \[A âŠ¨ Ï•_{t, u} \;â‡”\; A t \,=\, A u\]

This is a satisfaction-based view of logic; a proof-based view is also possible.

** Institutions

The necessary ingredients for a logic are captured tersely in an [[https://en.wikipedia.org/wiki/Institution_(computer_science)][â€œinstitutionâ€]]
which gives us a category of signatures, a functor $Sen$ that assigns them sentences,
and a functor $Mod$ that assigns them categories, along with satisfication relations.

Alternatively, an institution is a functor from a category of signatures to the
category of [[http://iks.cs.ovgu.de/~till/papers/derived.pdf][rooms]].

* Equational Logic, /EL/

# This logic is defined as follows.

+ Formulae are universally quantified equations:
  \[EL(Î£) = \{âˆ€ X. t = u â™ \text{X is a set of variables; t and u are Î£-terms of the same sort using variables X}\}\]

  The =,âˆ€ are meta-symbols; the formulae are just triples $(X, t, u)$
  but we use a suggestive notation for the satisfaction relation below.

+ Formula morphisms apply signature morphisms component-wise:
  \[EL\, Î¼ \,(âˆ€ X. t = u) \;=\; (âˆ€ Î¼(X). Î¼ t = Î¼ u)\]

+ A formula is satisfied when all variable assignments result in true equalities:
    $A âŠ¨_Î£ âˆ€X.t=u$ if and only if ~A Î± t = A Î± u~ for all assignments $Î± : X â†’ A$.

  In-particular, if variables ~X~ have their sorts interpreted by ~A~ as empty
  sets, then there would be no assignments ~Î±~ to consider, and so the formula would
  be vacuously satisfied.

This is a logic with equality: The equality of /t/ and /u/ is the ground equation
/âˆ€ âˆ…. t = u/.

* Conditional Equational Logic, /CEL/

CEL is a mild generalisation of EL that is easier to use.

+ Formulae are universally quantified equations with conjunctive provisos:
  \[CEL(Î£) = \{âˆ€ X. tâ‚ = uâ‚ âˆ§ â‹¯ âˆ§ tâ‚™ = uâ‚™ \,â‡’\, tâ‚™â‚Šâ‚ = uâ‚™â‚Šâ‚\}\]
  where each pair ~táµ¢, uáµ¢~ are terms of the same sort and ~X~ is a set of variables.

  The âˆ€,=,âˆ§,â‡’ are meta-symbols; the formulae are just tuples $(X,
  ((tâ‚,uâ‚), â€¦,(tâ‚™, uâ‚™)),(t, u))$ but we use a suggestive notation for
  the satisfaction relation below.

+ Formula morphisms apply signature morphisms component-wise:
  \[CEL\,Î¼\,(âˆ€ X. tâ‚ = uâ‚ âˆ§ â‹¯ âˆ§ tâ‚™ = uâ‚™ \,â‡’\, tâ‚™â‚Šâ‚ = uâ‚™â‚Šâ‚) \;=\; (âˆ€
  Î¼(X). Î¼ tâ‚ = Î¼ uâ‚ âˆ§ â‹¯ âˆ§ Î¼ tâ‚™ = Î¼ uâ‚™ \,â‡’\, Î¼ tâ‚™â‚Šâ‚ = Î¼ uâ‚™â‚Šâ‚)\]

+ A formula is satisfied when all variable assignments result in true equalities
  /assuming/ the provisos are all true:

  ~A âŠ¨ âˆ€ X. tâ‚ = uâ‚ âˆ§ â‹¯ âˆ§ tâ‚™ = uâ‚™ â‡’ tâ‚™â‚Šâ‚ = uâ‚™â‚Šâ‚~ iff for every
  assignment $Î± : X â†’ A$, if $A\, Î±\, táµ¢ \;=\; A\, Î±\, uáµ¢$ for all
  $i : 1..n$, then $A\, Î±\, tâ‚™â‚Šâ‚ \;=\; A\, Î±\, uâ‚™â‚Šâ‚$.

* Predicate Logic, /PL/ and ---/Prop/

PL generalises classical first-order predicate logic for many-sorted algebras.
It's also known as Predicate Calculus.

Formulae Ï• are defined inductively: ~Ï• ::= t = u | Ï• âˆ§ Ï•â€² | Â¬ Ï• | (âˆ€ x : s. Ï•)~
 - Provided /t, u/ are Î£-terms of the same sort; /x/ is a variable; /s/ is a sort.
 - As usual, it is possible to introduce additional logical symbols
   such as $true, false, âˆ¨, â‡’, â‡”, âˆƒ$ as abbreviations; e.g., ~true~ is an abbreviation
   for the formula ~t = t~ where ~t~ is a Î£-term.

The signature morphisms ~PL Î¼~ are defined by â€˜distributingâ€™ ~Î¼~ over the
metasymbols, down to the terms.

The satisfaction relation is defined by ~A âŠ¨ Ï•~ iff $A\, Î± \, Ï•$ is true
for all assignments $Î± : free-variables(Ï•) â†’ A$, where $A\, Î±$ extends
to formulae by â€˜distributingâ€™ over the metasymbols =,âˆ§,Â¬,âˆ€ to get the
semantical notions of equality, conjunction, negation, and universal
quantification.

PL, FOL, quantifies only variables that range over individuals;
second-order logic, in addition, also quantifies over sets/functions;
third-order logic also quantifies over sets of sets, and so
on. Higher-order logic, HOL, is the union of all nth-order logics and
so admits quantification over sets that are nested arbitrarily deeply.

Propositional logic /Prop/, â€˜zero-order logicâ€™, does not deal with
non-logical objects, predicates about them, or quantifiers.  It is
obtained from PL by ignoring =,âˆ€, and including variables that may
only take on Boolean values, as well as the constant ~true~.
Satisfication is defined by assignments Î± to the Boolean values;
whence algebras become irrelevant.

Intuitionistic Logic omits the law of the excluded middle and so connectives
are not interdefinable. It is obtained from PL by omitting Â¬, and including
âŠ¤,âŠ¥,âˆ¨,â‡’,âˆƒ. Furthermore, satisfication is defined to mean a formula is valid
iff it receives the value of the top element for any assignment
and the metasymbols âˆ§,âˆ¨,â‡’ are interpreted in an /arbitrary/ [[https://en.wikipedia.org/wiki/Heyting_algebra][Heyting algebra]]
rather than the classical Boolean algebra ğ”¹ of truth values.

* Models & Theories

Let /L/ be a logic ---so we can speak of satisfaction---
and let /Î¨ âŠ† L Î£/ be a set of formulae over signature Î£.

+ A Î£-algebra /A/ is a *model of Î¨* if /A âŠ¨ Ï•/ for each /Ï• âˆˆ Î¨/ ---denoted /A âŠ¨ Î¨/.

  Let $Mod_Î£(Î¨)$ denote all Î£-algebras that are models of Î¨.

+ The *theory* of a Î£-algebra /A/ wrt /L/ is the set of formulae modelled by
  /A/: \[ Th_L(A) = \{Ï• âˆˆ L\, Î£ â™ A âŠ¨ Ï•\} \]

  A theory is â€˜largerâ€™ when the logic is more â€˜powerfulâ€™.

Theorems:
1. $Mod_Î£(âˆ…) = ğ’œğ“â„Š Î£$.
2. $Mod_ğ’°(Î¨)$ is an abstract data type; i.e., it is a class of
   Î£-algebras that is closed under isomorphism.
3. Homomorphism: $Mod(Î¨ âˆª Î¨â€²) = Mod(Î¨) âˆ© Mod(Î¨â€²)$.
4. Homomorphism: $Th(A âˆª B) = Th(A) âˆ© Th(B)$.
5. Antitonicity: $Î¨ âŠ† Î¨â€² â‡’ Mod(Î¨â€²) âŠ† Mod(Î¨)$.
6. Antitonicity: $A âŠ† B â‡’ Th(B) âŠ† Th(A)$.
7. Theories cannot distinguish between isomorphic algebras:
   $A â‰… B â‡’ Th(A) = Th(B)$.
8. If /L/ is a logic with equality, and if $A$ and $B$ are generated,
   then $A â‰… B â‡ Th(A) = Th(B)$.

It is possible to show that $Mod$ and $Th$ constitute a Galois connection.

* Logical Consequence ---Semantic Entailment

Let /L/ be a logic ---so we can speak of satisfaction---
and let /Î¨ âŠ† L Î£/ be a set of formulae over signature Î£,
and Ï• a formula.

+ Say *Ï• is a logical consequence of Î¨* whenever an algebra models Î¨ it also models Ï•
  ---denoted $Î¨ âŠ¨_Î£ Ï•$.
+ *Ï• is valid* whenever it is a logical consequence of the empty set of formulae;
  one also says *Ï• is a tautology*
  ---denoted $âŠ¨_Î£ Ï•$.

 Theorems:
  1. Componentwise: /âŠ¨ Ï•/ iff /A âŠ¨ Ï•/ for all Î£-algebras /A/.
  2. Componentwise: $Mod(Î¨) âŠ¨ Ï•$ iff $Î¨ âŠ¨ Ï•$.
  3. Empty Inconsistency: If $Mod(Î¨)$ is empty, then $Î¨ âŠ¨ L\,Î£$.
  4. A theory is closed under logical consequence.
  5. A theory contains all tautologies.

* Calculi ---Deduction Systems

  A calculus, or â€˜proof systemâ€™,
  is an inductive definition of a set of strings ---e.g., formulae---
  whose goal is to /syntactically/ grasp the notion of logical consequence
  and, in principle, permit /mechanical/ proofs of statements such as /Î¨ âŠ¨ Ï•/.

** Formal Definition

A *calculus* ğ’¦ for a logic /L/ and signature Î£ is a finite set of
  â€˜inference rulesâ€™ each of which is a decidable subset of /L(Î£)â¿ Ã—
  L(Î£)/ for some /n : â„•/.

- A rule $\{((Ï•â‚, â€¦, Ï•â‚™), Ï•) â™ â‹¯\}$ is generally presented as
      #+BEGIN_EXAMPLE
    Ï•â‚ â‹¯ Ï•â‚™
    ------
      Ï•
#+END_EXAMPLE

- Rule with /n = 0/ are called â€˜axiom schemasâ€™, and an element of an axiom scheme is
  called an â€˜axiomâ€™.

The meaning of a calculus is what it allows to be derived:
*Ï• is derivable from Î¨*, denoted $Î¨ âŠ¢_ğ’¦ Ï•$, if it is /provable within ğ“š/; i.e.,
there is a finite non-empty sequence /Ï•â‚, â€¦, Ï•â‚–/ with /Ï•â‚– = Ï•/ and each /Ï•áµ¢
is either an assumption, /Ï•áµ¢ âˆˆ Î¨/, or is the result of an inference rule applied to previous elements of the sequence; i.e., there are indices $jâ‚, â€¦, jâ‚™$
such that $((Ï•_{jâ‚}, â€¦, Ï•_{jâ‚™}), Ï•áµ¢)$ is an element of an inference rule of ğ“š
---in particular, $Ï•áµ¢$ could be an axiom.


** Grasping the notion of logical consequence

The purpose of a calculus is to grasp the notion of logical consequence.

Let /Î¨ âŠ† L(Î£)/ and /Ï• âˆˆ L(Î£)/.

+ *ğ’¦ is sound* if ğ’¦-provability implies logical consequence:
  For any Î¨, Ï•: \[Î¨ âŠ¢^ğ’¦ Ï• \;â‡’\; Î¨ âŠ¨ Ï•\]
+ *ğ’¦ is complete* if logical consequence implies ğ’¦-provability:
  For any Î¨, Ï•: \[Î¨ âŠ¢^ğ’¦ Ï• \;â‡\; Î¨ âŠ¨ Ï•\]

** A Nifty Table

| Signature Î£       | â‡’ | What terms can be formed?                     |
| Logic /L/           | â‡’ | What formulae can be formed? & What is truth? |
| Inference Rules ğ’¦ | â‡’ | How are theorems proven?                      |

* spacing COMMENT newpage                                                    :ignore:
#+latex: \newpage
* COMMENT Making README

C-c C-c: Evaluate src block.

:'( For some reason using {{{title}}} below would not work.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.org
     ,# HTML: <h1> Easily Making CheatSheets with Org-mode </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

     :Hide:
     This project is to contain a listing of common results in X Theory.

     ,*The repo contains other articles I've written on X Theory;*
     ,*which may be read in a blog-format at:*
     https://alhassy.github.io/blog/categories/#Xtheory
     :End:

    ,*The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*,
     while below is an unruly html rendition.

     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; âŸª For a particular block, we use â€œ:eval never-exportâ€ âŸ«
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      ; (org-md-export-to-markdown)
      (org-org-export-to-org)
      )
)
#+END_SRC

#+RESULTS: make-readme
: README.org

* COMMENT footer

The first â€œevalâ€ below is convenience matter
that should be loaded whenever CheatSheet.org is opened.

The second â€œevalâ€ makes a README for the repo, whenever the file is opened,
and is then bound to ~f11~ for convenience.

# Local Variables:
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# eval: (local-set-key (kbd "<f11>") '(lambda () (interactive) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# compile-command: (my-org-latex-export-to-pdf)
# End:
