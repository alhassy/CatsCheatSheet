#+TITLE: Reference Sheet for Elementary Category Theory
# SUBTITLE: Cheat Sheet Template
# DATE: << Spring 2018 >>
# When we don't provide a date, one is provided for us.
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]]
#+EMAIL: alhassy@gmail.com
#+DESCRIPTION: This document is written by Musa Al-hassy for his learning in the spring of 2018.
#+STARTUP: hideblocks
#+STARTUP: overview
#+TODO: BEGIN-IGNORE(b) END-IGNORE(e) } | DONE(d)


# Important shortcuts:
# f7 preview changes
# f8 commit each change
# f9 push changes

#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{newunicodechar}
#+LATEX_HEADER: \newunicodechar{ï¹”}{\ensuremath{\raisebox{0.4ex}{\tiny \,;\,}}}  %% forward composition ï¹”

#+INCLUDE: ~/Dropbox/MyUnicodeSymbols.org
#+INCLUDE: CheatSheet/CheatSheetSetup.org

* Latex setup :ignore:
# See defn-Type, below for an expanded usage; \eqn{name}{formula}
#+LaTeX: \def\eqn#1#2{ \begin{flalign*} #2 && \tag*{#1} \label{#1} \end{flalign*} }

# Variant with less spacing
#+LaTeX: \def\eqnLS#1#2{  \eqn{#1}{#2}} }

#+LaTeX: \def\src{\mathsf{src}}
#+LaTeX: \def\tgt{\mathsf{tgt}}
#+LaTeX: \def\Id{\mathsf{Id}}

* Categories

A *category* ğ’ consists of a collection of â€œobjectsâ€ ~Obj ğ’,~ a collection of
  â€œmorphismsâ€ ~Mor ğ’~, an operation ~Id~ associating a morphism ~Idâ‚ : a â†’ a~ to each object ~a~,
  a parallel pair of functions ~src, tgt : Mor ğ’ â†’ Obj ğ’~, and a â€œcompositionâ€
  operation ~_ï¹”_ : âˆ€{A B C : Obj} â†’ (A â†’ B) â†’ (B â†’ C) â†’ (A â†’ C)~
  where for objects ~X~ and ~Y~ we define the /type/ ~X â†’ Y~
  as follows
\begin{flalign*}
    f : X \to Y \quad\equiv\quad \mathsf{src}\; f = X \;\land\; \mathsf{tgt}\; f = Y 
   &&
   \tag*{defn-Type}
   \label{defn-Type}
\end{flalign*}
# For other approaches see https://tex.stackexchange.com/a/12035/69371
#
# As we can see from \eqref{defn-Type}\ldots
#
  Moreover composition is required to be associative with ~Id~ as identity.

Instead of ~src~ and ~tgt~ we can instead assume primitive a ternary relation
~_:_â†’_~ and regain the operations precisely when the relation is functional
in its last two arguments:
\eqn{unique-Type}{f : A \to B \;\land\; f : A' \to B' \;\implies\; A=A' \;\land\; B=B'}
When this condition is dropped, we obtain a /pre-category/; e.g., the familiar /Sets/
is a pre-category that is usually treated as a category by making morphisms
contain the information about their source and target: ~(A, f, B) : A â†’ B~
rather than just ~f~. /This is sometimes easier to give, then src and tgt! C.f. Alg(F)./

\vspace{1em}

A categorical statement is an expression built from notations for objects,
typing, morphisms, composition, and identities by means of the usual logical
connectives and quantifications and equality.

\vspace{1em}

Even when morphisms are functions, the objects need not be sets:
Sometimes the objects are /operations/ --with an appropriate definition
of typing for the functions. The categories of F-algebras are an example
of this.

\vspace{1em}

Example Categories.
+ Each digraph determines a category: The objects are the nodes
  and the paths are the morphisms typed with their starting and ending node.
  Composition is catenation of paths and identity is the empty path.
+ Each preorder determines a category: The objects are the elements
  and there is a morphism ~a â†’ b~ named, say, ~(a, b),~ precisely when $a â‰¤ b$.

* Functors

A *functor* /F : ğ’œ â†’ â„¬/ is a pair of mappings, denoted by one name,
from the objects, and morphisms, of ğ’œ to those of â„¬ such that
it respects the categorical structure:

#+BEGIN_EXPORT latex 
{\setlength{\abovedisplayskip}{-1pt}\setlength{\belowdisplayskip}{-1pt}

\eqn{functor-Type}{F\, f : F\, A \to_â„¬ F\, B \quad\Leftarrow\quad f : A \to_ğ’œ B }

\eqn{Functor}{F\, \Id_A \;=\; \Id_{F\, A}} 

\eqn{Functor}{F\, (f ï¹” g) \;=\; F\, f ï¹” F\, g}

}
#+END_EXPORT

\vspace{1em}

The two axioms are equivalent to the single statement that 
/functors distribute over finite compositions, with $\Id$ being the empty composition/
\[ F(f ï¹” \cdots ï¹” g) \;=\; F\, f ï¹” \cdots ï¹” F\, g \]

Use of Functors.
+ In the definition of a category, â€œobjectsâ€ are â€œjust thingsâ€ for which no internal
  structure is observable by categorical means --composition, identities, morphisms, typing.

  Functors form the tool to deal with â€œstructuredâ€ objects

  Indeed in ğ’®â„¯ğ“‰ the aspect of a structure is that it has â€œconstituentsâ€, and that it is possible
  to apply a function to all the individual constituents; this is done by
  /F f : F A â†’ F B/.

+  For example, let /ğ‘° A = A Ã— A/ and /ğ‘° f = (x, y) â†¦ (f x, f y)./
  So ğ‘° is or represents the structure of pairs; /ğ‘° A/ is the set of pairs of /A/,
  and /ğ‘° f/ is the function that applies /f/ to each constituent of a pair.

  - A /binary operation on A/ is then just a function /ğ‘° A â†’ A;/
    in the same sense we obtain â€œF-ary operationsâ€.

+  Also, /Seq/ is or represents the structure of sequences; /Seq A/ is the structure of sequences
  over /A/, and /Seq f/ is the function that applies /f/ to each constituent of a sequence.

+  Even though /F A/ is still just an object, a thing with no observable internal structure, the
  functor properties enable to exploit the â€œstructureâ€ of /F A/ by allowing us to â€œapplyâ€
  a /f/ to each â€œconstituentâ€ by using /F f/.

\vspace{1em}

Category $ğ’œlâ„Š(F)$
+ For a functor /F : ğ’œ â†’ ğ’Ÿ/, this category has â€œF-algebrasâ€, F-ary operations in ğ’Ÿ as, objects
  -- i.e., objects are ğ’Ÿ-arrows $F\, A â†’ A$ --
  and /F/-homomorphisms as morphisms, and it inherits composition and identities from ğ’Ÿ.

  #+BEGIN_EXPORT latex 
  {\setlength{\abovedisplayskip}{-1pt}\setlength{\belowdisplayskip}{-1pt}

  \eqn{defn-Homomorphism}{f : âŠ• â†’_F âŠ— \quad\equiv\quad âŠ• ï¹” f = F\, f ï¹” âŠ— }

  \eqn{id-Homomorphism}{ \Id : âŠ• â†’_F âŠ• }

  \eqn{comp-Homomorhism}{ f ï¹” g : âŠ• â†’_F âŠ™ \qquad\Leftarrow\qquad f : âŠ• â†’_F âŠ— \;\land\; g : âŠ— â†’_F âŠ™}
  }
  #+END_EXPORT

  Note that category axiom \eqref{unique-Type} is not fulfilled since a function can be
  a homomorphism between several distinct operations. However, we pretend it is a category
  in the way discussed earlier, and so the carrier of an algebra is fully determined by
  the operation itself, so that the operation itself can be considered the algebra.

  #+BEGIN_CENTER
  /Theorem \eqref{comp-Homomorhism} renders a semantic property as a syntactic condition!/
  #+END_CENTER

\vspace{1em}

+ A *contravariant functor* ğ’ â†’ ğ’Ÿ is just a functor /ğ’áµ’áµ– â†’ ğ’Ÿáµ’áµ–/.
+ A *bifunctor* from ğ’ to ğ’Ÿ is just a functor /ğ’Â² â†’ ğ’Ÿ/.

* Naturality

A natural transformation is nothing but a structure preserving map between functors.
â€œStructure preservationâ€ makes sense, here, since we've seen already that a functor
is, or represents, a structure that objects might have.

\vspace{1em}

As discussed before for the case /F : ğ’ â†’ ğ’®â„¯ğ“‰/, each /F A/ denotes a structured set
and /F/ denotes the structure itself.

\vspace{1em}

For example, ğ‘° is the structure of pairs, /Seq/ is the structure of sequences,
/ğ‘° Seq/ the structure of pairs of sequences, /Seq Seq/ the structure of sequences of
sequences, and so on.

\vspace{1em}

A â€œtransformationâ€ from structure /F/ to structure /G/ is a family of functions
/t : âˆ€{A} â†’ F A â†’ G A/; and it is â€œnaturalâ€ if each /tâ‚/ doesn't affect the /constituents/
of the structured elements in /F A/ but only reshapes the structure of the elements,
from an /F/-structure to a /G/-structure.

\vspace{1em}

#+BEGIN_CENTER
/Reshaping the structure by t commutes with subjecting the constituents to an arbitrary morphism./

That is, $F\, f ï¹” t_B \;=\; t_A ï¹” G\, f$ for all /f : A â†’ B./
#+END_CENTER

#+LaTeX: \eqn{ntrf-Def}{ Î· : F â†’Ì£ G \quad\equiv\quad âˆ€ f \,â€¢\, F\, f ï¹” Î·_{\tgt\, f}\;=\; Î·_{\src\, f} ï¹” G\, f }

This is `naturally' remembered: Morphism $Î·_{\tgt\, f}$ has type $F (\tgt\, f) â†’ G(\tgt\, f)$ and therefore
appears at the target side of an occurrence of /f/; similarly $Î·_{\src\, f}$ occurs at the source side of an /f/.
/Moreover/ since Î· is a transformation /from/ /F/ to /G/, functor /F/ occurs at the source side of an Î·
and functor /G/ at the target side.

\vspace{1em}

+ One also says /Î·â‚ is natural in/ its parameter /a/.

+ If we take $G = \Id$, then natural transformations $F â†’Ì£ \Id$ are precisely /F/-homomorphisms.
+ Indeed, a natural transformation is a sort-of homomorphism in that the image of a morphism
  after reshaping is the same as the reshaping of the image.

\vspace{1em}

Example natrual transformations
+ /rev : Seq â†’Ì£ Seq : [aâ‚, â€¦, aâ‚™] â†¦ [aâ‚™, â€¦, aâ‚]/
  reverses its argument thereby reshaping a sequence structure into a sequence structure without affecting the constituents.

+ /inits : Seq â†’Ì£ Seq Seq : [aâ‚, â€¦, aâ‚™] â†¦ [[], [aâ‚], â‹¯, [aâ‚, â€¦, aâ‚™]]/
  yields all initial parts of its argument
  thereby reshaping a sequence structure into a sequence of sequences structure, not affecting
  the constituents of its argument.

\vspace{1em}

#+BEGIN_EXPORT latex
\def\begineqns{ \begingroup\setlength{\abovedisplayskip}{-1pt}\setlength{\belowdisplayskip}{-1pt} }
\def\endeqns{ \endgroup }

\def\providedS{ \qquad\Leftarrow\qquad }
\def\lands{ \quad\land\quad }

\begineqns

\eqn{ntr-Ftr}{ JÎ· : JF â†’Ì£ JG \providedS Î· : F â†’Ì£ G \quad \text{ where } (JÎ·)_A â‰” J(Î·_A) }

\eqn{ntr-Poly}{ Î·K : FK â†’Ì£ GK  \hspace{-2ex}\providedS Î· : F â†’Ì£ G \quad \text{ where } (Î·K)_A â‰” Î·_{(K\, A) } }

\eqn{ntrf-Id}{ \Id_F : F â†’Ì£ F \text{\hspace{12em} where } (\Id_F)_A â‰” \Id_{(F\, A)} }

\eqn{ntrf-Compose}{ Îµ ï¹” Î· : F â†’Ì£ H \hspace{2ex}\providedS Îµ : F â†’Ì£ G \lands Î· : G â†’Ì£ H 
\\ \text{ where } (Îµ ï¹” Î·)_A = Îµ_A ï¹” Î·_A
}

\endeqns
#+END_EXPORT

\vspace{1em}

*Category â„±ğ“Šğ“ƒğ’¸(ğ’, ğ’Ÿ)*
consists of functors /ğ’ â†’ ğ’Ÿ/ as objects and natrual transformations between them as objects.
The identity transformation is indeed an identity for transformation composition, which is associative. 

\vspace{1em}

*Heuristic* To prove $Ï† = Ï†â‚ ï¹” â‹¯ ï¹” Ï†â‚™ : F â†’Ì£ G$ is a natural transformation, it suffices
to show that each $Ï†áµ¢$ is a natural transformation.
 + Theorem \eqref{ntrf-Compose} renders proofs of semantic properties to be trivial type checking!
 + E.g., It's trivial to prove /tails = rev ï¹” inits ï¹” Seq rev/ is a natural transformation
   by type checking, but to prove the naturality equation by using the naturality equations of
   /rev/ and /inits/ --no definitions required-- necessitates more writing, and worse: Actual thought! 

* Adjunctions

Nice Stuff âŒ£Ìˆ 

* âˆ Further Reads

+ Roland Backhouse
+ Grant Malcolm
+ Lambert Meertens
+ Jaap van der Woude

* newpage :ignore:
  \newpage
* COMMENT footer

(find-file "CheatSheet.el")

# Local Variables:
# eval: (org-babel-tangle)
# eval: (load-file "CheatSheet.el")
# compile-command: (my-org-latex-export-to-pdf)
# End:
