#+TITLE: Reference Sheet for Elementary Category Theory
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] @@latex:{\tiny\hspace{5.5em}\url{https://github.com/alhassy/CatsCheatSheet}}@@
#+EMAIL: alhassy@gmail.com
#+DESCRIPTION: Cheatsheet of category theory: Adjunctions, [co]limits, [co]products, [co]terminals, etc.
#+TODO: TODO | space
#+OPTIONS: d:nil

# (shell-command "rm CheatSheet.aux")

* More :ignore:

#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{newunicodechar}
#+LATEX_HEADER: \newunicodechar{Ôπî}{\ensuremath{\raisebox{0.4ex}{\tiny \,;\,}}}  %% forward composition Ôπî

#+LATEX_HEADER: \newunicodechar{Œî}{\ensuremath{\Delta}}
#+LATEX_HEADER: \newunicodechar{ùí≥}{\ensuremath{\mathcal{X}}}
#+LATEX_HEADER: \newunicodechar{ùí±}{\ensuremath{\mathcal{V}}}
#+LATEX_HEADER: \newunicodechar{ùí≤}{\ensuremath{\mathcal{W}}}

#+LATEX_HEADER: \newunicodechar{Ãá}{\ensuremath{.}}
#+LATEX_HEADER: \newunicodechar{‚Ä≤}{\ensuremath{'}}


#+LATEX_HEADER: \usepackage{calculation}

#+INCLUDE: CheatSheet/CheatSheetSetup.org

# https://en.wikipedia.org/wiki/Linguistic_relativity#Programming_languages

:nonstop:
(setq org-latex-pdf-process
      '("pdflatex  -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-latex-pdf-process
      '("pdflatex  -shell-escape -output-directory %o %f"))

:End:

# (async-shell-command "rm CheatSheet.tex")

# latex_header: \newunicodechar{ùíû}{\mathcal{C}}

* COMMENT In Defence of Backwards Composition :for_future_self:

For some time, I've preferred forwards composition as in Z notation.
Especially since my academic setting has people using that notation as well.

However here are some reasons I've decided to switch to the traditional format:

+ It is much more ubiquitous; therefore easier to understand without the necessary simple explanation.

+ It is Haskell's notion of function composition, therefore allowing the immediate translation
  of categorically derived programs to be implemented in Haskell. It also permits a nice
  implementation of some categorical concepts without must trouble.

+ I want to motivate the ‚Äúcalculational style‚Äù, so I do not want to deviate in orthogonal
  directions.

* LaTeX Setup :ignore:

# INCLUDE: /Users/musa/MyUnicodeSymbols/MyUnicodeSymbols.sty
#+LATEX_HEADER: \usepackage{CheatSheet/UnicodeSymbols}
# LATEX_HEADER: \usepackage[utf8]{inputenc}
# LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
# LATEX_HEADER: \usepackage{newunicodechar}

# ‚û© \pointer from wasysym package
#+LATEX_HEADER: \usepackage{wasysym}
#+LATEX_HEADER: \newunicodechar{Œ±}{\ensuremath{\alpha}}
#+LATEX_HEADER: \newunicodechar{œÅ}{\ensuremath{\rho}}
#+LATEX_HEADER: \newunicodechar{‚û©}{\,{\text{\pointer}}\,}

#+LATEX_HEADER: \newunicodechar{œï}{\ensuremath{\phi}}
#+LATEX_HEADER: \newunicodechar{‚üµ}{\ensuremath{\longleftarrow}}
#+LATEX_HEADER: \newunicodechar{‚Äº}{\ensuremath{! \! !}}

#+begin_export latex
\def\providedS{ \qquad\Leftarrow\qquad }

\def\impliesS{ \qquad\Rightarrow\qquad }

\def\landS{ \qquad\land\qquad }
\def\lands{ \quad\land\quad }

\def\eqs{ \quad=\quad}

\def\equivs{ \quad\equiv\quad}
\def\equivS{ \qquad\equiv\qquad}

\def\begineqns{ \begingroup\setlength{\abovedisplayskip}{-1pt}\setlength{\belowdisplayskip}{-1pt} }
\def\endeqns{ \endgroup }
% \def\endeqns{ \endgroup \setlength{\belowdisplayskip}{2pt} } % put belowspace back to desired setting
#+END_EXPORT

# See defn-Type, below for an expanded usage; \eqn{name}{formula}
# LaTeX: \setlength{\abovedisplayskip}{5pt} \setlength{\belowdisplayskip}{2pt}
#+LaTeX: \def\eqn#1#2{ \begin{flalign*} #2 && \tag*{\sc #1} \label{#1} \end{flalign*}  }

# LATEX_HEADER: \setlength{\parskip}{1em}
# LaTeX: \setlength{\parskip}{0.5em}

#+LaTeX: \def\room{\vspace{0.5em}}

#+BEGIN_EXPORT latex
\def\Obj{\mathsf{Obj}}
\def\Hom{\mathsf{Hom}}
\def\src{\mathsf{src}}
\def\tgt{\mathsf{tgt}}
\def\Id{\mathsf{Id}}

\def\inl{\mathsf{inl}}
\def\inr{\mathsf{inr}}

\def\bin{I\!\!I}
#+END_EXPORT

* COMMENT Compact Notation

 Why do people look for compact notations? A compact notation leads to
 shorter documents (less lines of code in programming) in which patterns are easier
 to identify and to reason about. Properties can be stated in clear-cut, one-line long
 equations which are easy to memorize. And diagrams such as (2.4) can be easily
 drawn which enable us to visualize maths in a graphical format.

* Categories
#
# The morphisms are a "dependent type" ;-)
#
A *category* ùíû consists of a collection of ‚Äúobjects‚Äù $\Obj\, ùíû$,
  a collection of  ‚Äú(homo)morphisms‚Äù $\Hom_ùíû(a,b)$ for any $a,b : \Obj\,ùíû$
  ---also denoted ‚Äú$a \,\to_ùíû\, b$‚Äù---,
  an operation $\Id$ associating a morphism $\Id‚Çê : \Hom(a,a)$ to each object $a$,
  and a dependently-typed ‚Äúcomposition‚Äù operation
  $\_‚àò\_ : ‚àÄ\{A \, B \, C : \Obj\} ‚Üí \Hom(B,C) ‚Üí \Hom(A,B) ‚Üí \Hom(A,C)$
  that is required to be associative with $\Id$ as identity.

# For other approaches see https://tex.stackexchange.com/a/12035/69371
#
# As we can see from \eqref{defn-Type}\ldots
#

#+LaTeX: \room

  It is convenient to define a pair of operations $\src, \tgt$ from morphisms to objects
  as follows:
\begin{flalign*}
    f : X \to_ùíû Y \quad\equiv\quad \mathsf{src}\; f = X \;\land\; \mathsf{tgt}\; f = Y
   &&
   \tag*{$\src,\tgt$-Definition}
   \label{src-tgt-Definition}
\end{flalign*}

Instead of $\Hom_ùíû$ we can instead assume primitive a ternary relation
$\_:\_‚Üí_ùíû\_$ and regain $\Hom_ùíû$ precisely when the relation is functional
in its last two arguments:
\eqn{type-Unique}{f : A \to_ùíû B \;\;\land\;\; f : A' \to_ùíû B' \;\implies\; A=A' \;\land\; B=B'}
When this condition is dropped, we obtain a /pre-category/; e.g., the familiar /Sets/
is a pre-category that is usually treated as a category by making morphisms
contain the information about their source and target: $(A, f, B) : A ‚Üí B$
rather than just $f$.
\newline
 /This is sometimes easier to give than Hom! C.f. Alg(F)./
\room

Here's an equivalence-preserving property that is useful in algebraic calculations,
#+LaTeX: \eqn{Composition}{ f : A ‚Üí B \lands g : B ‚Üí A \equivs g ‚àò f : A ‚Üí A \lands f ‚àò g : B ‚Üí B}

# A categorical statement is an expression built from notations for objects,
# typing, morphisms, composition, and identities by means of the usual logical
# connectives and quantifications and equality.
#

Examples:

+ [[https://arxiv.org/abs/1312.4818][Linear Algebra:]] Matrices with real number values determine a category whose objects are the natural numbers,
  morphisms $n ‚Üí m$ are $n √ó m$ matrices, $\Id$ is the identity matrix, and composition
  is matrix multiplication.

+ Each preorder determines a category: The objects are the elements
  and there is a morphism $a ‚Üí b$ named, say, ‚Äú$(a, b)$‚Äù, precisely when $a \leq b$;
  composition boils down to transitivity of $\leq$.

+ Each monoid $(M, ‚äï, e)$ gives rise to a category: The objects and the arrows
  are both the elements of$M$, and $k : m ‚Üí n \;‚â°\; k ‚äï m = n$.
  E.g., $(‚Ñï, √ó, 1)$ gives rise to a category whose products are gcd's
  and so properties of products are thus gcd theorems!

+ Each digraph determines a category: The objects are the nodes
  and the paths are the morphisms typed with their starting and ending node.
  Composition is catenation of paths and identity is the empty path.

+ Suppose we have an `interface', in the programming sense,
  of constant, function, and relation symbols ---this is also called a /signature/.

  Let ùíØ be any collection of sentences in the first-order language of signature $\Sigma$.
  Then we can define a category $\mathsf{Mod}\,ùíØ$ whose objects are
  implementations of interface $\Sigma$ satisfying constraints ùíØ, and whose morphisms
  are functions that preserve the $\Sigma$ structure.
  Ignoring constraints ùíØ gives us `functor algebras'.

  Particular examples include monoids and structure-preserving maps between them;
  likewise digraphs, posets, rings, etc and their homomorphisms.

\room

Even when morphisms are functions, the objects need not be sets:
Sometimes the objects are /operations/ ---with an appropriate definition
of typing for the functions. The categories of /F/-algebras are an example
of this.

* ‚ÄúGluing‚Äù Morphisms Together

Traditional function application is replaced by the more generic concept of
functional /composition/ suggested by morphism-arrow chaining:


Whenever we have two morphisms such that the target type of one
of them, say $g : B ‚Üê A$ is the same as the source type of the other,
say $f : C ‚Üê B$ then ‚Äú$f$ after $g$‚Äù, their /composite morphism/,
$f ‚àò g : C ‚Üê A$ can be defined. It ‚Äúglues‚Äù $f$ and $g$ together,
‚Äúsequentially‚Äù:

#+BEGIN_EXPORT latex
\eqn{composition-Type}{
  C \overset{f}{\longleftarrow} % B \lands
  B \overset{g}{\longleftarrow} A \impliesS
  C \overset{\;f ‚àò g}{\longleftarrow} A
}
#+END_EXPORT

Composition is the basis for gluing morphisms together to build more complex morphisms.
However, not every two morphisms can be glued together by composition.

\room

Types provide the interface for putting morphisms together to obtain more complex functions.

\room

A /split/ arises wherever two morphisms do not compose but share the same source.
  - Since they share the same source, their outputs can be paired: $c ‚Ü¶ (f\, c, g\, c)$.
  - This duplicates the input so that the functions can be executed in ‚Äúparallel‚Äù on it.

\room

A /product/ appears when there is no explicit relationship between the types of the morphisms.
  - We regard their sources as projections of a product, whence they can be seen as /splits/.
  - This $(c, d) ‚Ü¶ (f\, c, g\, d)$ corresponds to the ‚Äúparallel‚Äù application of $f$ and $g$,
     each with its /own/ input.

\room

An /either/ arises wherever two morphisms do not compose but share the same target.
  - Apply $f$ if the input is from the ‚Äú$A$ side‚Äù or apply $g$ if it is from the ‚Äú$B$ side‚Äù.
  - This is a ‚Äúcase analysis‚Äù of the input with branches being either $f$ or $g$.

\room

A /sum/ appears when there is no explicit relationship between the types of the morphisms.
  - We regard their targets as injections into a sum, whence they can be seen as /eithers/.

\room

#+LaTeX: \def\transpose#1{ \overline{#1} }
A /transpose/ arises when we need to combine a binary morphism with a unary morphism.
  - I.e., it arises when a composition chain is interrupted by an extra product argument.
  - Express $f$ as a /C/-indexed family, $f_c : A ‚Üí B$, of morphisms such that applying a function at any index
    behaves like $f$; i.e., $f_c \, a = f(c, a)$. Each $f_c$ can now be composed with $g$.
    Let $\transpose{(\;)}$ denote the operation $f ‚Ü¶ f_c$.

\vspace{-0.5em}

#+BEGIN_EXPORT latex
\begineqns

\eqn{split-Type}{ A \overset{f}{\longleftarrow} C \overset{g}{\longrightarrow} B
 \hspace{5.8em}\equivS A √ó B \overset{\;\;‚ü®f,g‚ü©}{\xleftarrow{\hspace*{0.5cm}}} C }

\eqn{x-Type}{ A \overset{f}{\longleftarrow} C \lands B \overset{g}{\longleftarrow} D
 \hspace{1.9em} \equivS A √ó B \overset{f √ó g}{\xleftarrow{\hspace*{0.5cm}}} C √ó D }

\eqn{either-Type}{ A \overset{f}{\longrightarrow} C \overset{g}{\longleftarrow} B
 \hspace{5.9em}\equivS A + B \overset{[f,g]}{\xrightarrow{\hspace*{0.5cm}}} C }

\eqn{+-Type}{ A \overset{f}{\longrightarrow} C \lands B \overset{g}{\longrightarrow} D
 \hspace{2em} \equivS A + B \overset{f + g}{\xrightarrow{\hspace*{0.5cm}}} C + D }

\eqn{transpose-Type}{
  B \overset{f}{\longleftarrow}{C √ó A}
  \hspace{6.9em} \equivS
  B^A \overset{\transpose{f}}{\longleftarrow} C
  }

  % By the well-formedness of the terms, we necessairly have
  % C = tgt g = fst (src f). Hence, both sides have the same information.
  %
\eqn{transpose-combination}{
  B \overset{f}{\longleftarrow}{C √ó A}
  \lands
  C \overset{g}{\longleftarrow} D
  \equivS
  B^A \overset{\transpose{f} ‚àò g}{\xleftarrow{\hspace*{1cm}}} D
  }
\endeqns
#+END_EXPORT

\vspace{1em}

** COMMENT Importance of Compositional Combinators                   :ignore:

 # Paraphrasing Oliveira, ¬ß2.13
 \vspace{3ex}
 The compositional combinators put forward here are equipped with a concise /set of properties/
 which enable programmers to transform programs, reason about them, and perform useful calculations.
 This raises a /programming methodology/ which is scientific and stable.

* Functors

A *functor* /F : ùíú ‚Üí ‚Ñ¨/ is a pair of mappings, denoted by one name,
from the objects, and morphisms, of ùíú to those of ‚Ñ¨ such that
it respects the categorical structure:

#+BEGIN_EXPORT latex
{\setlength{\abovedisplayskip}{-1pt}\setlength{\belowdisplayskip}{-1pt}

\eqn{functor-Type}{F\, f : F\, A \to_‚Ñ¨ F\, B \quad\Leftarrow\quad f : A \to_ùíú B }

\eqn{Functor}{F\, \Id_A \;=\; \Id_{F\, A}}

\eqn{Functor}{F\, (f ‚àò g) \;=\; F\, f \circ F\, g}

}
#+END_EXPORT

\vspace{1em}

The two axioms are equivalent to the single statement that
/functors distribute over finite compositions, with $\Id$ being the empty composition:/
\[ F(f_0 ‚àò \cdots ‚àò f_{n-1}) \;=\; F\, f_0 ‚àò \cdots ‚àò F\, f_{n-1} \]

Use of Functors.
+ In the definition of a category, ‚Äúobjects‚Äù are ‚Äújust things‚Äù for which no internal
  structure is observable by categorical means ---composition, identities, morphisms, typing.
  /Functors form the tool to deal with ‚Äústructured‚Äù objects./

  Indeed in ùíÆ‚ÑØùìâ the aspect of a structure is that it has ‚Äúconstituents‚Äù, and that it is possible
  to apply a function to all the individual constituents; this is done by
  /F f : F A ‚Üí F B/.

+  For example, let $\bin A = A √ó A$ and $\bin f = (x, y) ‚Ü¶ (f\, x, f\, y)$.
  So $\bin$ is or represents the structure of pairs; $\bin\, A$ is the set of pairs of /A/,
  and $\bin\, f$ is the function that applies /f/ to each constituent of a pair.

  - A /binary operation on A/ is then just a function $\bin A ‚Üí A$;
    in the same sense we obtain /F-ary operations/.

+ Also, /Seq/ is or represents the structure of sequences; /Seq A/ is the structure of sequences
  over /A/, and /Seq f/ is the function that applies /f/ to each constituent of a sequence.

+  Even though /F A/ is still just an object, a thing with no observable internal structure, the
  functor properties enable to exploit the ‚Äústructure‚Äù of /F A/ by allowing us to ‚Äúapply‚Äù
  an /f/ to each ‚Äúconstituent‚Äù by using /F f/.

\vspace{1em}

Category $ùíúl‚Ñä(F)$
+ For a functor /F : ùíú ‚Üí ùíü/, this category has /F-algebras/, /F/-ary operations in ùíü as, objects
  --- i.e., objects are ùíü-arrows $F\, A ‚Üí A$ ---
  and /F/-homomorphisms as morphisms, and it inherits composition and identities from ùíü.

  #+BEGIN_EXPORT latex
  {\setlength{\abovedisplayskip}{-1pt}\setlength{\belowdisplayskip}{-1pt}

  \eqn{defn-Homomorphism}{f : ‚äï ‚Üí_F ‚äó \quad\equiv\quad f ‚àò ‚äï = ‚äó ‚àò F\, f}

  \eqn{id-Homomorphism}{ \Id : ‚äï ‚Üí_F ‚äï }

  \def\providedS{\qquad\Leftarrow\qquad}

  \eqn{comp-Homomorhism}{ g ‚àò f : ‚äô ‚Üê_F ‚äï \providedS g : ‚äô ‚Üê_F ‚äó \;\land\; f : ‚äó ‚Üê_F ‚äï}
  }
  #+END_EXPORT

  Note that category axiom \eqref{unique-Type} is not fulfilled since a function can be
  a homomorphism between several distinct operations. However, we pretend it is a category
  in the way discussed earlier, and so the carrier of an algebra is fully determined by
  the operation itself, so that the operation itself can be considered the algebra.

  #+BEGIN_CENTER
  /\ref{comp-Homomorhism} renders a semantic property as a syntactic condition!/
  #+END_CENTER

\vspace{1em}

+ A *contravariant functor* ùíû ‚Üí ùíü is just a functor /ùíû·µí·µñ ‚Üí ùíü/.
+ A *bifunctor* from ùíû to ùíü is just a functor /ùíû¬≤ ‚Üí ùíü/.

* Naturality

A natural transformation is nothing but a structure preserving map between functors.
‚ÄúStructure preservation‚Äù makes sense, here, since we've seen already that a functor
is, or represents, a structure that objects might have.

\room

As discussed before for the case /F : ùíû ‚Üí ùíÆ‚ÑØùìâ/, each /F A/ denotes a structured set
and /F/ denotes the structure itself.

# \room
#
#+LaTeX: \paragraph{\footnotesize \textnormal{Example Structures}}\label{SeqPair-is-Pair-Seq}
\hspace{-1em}:
$\bin$ is the structure of pairs, /Seq/ is the structure of sequences,
/Seq Seq/ the structure of sequences of sequences,
$\bin \, Seq$ the structure of pairs of sequences ---which is naturally isomorphic
to $Seq \, \bin$ the structure of sequences of pairs!---, and so on.

\room

A ‚Äútransformation‚Äù from structure /F/ to structure /G/ is a family of functions \newline
$Œ∑ : ‚àÄ\{A\} ‚Üí F\, A ‚Üí G\, A$; and it is ‚Äúnatural‚Äù if each $Œ∑_A$ doesn't affect the /constituents/
of the structured elements in /F A/ but only reshapes the structure of the elements,
from an /F/-structure to a /G/-structure.

\vspace{0em}

#+BEGIN_CENTER
/Reshaping the structure by Œ∑ commutes with subjecting the constituents to an arbitrary morphism./
#+END_CENTER
# That is, $F\, f Ôπî t_B \;=\; t_A Ôπî G\, f$ for all /f : A ‚Üí B./

\vspace{-2em}
#+LaTeX: \eqn{ntrf-Def}{ Œ∑ : F ‚ÜíÃ£ G \quad\equiv\quad ‚àÄ f \;‚Ä¢\; Œ∑_{\tgt\, f} ‚àò F\, f \;=\; G\, f ‚àò Œ∑_{\src\, f} }

This is `naturally' remembered: Morphism $Œ∑_{\tgt\, f}$ has type $F (\tgt\, f) ‚Üí G(\tgt\, f)$ and therefore
appears at the target side of an occurrence of /f/; similarly $Œ∑_{\src\, f}$ occurs at the source side of an /f/.
/Moreover/ since Œ∑ is a transformation /from/ /F/ to /G/, functor /F/ occurs at the source side of an Œ∑
and functor /G/ at the target side.

\room

+ One also says /Œ∑‚Çê is natural in/ its parameter /a/.

+ If we take $G = \Id$, then natural transformations are /F/-homomorphisms.
   Thus, naturality is a kind of homomorphism condition.
   # $F ‚ÜíÃ£ \Id$ are precisely /F/-homomorphisms.

+ Indeed, a natural transformation is a sort-of homomorphism in that the image of a morphism
  after reshaping is the same as the reshaping of the image.

\room

Example natural transformations
+ /rev : Seq ‚ÜíÃ£ Seq : [a‚ÇÅ, ‚Ä¶, a‚Çô] ‚Ü¶ [a‚Çô, ‚Ä¶, a‚ÇÅ]/
  reverses its argument thereby reshaping a sequence structure into a sequence structure without affecting the constituents.

+ /inits : Seq ‚ÜíÃ£ Seq Seq : [a‚ÇÅ, ‚Ä¶, a‚Çô] ‚Ü¶ [[], [a‚ÇÅ], ‚ãØ, [a‚ÇÅ, ‚Ä¶, a‚Çô]]/
  yields all initial parts of its argument
  thereby reshaping a sequence structure into a sequence of sequences structure, not affecting
  the constituents of its argument.

\room

#+BEGIN_EXPORT latex
\begineqns

\eqn{ntrf-Ftr}{ JŒ∑ : JF ‚ÜíÃ£ JG \providedS Œ∑ : F ‚ÜíÃ£ G \quad \text{ where } (JŒ∑)_A ‚âî J(Œ∑_A) }

\eqn{ntrf-Poly}{ Œ∑K : FK ‚ÜíÃ£ GK  \hspace{-2ex}\providedS Œ∑ : F ‚ÜíÃ£ G \quad \text{ where } (Œ∑K)_A ‚âî Œ∑_{(K\, A) } }

\eqn{ntrf-Id}{ \Id_F : F ‚ÜíÃ£ F \text{\hspace{12em} where } (\Id_F)_A ‚âî \Id_{(F\, A)} }

\eqn{ntrf-Compose}{ Œ∑ ‚àò Œµ : H ‚ÜêÃ£ F \hspace{2ex}\providedS Œ∑ : H ‚ÜêÃ£ G \lands Œµ : G ‚ÜêÃ£ F
\\ \text{ where } (Œ∑ ‚àò Œµ)_A = Œ∑_A ‚àò Œµ_A
 }

\endeqns
#+END_EXPORT

\room

*Category ‚Ñ±ùìäùìÉùí∏(ùíû, ùíü)*
consists of functors /ùíû ‚Üí ùíü/ as objects and natural transformations between them as arrows.
The identity transformation is indeed an identity for transformation composition, which is associative.

\room

*Heuristic* To prove $œÜ = œÜ‚ÇÅ ‚àò ‚ãØ ‚àò œÜ‚Çô : F ‚ÜíÃ£ G$ is a natural transformation, it suffices
to show that each $œÜ·µ¢$ is a natural transformation.
E.g., without even knowing the definitions, naturality of
/tails = Seq rev ‚àò inits ‚àò rev/ can be proven ---just type checking!
# thanks to \eqref{ntrf-Compose}!

\iffalse
 + Theorem \eqref{ntrf-Compose} renders proofs of semantic properties to be trivial type checking!
 + E.g., It's trivial to prove /tails = rev Ôπî inits Ôπî Seq rev/ is a natural transformation
   by type checking, but to prove the naturality equation by using the naturality equations of
   /rev/ and /inits/ ---no definitions required--- necessitates more writing, and worse: Actual thought!
\fi

* Adjunctions

An adjunction is a particular one-one correspondence between different kinds of
morphisms in different categories.

\room

An *adjunction* consists of two functors $L : ùíú ‚Üí ‚Ñ¨$ and $R : ‚Ñ¨ ‚Üí ùíú$,
as well as two (not necessarily natural!) transformations
$Œ∑ : \Id ‚Üí RL$ and $Œµ : LR ‚Üí \Id$ such that

\vspace{-1em}

#+BEGIN_EXPORT latex
\eqn{Adjunction}{\text{\tiny Provided $f : A ‚Üí_ùíú R B$ and $g : L A ‚Üí_‚Ñ¨ B$ }
 \\ f = R g ‚àò Œ∑_A \equivS Œµ_B ‚àò L f = g
}
#+END_EXPORT

Reading right-to-left: In the equation $Œµ_B ‚àò L f = g$ there is a unique solution to the unknown $f$.
Dually for the other direction.

\room

That is,
/each L-algebra g is uniquely determined ---as an L-map followed by an Œµ-reduce---/
/by its restriction to the adjunction's unit Œ∑./

\room

A famous example is ‚ÄúFree ‚ä£ Forgetful‚Äù, e.g. to /define/ the list datatype, for which the above
becomes: Homomorphisms on lists are uniquely determined, as a map followed by a reduce,
by their restriction to the singleton sequences.

\room

We may call $f$ the restriction, or lowering, of $g$ to the ‚Äúunital case‚Äù
and write $f = ‚åäg‚åã = R g ‚àò Œ∑_A$. Also, we may call $g$ the extension, or raising,
of $f$ to an /L/-homomorphism and write $g = ‚åàf‚åâ = Œµ_B ‚àò L f$. The above equivalence
now reads:

#+BEGIN_EXPORT latex
\begineqns

\eqn{Adjunction-Inverse}{f = ‚åäg‚åã \equivS ‚åàf‚åâ = g}

\eqn{lad-Type}{‚åäg‚åã_{A,B} = R g ‚àò Œ∑_A \; : \; A ‚Üí_ùíú R B
 \text{ where } g : L A ‚Üí_‚Ñ¨ B
 }

\eqn{rad-Type}{‚åàf‚åâ_{A,B} = Œµ_B ‚àò L f \; : \; L A ‚Üí_‚Ñ¨ B
 \text{ where } f : A ‚Üí_ùíú R B
 }

\endeqns
#+END_EXPORT

\room
\vspace{1ex}
Note that ‚åà is like `r' and the argument to ‚åà‚åâ must involve the /R/-ight adjoint in its type;
# likewise for
#+LaTeX: {\textbf L}ad takes morphisms involving the {\textbf L}eft adjoint ;)

\room

This equivalence expresses that `lad' $‚åä‚åã$, from \emph{l}eft \emph{ad}jungate,
and `rad' $‚åà‚åâ$, from \emph{r}ight \emph{ad}jungate, are each other's inverses
and constitute a correspondence between certain morphisms.
/Being a bijective pair, lad and rad are injective, surjective, and undo one another./

\room

We may think of ‚Ñ¨ as having all complicated problems so we abstract
away some difficulties by \emph{r}aising up to a cleaner, simpler, domain
via rad ‚åà‚åâ; we then solve our problem there, then go back \emph{down} to
the more complicated concrete issue via ‚åä‚åã, lad.
\newline
( E.g., ‚Ñ¨ is the category of monoids, and ùíú is the category of sets; $L$ is the list functor. )

# Some useful results,
#+BEGIN_EXPORT latex
\begineqns

\eqn{ntrf-Adj}{\text{The Œ∑ and Œµ determine each other and they are \emph{natural} transformations.}}

\vspace{2ex}
‚Äúzig-zag laws‚Äù The unit has a post-inverse while the counit has a pre-inverse:

\eqn{unit-Inverse}{ \Id = R Œµ ‚àò Œ∑}

\eqn{Inverse-counit}{ \Id = Œµ ‚àò L Œ∑}

\vspace{2ex}
The unit and counit can be regained from the adjunction inverses,

\eqn{unit-Def}{ Œ∑ = ‚åä\Id‚åã}

\eqn{counit-Def}{ Œµ = ‚åà\Id‚åâ }

\vspace{2ex}
Lad and rad themselves are solutions to the problems of interest, \eqref{Adjunction}.

\eqn{lad-Self}{Œµ ‚àò L ‚åäg‚åã = g}

\eqn{rad-Self}{R ‚åàf‚åâ ‚àò Œ∑ = f }

\vspace{2ex}
The following laws assert a kind of
monoic-ness for Œµ and a kind of epic-ness for Œ∑.
Pragmatically they allow us to prove an equality
by shifting to a possibly easier equality obligation.

\eqn{lad-Unique}{ R g ‚àò Œ∑ = R g‚Ä≤ ‚àò Œ∑ \equivS g = g‚Ä≤}

\eqn{rad-Unique}{Œµ ‚àò L f \,= Œµ ‚àò L f‚Ä≤ \,\equivS f = f‚Ä≤}

\vspace{2ex}
Lad and rad are natural transformations in the category $‚Ñ±ùìäùìÉùí∏(ùíú^{op} √ó ‚Ñ¨, ùíÆ‚ÑØùìâ)$ realising
$(L X ‚Üí Y) ‚âÖ (X ‚Üí G Y)$ where $X, Y$ are the first and second projection functors
and $(-‚Üí-) : ùíû^{op} √ó ùíû ‚Üí ùíÆ‚ÑØùìâ$ is the hom-functor such that $(f ‚Üí g) h = g ‚àò h ‚àò f$.
\\ By extensionality in ùíÆ‚ÑØùìâ, their naturality amounts to the laws:

\eqn{lad-Fusion}{‚åä y ‚àò g ‚àò L x  ‚åã \;=\; R y ‚àò ‚åäg‚åã ‚àò x }

\eqn{rad-Fusion}{‚åà R y ‚àò f ‚àò  x ‚åâ \;=\; y ‚àò ‚åàf‚åâ ‚àò L x }

\room
\endeqns
#+END_EXPORT

Also,
+ Left adjoints preserve colimits such as initial objects and sums.
+ Right adjoints preserve limits such as terminal objects and products.

* Constant Combinators

#+LaTeX: \def\const#1{ \underline{#1} }

Opposite to the identity functions which do not lose any information,
we find functions which lose all, or almost all, information.
Regardless of their input, the output of these functions is always the
same value.

# \room
#
#+LaTeX: \def\K{\mathcal{K}}
#+LaTeX: \paragraph{\footnotesize \textnormal{The Constant Combinator}}\label{constant-combinator}
$\K : ùíû ‚Üí ‚Ñ±ùìäùìÉùí∏(ùíü,ùíû)$
+ For objects $x$, the ``constant functor'': \\
   $\K{x}\, y = x$ and $\K{x}\, f = \Id_x$ for objects $y$ and morphisms $f$.
+ For morphisms $f$, the ``constant natural transformation'': \\
   $\K{f} : \K{(\src f)} ‚ÜíÃ£ \K{(\tgt f)}$
   sending objects $y$ to morphism $\K{f}\, y = f$.

\room
Sometimes it is convenient to notate $\const{c} = \K \, c$
and refer to this as the /everywhere c/ operation.
#+LaTeX: \eqn{constant-functor-Defn}{\const{c}\, a = c}

The following property defines constant functors at the `pointfree level':
#+LaTeX: \eqn{constant-Fusion}{\const{c} ‚àò F = \const{c} }

Constant functors force any difference in behaviour for any two
functors to disappear:
#+LaTeX: \eqn{constant-Equality}{\const{c} ‚àò F = \const{c} ‚àò G}

Interestingly, functor composition and application
are bridged explicitly by the constant functor:
#+BEGIN_EXPORT latex
\eqn{Functor-Bridge}{ F ‚àò \const{c} = \const{F \, c}}
#+END_EXPORT

# Observe that /constant arrows that are epic necessarily target a terminal object./
* Monics and Epics

Identity functions and constant functions are limit points of the
functional spectrum with respect to information preservation.
All the other functions are in-between: They ‚Äúlose‚Äù some information,
which is regarded as uninteresting for some reason.

\room

How do functions lose information?
Basically in two ways: They may be ‚Äúblind‚Äù enough to confuse different
inputs, by mapping them to the same output, or they may ignore values
of their target. For instance, $\const{c}$ confuses all inputs
by mapping them all onto $c$. Moreover, it ignores all values of its
target apart from $c$.

\room

Functions which do not confuse their inputs are called /monics/:
They are ‚Äúpost-cancellable‚Äù:

#+BEGIN_EXPORT latex
\eqn{monic-Defn}{ f \; \mathsf{monic} \equivS
  \left(‚àÄ h,k \;‚Ä¢\; f ‚àò h = f ‚àò k \equivs h = k\right)
}
#+END_EXPORT

Functions which do not ignore values of their target are called
/epics/: They are ‚Äúpre-cancellable‚Äù:
#+BEGIN_EXPORT latex
\eqn{epic-Defn}{ f \; \mathsf{epic} \equivS
  \left(‚àÄ h,k \;‚Ä¢\; h ‚àò f = k ‚àò f \equivs h = k\right)
}
#+END_EXPORT

Intuitively, $h = k$ on all points of their source precisely when
they are equal on all image points of $f$, since $f$ being epic means
it outputs all values of their source.

\room

It is easy to check that ‚Äúthe‚Äù identity function is monic and epic,
while any constant function $\const{c}$ is not monic and is only
epic when its target consists only of $c$.

* Isos

#+LaTeX: \def\inverse{^{-1}}

An arrow is an /iso/ iff it is invertible; i.e., there is an ‚Äúinverse‚Äù morphism
$f\inverse$ with
\eqn{inverse-Char}{ f ‚àò f\inverse = \Id \landS f\inverse ‚àò f = \Id}

To /construct/ $f\inverse$, we begin by identifying its type which may give
insight into its necessary `shape' ---e.g., as a sum or a product---
then we pick one of these equations and try to reduce it as much as possible
until we arrive at a definition of $fÀò$, or its `components'.

  + E.g.,
    $coassocr = [\Id + \inl, \inr ‚àò \inr]$ of type $(A + B) + C ‚âÖ A + (B + C)$,
    its inverse  /coassocl/ must be of the shape $[x, [y, z]]$ for unknowns
    $x,y,z$ which can be calculated
    by solving the equation $[x, [y, z]] ‚àò coassocr = \Id$ ---Do it!

# --E.g., the inverse of ~assoc~.

\room

The following rules can be of help if $f\inverse$ is found handier than isomorphism $f$
in reasoning,

\begineqns

\eqn{inverse-Shunting1}{ f ‚àò x = y \equivS x = f\inverse ‚àò y}

\eqn{inverse-Shunting2}{ x ‚àò f = y \equivS x = y ‚àò f\inverse}

\endeqns

\room
\room

Isos are necessarily monic and epic, but in general the other way
around is not true.

\room

Isomorphisms are very important because they convert data from one
‚Äúformat‚Äù, say $A$, to another format, say $B$, without losing
information. So $f$ and $fÀò$ are faithful protocols between the two
formats $A$ and $B$.
Of course, these formats contain the same ‚Äúamount‚Äù of information
although the same data adopts a ‚Äúdifferent‚Äù shape in each of them.
‚îÄc.f. \nameref{SeqPair-is-Pair-Seq}.

\room

Isomorphic data domains are regarded as ‚Äúabstractly‚Äù the same;
then one write $A ‚âÖ B$.

Finally, note that all classes of functions referred to so far
---identities, constants, epics, monics, and isos---
are closed under composition.

Monics to the initial object are necessarily isos!
# Simialr to the bottom of a poset.

# \newpage.\newpage
* COMMENT TODO More Morphism Properties

# \NTHM{}{Monic}{ compositionally post-cancellable ---nearly the same formulation as injective! }

If a composition is monic then its first arrow is monic.

\NTHM{}{Epic}{ compositionally pre-cancellable }

If a composition is epic then its last arrow is epic.

\NTHM{}{Split Monic}{ compositionally post-invertible }

\NTHM{}{Split Epic}{ compositionally pre-invertible }

\NTHM{}{Iso}{ Both epic and monic ; i.e., monic and split epic }

* COMMENT space newpage                                                      :ignore:
  \newpage
* Skolemisation
# ‚ÄúUp to Isomorphism‚Äù

If a property $P$ holds for precisely one class of isomorphic objects,
and for any two objects in the same class there is precisely one
isomorphism from one to the other, then we say that
/the P-object is unique up to unique isomorphism/.
For example, in ùíÆ‚ÑØùìâ the one-point set is unique up to a unique isomorphism,
but the two-point set is not.

\room

For example, an object /A/ is ``initial'' iff
$‚àÄ B  \;‚Ä¢\;  ‚àÉ‚ÇÅ f  \;‚Ä¢\;  f : A ‚Üí B$, and such objects are unique
up to unique isomorphism ---prove it!
The formulation of the definition is clear but it's not very well suited for /algebraic manipulation/.

\room

A convenient formulation is obtained by `skolemisation': An assertion of the form
\[ ‚àÄ x \;‚Ä¢\; ‚àÉ‚ÇÅ y \;‚Ä¢\; R \, x \, y \]
is equivalent to: There's a function ‚Ñ± such that
\[ \, \hspace{13em} ‚àÄ x, y \;‚Ä¢\; R \, x \, y \;‚â°\; y = ‚Ñ±\, x  \hspace{8em}\text{\sc(‚Ñ±-Char)} \]
In the former formulation it is the existential quantification ‚Äú$‚àÉ y$‚Äù inside the scope of a universal
one that hinders effective calculation. In the latter formulation the existence claim is brought to a
more global level: A reasoning need no longer be interrupted by the declaration and naming of the
existence of a unique $y$ that depends on $x$; it can be denoted just $‚Ñ±\, x$.
As usual, the final universal quantification can be omitted, thus simplifying the formulation once more.

\room

In view of the important role of the various $y$'s, these $y$'s deserve a particular notation that
triggers the reader of their particular properties. We employ bracket notation such as $‚¶á x ‚¶à$
for such $‚Ñ±\, x$: An advantage of the bracket notation is that no extra parentheses are needed
for composite arguments $x$, which we expect to occur often.

\room

The formula /characterising/ $‚Ñ±$ may be called `‚Ñ±-Char' and it immediately give us some results
by truthifying each side, namely `Self' and `Id'. A bit more on the naming:

| Type        | Possibly non-syntactic constraint on notation being well-formed |
| Self        | It, itself, is a solution                                       |
| Id          | How $\Id$ can be expressed using it                             |
| Uniq        | Its problem has a unique solution                               |
| Fusion      | How it behaves with respect to composition                      |
| Composition | How two instances, in full subcategories, compose               |

# More, to consider.
#
# | Reflection   | How Id can be expressed                                         |
# | Cancellation | How it can be eliminated                                        |
# | Fusion       | How composition goes into it                                    |
# | Absorption   | How a lifted, via functor application, composition goes into it |
# | Naturality   | How it commutes with composition                                |
# | Functor      | How it defines a functor                                        |
# | Definition   | How it's defined for arbitrary morphisms by being defined for the Id case; usually an instance of Absorption; c.f. x/y defined by 1/y defined. |

Note that the last 3 indicate how the concept interacts with the categorical structure:
$=, Ôπî, \Id$. Also note that Self says there's at least one solution and Uniq says there is
at most one solution, so together they are equivalent to ‚Ñ±-Char ---however those two proofs
are usually not easier nor more elegant than a proof of ‚Ñ±-Char directly.

\room

*Proving ‚Ñ±-Char* is straightforwardly accomplished by providing a definition for ‚Ñ±
and establishing ‚Ñ±-Char ---these two steps can be done in parallel! Almost every such
proof has the following format, or a circular implication thereof: For arbitrary $x$ and $y$,

# \vspace{2em}
#+begin_calculation latex
    R \kern0.5ex x \kern0.5ex y
\step[‚â°]{}
    ‚ãÆ
\step[‚â°]{}
    y = \text{‚Äúan expression not involving $y$‚Äù}
\step[‚â°]{ ùíπ‚ÑØùíªùíæùìÉ‚ÑØ $‚Ñ± \, x$ to be the right side of the previous equation }
    y = ‚Ñ± \kern0.5ex x
#+end_calculation

#  [Dangerous] Convention:
#  free variables are quantified implicitly in such a way that the laws in which they appear
#  are well-defined.

 # The relevance of universal properties, such as ‚Ñ±-Char, is that it offers a way of /solving equations/
 # of the form $y = ‚Ñ±\, x$. For example, can the identity be expressed, or `reflected', using this combinator?
 # We just solve the equation $\Id = ‚Ñ±\, x$ for unknown(s) $x$ by appealing to the universal property.

* Initiality

# Convenient definition:
An object /0 is initial/ if there's a mapping $‚¶á-‚¶à$, from objects to morphisms,
such that \ref{initial-Char} holds; from which we obtain a host of useful corollaries.
Alternative notations for $‚¶á B ‚¶à$ are $\text{!`}_B$, or $‚¶á0 ‚Üí B‚¶à$ to make the
dependency on 0 explicit.

#+BEGIN_EXPORT latex
\begineqns

\eqn{initial-Char}{ f : 0 ‚Üí B \equivS f = ‚¶á B ‚¶à }

\eqn{initial-Self}{ ‚¶á B ‚¶à : 0 ‚Üí B }

\eqn{initial-Id}{ \Id‚ÇÄ = ‚¶á 0 ‚¶à }

\eqn{initial-Uniq}{ f, g : 0 ‚Üí B \impliesS f = g }

% Pre-absorption
\eqn{initial-Fusion}{ f : B ‚Üí C \impliesS f ‚àò ‚¶á B ‚¶à = ‚¶á C ‚¶à }

\vspace{2ex}
{\tiny Provided objects $B, C$ are both in ùíú and ‚Ñ¨,
which are full subcategories of some category ùíû:}
\eqn{initial-Compose}{ ‚¶á C ‚Üê B ‚¶à_‚Ñ¨ ‚àò ‚¶áB ‚Üê A‚¶à_ùíú = ‚¶á C ‚Üê A‚¶à_ùíú }
%
% Recall: ùíü is a full-subcategory of ùíû means: ùíü(x,y) = ùíû(x,y) for x,y : Obj ùíü.

\vspace{2ex}
{\tiny Provided ùíü is built on top of ùíû; i.e., ùíü-objects are composite entities in ùíû: }
\eqn{initial-Type}{ B \text{ is an object in ùíü } \impliesS ‚¶á B ‚¶à \text{ is a morphism in ùíû} }

\endeqns
#+END_EXPORT

\vspace{1em}

These laws become much more interesting when the category is built upon another
one and the typing is expressed as one or more equations in the underlying
category. In particular the importance of fusion laws cannot be over-emphasised;
it is proven by a strengthening step of the form
$f ‚àò ‚¶áB‚¶à : 0 ‚Üí C \providedS ‚¶áB‚¶à : 0 ‚Üí B \lands f : B ‚Üí C$.

\room

For example, it can be seen that the datatype of sequences is `the' initial object
in a suitable category, and the mediator $‚¶á-‚¶à$ captures
‚Äúdefinitions by induction on the structure‚Äù! Hence induction arguments
can be replaced by initiality arguments! Woah!

** COMMENT Proving Initiality :moved_to_skolemisation_section:
\room

*Proving Initiality* One may prove that an object $0$ is initial by providing
a definition for $‚¶á-‚¶à$ and establishing initial-Char. Almost every such
proof has the following format, or a circular implication thereof: For arbitrary /f/ and /B/,

\vspace{2em}
#+begin_calculation latex
    f : A ‚Üí B
\step[‚â°]{}
    ‚ãÆ
\step[‚â°]{}
    f = \text{‚Äúan expression not involving $f$‚Äù}
\step[‚â°]{ ùíπ‚ÑØùíªùíæùìÉ‚ÑØ $‚¶á B ‚¶à$ to be the right side of the previous equation }
    f = ‚¶á B ‚¶à
#+end_calculation

\vspace{-2em}

# With the characterisation and init-Identity rules, one can show that initial objects are unique
# up to isomorphism and so I've opted out to naming a representative `0`. Dually, for final objects.
# %
# % See page 38, par 2.22 of Fokkinga's gentle introduction for a nice calculational proof.
#

\newpage

** COMMENT full, luff, subcategory definitions

 \NTHM{}{Subcategory}{ Subcollection of objects and a subcollection of morphisms
   that contains the identities for them and is closed under composition.
 }

 \NTHM{}{Full subcategory}{ Each homset of the morphism subcollection is the whole homset of the parent category.
 That is, it is generated by the objects subcollection.
 }

 \NTHM{}{lluf subcategory}{ The object subcollection contains all objects of the parent category. }

* Colimits

Each colimit is a certain initial object, and each initial object is a certain colimit.

# Colimits are precisely initiality, and generalise sums, coequalisers, and pushouts.

+ A /diagram in ùíû/ is a functor $D : ùíü ‚Üí ùíû$.

    # Let $D : \mathcal{D} \to \mathcal{A}$ be a functor
    #  ---in-fact it suffices to consider this as a graph homomorphism
    #  reifying the nodes and vertices of $\mathcal{D}$ as objects
    #  and morphisms of $\mathcal{A}$.
    #

    #  When giving $D$ and $\mathcal{D}$ via a diagram, as is done below in some
    #  example constructions, then $\mathcal{D}$ is just a subcategory and so
    #  $D$ is just the inclusion functor :-)
    #

+ Recall \nameref{constant-combinator} yielding a functor on objects ---$\const{C}\, x = C$ for objects $x$ and
  $\const{C}\, f = \Id_C$ for morphisms /f/--- and a natural transformation on arrows
  ---$\const{g} = x \mapsto g : \const{A} ‚ÜíÃ£ \const{B}$ for morphism $g : A ‚Üí B$.

+ The category $‚ãÅD$, built upon ùíû, has objects $Œ≥ : D ‚ÜíÃ£ \const{C}$ called ‚Äúco-cones‚Äù, for
  some object $C =: \tgt\, Œ≥$, and a morphism from $Œ≥$ to $Œ¥$ is a ùíû-morphism $x$ such that $\const{x} ‚àò Œ≥ = Œ¥$.

 /`Cones' sit upright on their base, $D$, on a table; `CoCones' sit upright on a co-table!/

+ A /colimit for D/ is an initial object in $‚ãÅ D$; which may or may not exist.

\room

Writing $-‚ï±Œ≥$ for $‚¶á-‚¶à$ and working out the definition of co-cone in terms of equations in ùíû,
  we obtain: /$Œ≥ : Obj(‚ãÅD)$ is a colimit for $D$/ if there is a mapping $-‚ï±Œ≥$ such that /‚ï±-Type/ and
/‚ï±-Char/ hold.

#+BEGIN_EXPORT latex
\begineqns

\eqn{Colimit-Type}{ Œ¥ \text{ cocone for } D \impliesS Œ¥‚ï±Œ≥ : \tgt\, Œ≥ ‚Üí \tgt\,Œ¥}

\vspace{2ex}
Well-formedness convention: In each law the variables are quantified
in such a way that the premise of $\slash$-Type is met.
The notation $Œ¥‚ï±‚ãØ$ is only senseful if Œ¥ is a co-cone for $D$,
like in arithmetic where the notation $m \div n$ is only sensful if $n$ differs from 0.

\eqn{Colimit-Char}{ \const{x} ‚àò Œ≥ = Œ¥ \equivS x = Œ¥ ‚ï± Œ≥ }

\vspace{2ex}
The fraction notation better suggests the \emph{calculational} properties.

% # Maybe call the colimiting object $\bigsqcup D$ ? Since it is similar to the `join'
% # and a cocone is a `proof' that an object is an upper bound?

\vspace{2ex}
Notice that for given $x : C ‚Üí C'$ the equation $Œ¥ ‚ï± Œ≥ = x$ \underline{defines}
Œ¥, since by $\slash$-Char that one equation equivales the family of equations
$Œ¥_A = x ‚àò Œ≥_A$. This allows us to define a natural transformation ---or `eithers' in
the case of sums--- using a single function \emph{having} the type of the mediating arrow.

\eqn{Colimit-Self ; Cancellation}{ \const{Œ¥‚ï±Œ≥} ‚àò Œ≥ = Œ¥}

\eqn{Colimit-Id}{Œ≥‚ï±Œ≥ = \Id}

\eqn{Colimit-Fusion}{x ‚àò Œ¥‚ï±Œ≥ = (\const{x} ‚àò Œ¥) ‚ï± Œ≥}
% Direct Proof:
%
%    Œ≥‚ï≤Œ¥ Ôπî x = Œ≥ ‚ï≤ (Œ¥ Ôπî _x_)
% ‚â°  Œ≥ Ôπî \const{Œ≥‚ï≤Œ¥ Ôπî x} = Œ¥ Ôπî _x_          ‚ï≤-char
% ‚â°  Œ≥ Ôπî \const{Œ≥‚ï≤Œ¥} Ôπî _x_ = Œ¥ Ôπî _x_          const functor
% ‚â°  Œ¥ Ôπî _x_ = Œ¥ Ôπî _x_                         ‚ï≤-self
% ‚â° true                                        =-reflexivity

\eqn{Colimit-Unique ; JointlyEpic}{\const{x} ‚àò Œ≥ = \const{y} ‚àò Œ≥ \impliesS x = y}

% \vspace{2ex}
% This expresses that colimits Œ≥ have an epic-like property: \\
% The component morphisms $Œ≥_A$ are \emph{jointly epic}.

\vspace{2ex}
The following law confirms the choice of notation once more
---just as the above fusion law is nearly mutliplication into the numerator.

\eqn{Colimit-Compose}{Œµ‚ï±Œ¥ ‚àò Œ¥‚ï±Œ≥  = Œµ‚ï±Œ≥}

% # ? \alert{where} $\delta$ and $\epsilon$ are $D$ cocones
% # ? and anything appearing to the left? of $\under$ being a colimit!

\vspace{2ex}
The next law tells us that functors distribute over the ‚ï±-notation
provided the implicit well-formedness condition that
$FŒ≥$ is a colimit holds ---clearly this condition is valid when $F$
preserves colimits.

\eqn{Colimit-Functor-Dist}{F(Œ¥‚ï±Œ≥) = FŒ¥ ‚ï± FŒ≥}

\eqn{Colimit-Pre-Functor-Elim}{Œ¥F‚ï±Œ≥F = Œ¥‚ï±Œ≥}

% Recall $\eta F$ be the natural transformation $x \mapsto \eta_{F\, x}$.
%  Let $\gamma$ and $\gamma F$ be colimits for the same diagram, then

\endeqns
#+END_EXPORT




\room
\room

Let $()_x : \varnothing ‚ÜíÃ£ \K{x}$ be the natural transformation from the
empty functor $\varnothing : \mathbf{0} \to ùíû$ to the constant functor.
\vspace{-0.8em}
#+LaTeX:  \eqn{Initiality as colimit}{‚¶áB‚¶à \eqs ()_B ‚ï± ()_0}

# Needless to say, my favourite:
Cocones under $D$ correspond one-to-one with arrows from its colimit:
\vspace{-0.8em}
#+LaTeX:  \eqn{Colimit as Adjunction}{(D ‚ÜíÃ£ \K C) \;\cong\; (\mathsf{CoLim}\,D \to C) \!\qquad \text{ where } \mathsf{CoLim}\,D = \tgt Œ≥ }
* Limits

Dually, the category $‚ãÄD$ has objects being ‚Äúcones‚Äù $Œ≥ : \const{C} ‚ÜíÃ£ D$ where $C =: \src\, Œ≥$
is a ùíû-object, and a morphism to $Œ≥$ /from/ $Œ¥$ is a ùíû-morphism $x$ such that $Œ≥ ‚àò \const{x} = Œ¥$.
In terms of ùíû, /$Œ≥ : Obj(‚ãÄ D)$ is a limit for $D$/ if there is a mapping $Œ≥‚ï≤-$ such that
the following ‚ï≤-Type and ‚ï≤-Char hold, from which we obtain a host of corollaries.
As usual, there is the implicit well-formedness condition.
# Theorem ‚ï≤-Unique expresses that limits Œ≥ have an monic-like property:
# The component morphisms $Œ≥_A$ are \emph{jointly monic}.
#
# Well-formedness convention: In each law the variables are quantified
# in such a way that the premise of $/$-Type is met.
# The notation $Œ¥‚ï±‚ãØ$ is only senseful if Œ¥ is a cone for $D$,
# like in arithmetic where the notation $m/n$ is only sensful if $n$ differs from 0.

#+BEGIN_EXPORT latex
\begineqns

\eqn{Limit-Type}{ Œ¥ \text{ cone for } D \impliesS Œ≥ ‚ï≤ Œ¥ : \src\, Œ¥ ‚Üí \src\,Œ≥}

\eqn{Limit-Char}{ Œ≥ ‚àò \const{x}  = Œ¥ \equivS x = Œ≥ ‚ï≤ Œ¥ }

\eqn{Limit-Self}{ Œ≥ ‚àò \const{Œ≥ ‚ï≤ Œ¥}  = Œ¥}

\eqn{Limit-Id}{Œ≥‚ï≤Œ≥ = \Id}

\eqn{Limit-Fusion}{Œ≥‚ï≤Œ¥  ‚àò x = Œ≥ ‚ï≤ (Œ¥ ‚àò \const{x})}

\eqn{Limit-Unique ; JointlyMonic}{Œ≥ ‚àò \const{x} = Œ≥ ‚àò \const{y} \impliesS x = y}

\eqn{Limit-Functor-Dist}{F(Œ≥ ‚ï≤ Œ¥) = FŒ≥ ‚ï≤ FŒ¥}

\eqn{Limit-Pre-Functor-Elim}{Œ≥F ‚ï≤ Œ¥F = Œ≥‚ï≤Œ¥}
% Direct proof:
%
%    Œ¥F‚ï±Œ≥F = Œ¥‚ï±Œ≥
% ‚â°  Œ¥F = (Œ¥ ‚ï± Œ≥) Ôπî Œ≥F
% ‚â°  (Œ¥ ‚ï± Œ≥ Ôπî Œ≥)F = (Œ¥ ‚ï± Œ≥) Ôπî Œ≥F
% ‚â°  (Œ¥ ‚ï± Œ≥ Ôπî Œ≥)FA = ((Œ¥ ‚ï± Œ≥) Ôπî Œ≥F)A
% ‚â°  Œ¥ ‚ï± Œ≥ ; Œ≥FA  = Œ¥‚ï±Œ≥ Ôπî Œ≥FA
% ‚â°  true
%
\endeqns
#+END_EXPORT

\vspace{-1em}

\newpage
* Sums
Take $D$ and $ùíü$ as suggested by $Dùíü = \left( \overset{A}{‚Ä¢} \;\;\; \overset{B}{‚Ä¢} \right)$.
Then a cocone Œ¥ for $D$ is a two-member family $Œ¥ = (f, g)$ with
$f : A ‚Üí C$ and $g : B ‚Üí C$, where $C = \tgt\, Œ¥$.

\room

Let $Œ≥=(\inl, \inr)$ be a colimit for $D$, let $A + B = \tgt\,Œ≥$, and write
$[f, g]$ in-place of $Œ≥‚ï≤(f, g)$, then the ‚ï≤-laws yield:
/$(\inl, \inr, A+B)$ form a sum of $A$ and $B$/ if there is a mapping $[-,-]$
such that \ref{[]-Type} and \ref{[]-Char} hold.

#  Take $D$ and $\mathcal{D}$ as suggested by $D\,\mathcal{D} = (\spot\!\!\!\!^A \; \spot\!\!\!\!^B)$, for given
#  objects $A = \src f$ and $B = \src g$, with colimit $\gamma = (\mathsf{inl}, \mathsf{inr})$.
# #+LaTeX:  \eqn{Sum as colimit, ‚ï±-[]}{[f,g] \eqs (\mathsf{inl}, \mathsf{inr}) \under (f,g)}

#+BEGIN_EXPORT latex
\begineqns

\eqn{[]-Type}{f : A ‚Üí C \lands g : B ‚Üí C \impliesS [f, g] : A + B ‚Üí C}

\eqn{[]-Char}{ x ‚àò \inl = f \lands x ‚àò \inr = g \equivS x = [f, g] }

\eqn{[]-Cancellation; []-Self}{ [f, g] ‚àò \inl = f \landS [f, g] ‚àò \inr = g}

\eqn{[]-Id}{ [\inl, \inr] = \Id}

\eqn{[]-Unique}{ x ‚àò \inl = y ‚àò \inl \lands x ‚àò \inr = y ‚àò \inr \impliesS x = y}

\eqn{[]-Fusion}{ x ‚àò [f , g] = [x ‚àò f, x ‚àò g] }

\vspace{2ex}
The implicit well-formedness condition in the next law is that
$(F\,\inl, F\,\inr, F(A+B))$ form a sum of $F\,A$ and $F\, B$.
%  ---which clearly holds if $F$ preserves sums.

\eqn{[]-Functor-Dist}{F \, [f, g]_ùíû = [F \, f , F \, g]_ùíü \qquad\text{ where } F : ùíû ‚Üí ùíü}
%
% f : A ‚Üí C
% g : B ‚Üí C
% F[f,g]     : F(A + B) ‚Üí F C
% [F f, F g] : F A + F B ‚Üí F C
%
% Types are okay since, by assumption, F(A + B) forms the sum of FA and FB,
% That is, (F A + F B) ‚âî F(A + B)
%
% Direct proof:
%
%    F[f,g] = [Ff, Fg]
% ‚â°  F[f,g] Ôπî F inl = F f  ‚àß F[f,g] Ôπî F inr = F g
% ‚â°  F([f,g] Ôπî inl) = F f  ‚àß F([f,g] Ôπî inr) = F g
% ‚áê [f,g] Ôπî inl = f  ‚àß [f,g] Ôπî inr = g
% ‚â°  [f,g] = [f,g]
% ‚â°  true

\endeqns
#+END_EXPORT

\room
\room

In the pointwise setting, notice that the cancellation law serves to define the casing construct [-,-].
Then that casing is a form of conditional can be read from the characterisation.
With this view, fusion, post-distributivity of composition over casing is just
the usual law that function application distributes over conditionals
and the casing extensionality law is the body-idempotency of conditionals.

\room

For categories in which sums exist, we define for $f : A ‚Üí B$ and $g : C ‚Üí D$,

\begineqns

\eqn{+-Definition}{ f + g = [ \inl ‚àò f, \inr ‚àò g] : A + C ‚Üí B + D}

\eqn{Injections-Naturality}{ (f + g) ‚àò \inl = f ‚àò \inl \landS (f + g) ‚àò \inr = \inr ‚àò g }

\eqn{Extensionality}{ [h ‚àò \inl , h ‚àò \inr] = h}

\eqn{Absorption}{ [h, j] ‚àò (f + g) = [h ‚àò f, j ‚àò g] }

\eqn{+-BiFunctoriality}{ \Id + \Id = \Id \landS (f + g) ‚àò (h + j) = (f ‚àò h) + (g ‚àò j)}

\eqn{Structural Equality}{ [f,g] = [h, j] \equivS f = h \lands g = j }

\endeqns

\newpage

* Products

#+BEGIN_EXPORT latex
\def\fst{\mathsf{fst}}
\def\snd{\mathsf{snd}}
#+END_EXPORT

Take $D$ and $ùíü$ as suggested by $Dùíü = \left( \overset{A}{‚Ä¢} \;\;\; \overset{B}{‚Ä¢} \right)$.
Then a cone Œ¥ for $D$ is a two-member family $Œ¥ = (f, g)$ with
$f : C ‚Üí A$ and $g : C ‚Üí B$, where $C = \tgt\, Œ¥$.

\room

Let $Œ≥=(\fst, \snd)$ be a limit for $D$, let $A + B = \tgt\,Œ≥$, and write
$‚ü®f, g‚ü©$ in-place of $(f, g)‚ï±Œ≥$, then the ‚ï±-laws yield:
/$(\fst, \snd, A √ó B)$ form a product of A and B/ if there is an operation
$‚ü®-,-‚ü©$ satisfying the Char and Type laws below; from which we obtain a host of corollaries.

#+BEGIN_EXPORT latex
\begineqns

\eqn{Pair-Type}{f : C ‚Üí A \lands g : C ‚Üí B \impliesS ‚ü®f, g‚ü© : C ‚Üí A √ó B}

\eqn{Pair-Char}{ \fst ‚àò x = f \lands \snd ‚àò x = g \equivS x = ‚ü®f, g‚ü© }

\eqn{Pair-Cancellation; Pair-Self}{ \fst ‚àò ‚ü®f, g‚ü© = f \landS \snd ‚àò ‚ü®f, g‚ü© = g}

\eqn{Pair-Id}{ ‚ü®\fst, \snd‚ü© = \Id}

\eqn{Pair-Unique}{ \fst ‚àò x = \fst ‚àò y  \lands \snd ‚àò x = \snd ‚àò y \impliesS x = y}

\eqn{Pair-Fusion}{ ‚ü®f , g‚ü© ‚àò x = ‚ü®f ‚àò x , g ‚àò x‚ü© }

\eqn{Pair-Functor-Dist}{F \, ‚ü®f, g‚ü©_ùíû = ‚ü®F \, f , F \, g‚ü©_ùíü \qquad\text{ where } F : ùíû ‚Üí ùíü}

\endeqns
#+END_EXPORT

\room
\room

The characterisation says that the essential properties of ordered pairs
is that their components are retrievable and they are
completely determined by their components.

\room

Notice that the cancellation rule is essentially the /definitions of projections/ in the pointwise setting;
likewise absorption is akin to the pointwise definition of the product bi-map.

\room

The fusion laws give us a pointfree rendition of their usual pointwise
definitions: All applications have been lifted to compositions!
# Likewise for the absorption laws.

# These are essentially a re-write of the sum laws.

\room

For categories in which products exist, we define for $f : A ‚Üí B$ and $g : C ‚Üí D$,

\begineqns

\eqn{x-Definition}{ f √ó g = ‚ü® f ‚àò \fst, g ‚àò \snd ‚ü© : A √ó C ‚Üí B √ó D}

\eqn{Projections-Naturality}{ \fst ‚àò (f √ó g) = f ‚àò \fst \landS \snd ‚àò (f √ó g) = g ‚àò \snd }

\eqn{Extensionality}{ ‚ü®\fst ‚àò h, \snd ‚àò h‚ü© = h}

\eqn{Absorption}{ (f √ó g) ‚àò ‚ü®h, j‚ü© = ‚ü®f ‚àò h, g ‚àò j‚ü© }

\eqn{x-BiFunctoriality}{ \Id √ó \Id = \Id \landS (f √ó g) ‚àò (h √ó j) = (f ‚àò h) √ó (g ‚àò j)}

\eqn{Structural Equality}{ ‚ü®f,g‚ü© = ‚ü®h, j‚ü© \equivS f = h \lands g = j }

\endeqns

# \newpage
* Finitary Sums and Products

All properties studied for binary /splits/ and binary /eithers/ extend to the
finitary case. For the particular situation $n = 1$, we will have $‚ü®f‚ü©=[f]=f$
and $\inl = \fst = \Id$, of course.

\room

For the particular situation $n = 0$,
finitary products ‚Äúdegenerate‚Äù to terminal object 1 and finitary sums ‚Äúdegenerate‚Äù to initial object 0.
The standard notation for the empty split $‚ü®‚ü©$ is $!_C$, where $C$ is the source.
Dually, the standard notation for the empty either $[]$ is $?_C$.

# Exercise 2.30: Particularise the exchange law to empty products and empty coproducts; i.e., 1 and 0!

\eqn{Empty Exchange Rule}{ ‚ü®‚ü©_0 = []_1 }

# \newpage

* Mixing products and coproducts

Any $f : A + B ‚Üí C √ó D$ can be expressed alternatively as an /either/
or as a /split/. It turns out that both formats are identical:
# The Interchange rule.
\vspace{-1.5em}
\eqn{Exchange Rule}{ ‚ü®[f,g], [h,j]‚ü© = [‚ü®f,h‚ü©,‚ü®g,j‚ü©] }

E.g., $\mathsf{undistr}  = ‚ü®[\fst, \fst], \snd + \snd‚ü© = [\Id √ó \inl, \Id √ó \inr] : (A √ó B) + (A √ó C) ‚Üí A √ó (B + C)$.

# Notice that this law above is self-dual.

# Also, by the exchange rule,
\begineqns

\eqn{Cool-Property}{ [f √ó g, h √ó k] \;=\; ‚ü® [f, h] ‚àò (\fst + \fst), [g, k] ‚àò (\snd + \snd)‚ü© }

\eqn{Co-cool-Property}{ ‚ü®f + g, h + k‚ü© \;=\; [ (\inl √ó \inl) ‚àò ‚ü®f, h‚ü©, (\inr √ó \inr) ‚àò ‚ü®g, k‚ü©] }
# Direct proof:
#
#   [ ‚ü®f, h‚ü© Õæ (\inl √ó \inl), ‚ü®g, k‚ü© Õæ (\inr √ó \inr)]
# = [ ‚ü®inl ‚àò f , inl ‚àò h‚ü©, ‚ü®inr ‚àò g, inr ‚àò k‚ü© ]      absorption
# = ‚ü® [inl ‚àò f, inr ‚àò g], [inl ‚àò h, inr ‚àò k]‚ü©       exchange
# = ‚ü® f + g, h + k ‚ü©                               defns
\endeqns

\room

Also, since constants ignore their inputs,
#+LaTeX: \eqn{Exchange-with-constant}{ [‚ü® f, \const{k} ‚ü©, ‚ü® g , \const{k} ‚ü©] = ‚ü® [f, g], \const{k} ‚ü© }
# Proof:
#
#   [‚ü® f, _k_ ‚ü©, ‚ü® g , _k_ ‚ü©]
# = ‚ü® [f, g], [ _k_ , _k_ ]‚ü©        exchange
# = ‚ü® [f, g], _k_ ‚àò [ Id, Id ]‚ü©   fusion
# = ‚ü® [f, g], _k_ ‚ü©               constants

* COMMENT space vfill                                                        :ignore:
    \vfill
* References

#+LaTeX: {\color{white}.}

[[https://maartenfokkinga.github.io/utwente/mmf92b.pdf][A Gentle Introduction to Category Theory ‚îÄ the calculational approach]]
\newline
by [[https://maartenfokkinga.github.io/utwente/][Maarten Fokkinga]]

\vspace{1em}

An excellent introduction to category theory with examples motivated from programming, in-particular
working with sequences. All steps are shown in a calculational style ---which Fokkinga
has made [[https://ctan.org/tex-archive/macros/latex/contrib/calculation][available]] for use with LaTeX--- thereby making it suitable for self-study.

\vspace{1em}

Clear, concise, and an illuminating read.

\vspace{1em}

I've deviated from his exposition by using backwards composition `‚àò' rather
than diagrammatic composition `;', as such my limit notation is his colimit notation! Be careful.

\vspace{1em}

I've also consulted the delightful read [[http://www4.di.uminho.pt/~jno/ps/pdbc_part.pdf][Program Design by Calculation]] of [[http://www4.di.uminho.pt/~jno/][Jos√© Oliveira]].

\vspace{0.5em}

Very accessible for anyone who wants an introduction to functional programming!
The category theory is mostly implicit, but presented elegantly!

\vspace{-0.5em}

:More:
+ [ ] [[https://link.springer.com/content/pdf/10.1007%2F978-3-642-32202-0_2.pdf][Generic Programming with Adjunctions]]
+ [ ] [[http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/acmmpc-calcfp.pdf][Calculating Functional Programs]]
      - [[https://www.sciencedirect.com/science/article/pii/S157106610480906X?via%3Dihub][When is a function a fold or an unfold?]]
      - [[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.1735][The Under-Appreciated Unfold]]

+ [ ] [[https://www.researchgate.net/profile/Lambert_Meertens/publication/267305882_Category_Theory_for_Program_Construction_by_Calculation/links/54dbd91f0cf2a7769d9403a6/Category-Theory-for-Program-Construction-by-Calculation.pdf][Category Theory for Program Construction by Calculation]]
+ [ ] [[http://maartenfokkinga.github.io/utwente/mmfphd.pdf][Law and Order in Algorithmics]]
+ [ ] [[http://maartenfokkinga.github.io/utwente/mmf90.pdf][Homo- and Catamorphisms, Reductions and Maps: An Overview]]
+ [ ] [[http://maartenfokkinga.github.io/utwente/#detail_0000003538][Monadic Maps and Folds for Arbitrary Datatypes]]
+ [ ] [[http://www.cs.nott.ac.uk/~pszgmh/bananas.pdf][Bananas in Space: Extending Fold and Unfold to Exponential Types]]
+ [ ] [[http://maartenfokkinga.github.io/utwente/mmf90j.pdf][Adjunctions formulated as cata/anamorphisms]]
+ [X] [[http://www.cs.ox.ac.uk/jeremy.gibbons/publications/reladj.pdf][Relational Algebra by Way of Adjunctions]]
+ [X] [[http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/hodgp-journal.pdf][Design Patterns as Higher‚àíOrder Datatype‚àíGeneric Programs]]
+ [ ] [[http://www.cs.ox.ac.uk/jeremy.gibbons/publications/proyo.pdf][What You Needa Know about Yoneda]]
      - [[http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf][Profunctor Optics]]

[[http://www.cs.ox.ac.uk/people/nicolas.wu/papers/Hylomorphisms.pdf][Conjugate Hylomorphisms, Or: The Mother of All Structured Recursion Schemes]]

[[http://www.cs.ox.ac.uk/jeremy.gibbons/publications/progorn.pf][Programming with Ornaments]] ---how dependent types show binomial heaps as fancy binary numbers?
  - [[http://www.cs.ox.ac.uk/people/hsiang-shang.ko/pcOrn/pcOrn.pdf][Modularising Inductive Families]]

:End:

** COMMENT Further Reads

 + Roland Backhouse
 + Grant Malcolm
 + Lambert Meertens
 + Jaap van der Woude

 + /Adjunctions/ by Fokkinga and Meertens

 + Backus' FP and Iverson's APL are examples of pointfree programming
   languages; look them up ;-)

* To Read

  + [[http://www.cwru.edu/artsci/math/wells/pub/ttt.html][Toposes, Triples and Theories]] by Michael Barr and Charles Wells
  + [[https://arxiv.org/pdf/1803.05316.pdf][Seven Sketches in Compositionality: An Invitation to Applied Category Theory]]
  + [[https://arxiv.org/abs/math/0502550][Frobenius algebras and ambidextrous adjunctions]] by Aaron Lauda
  + [[http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf][Functorial Semantics of Algebraic Theories]] by F. William Lawvere
  + [[http://www.tac.mta.ca/tac/reprints/articles/10/tr10.pdf][Basic Concepts of Enriched Category Theory]] by G.M. Kelly
  + [[http://golem.ph.utexas.edu/category/2008/03/physics_topology_logic_and_com.html][Rosetta Stone]]

* space newpage                                                      :ignore:
  \newpage
* Monoidal and Closed Categories

  #+latex: \def\eval{\mathsf{eval}}

  It is rather common that we have a notion of pairing for types for which there is a unit type.
  Examples include products with the initial object, sums with the terminal object, or for
  the category of endofunctors: Functor composition with the identity functor.

  # Monoidal categories are also called ‚Äútensor categories‚Äù

  \room

  A /monoidal category/ /(ùíû, ‚äó, I, Œ±, Œª, œÅ)/ consists of a category ùíû with bifunctor
  \newline
  $\_{}‚äó\_{} : ùíû^2 ‚Üí ùíû$ and object /I : Obj ùíû/
  ---referred to as the ‚Äòtensor product‚Äô and ‚Äòtensor unit---
  and three natural isomorphisms:
  \newline
  The ‚Äò(right-to-left) associator‚Äô /Œ±_{A, B, C} : A ‚äó (B ‚äó C) ‚âÖ (A ‚äó B) ‚äó C/ and
  \newline
  the ‚Äòunitors‚Äô  /Œª_A : I ‚äó A ‚âÖ A/ and /œÅ_A : A ‚äó I ‚âÖ A/ such that:

  0. The order of re-parensization, outer-most or inner-most first, does not matter; i.e.,
     the two obvious maps witnessing $A ‚äó (B ‚äó (C ‚äó D)) ‚Üí ((A ‚äó B) ‚äó C) ‚äó D$ are identical:
     $Œ±_{A ‚äó B, C, D} \;‚àò\; Œ±_{A, B, C ‚äó D} \eqs Œ±_{A, B, C} ‚äó \Id_D \;‚àò\; Œ±_{A, B ‚äó C, D}\;‚àò\; \Id_A ‚äó Œ±_{B, C, D}$.

  1. Unit elimination paths are the same even if unnecessary associtivity is performed; i.e.,
     the two obvious maps witnessing $A ‚äó (I ‚äó B) ‚Üí A ‚äó B$ are identical:
     \newline
     $\Id_A ‚äó Œª_B \eqs (œÅ_A ‚äó \Id_B) \;‚àò\; Œ±_{A, I, B}$.

  Mnemonic: Œª, ‚ÄòL‚Äôambda, is for ‚ÄòL‚Äôeft unitor; œÅ, ‚ÄòR‚Äôho, is for ‚ÄòR‚Äôight unitor.

  \room

  Unfolding some of that up yields:
  + $\Id ‚äï \Id = \Id$ and $(f ‚àò g) ‚äó (h ‚àò k) = (f ‚äó h) ‚àò (g ‚äó k)$
  + $Œ± ‚àò (f ‚äó (g ‚äó h)) = ((f ‚äó g) ‚äó h) ‚àò Œ±$
  + $Œª ‚àò (\Id ‚äó f) = f ‚àò Œª$
  + $œÅ ‚àò (f ‚äó \Id) = f ‚àò œÅ$

  *Mac Lane's coherence theorem:* Any well-typed diagram built from ‚äó, Œ±, Œª, œÅ commutes.

  :TO_PROVE:
  + Iteration Laws ? :: $Œª_{X ‚äó Y} = (Œª_X ‚äó \Id_Y) ‚àò Œ±$ and $œÅ_{X ‚äó Y} = \Id_X ‚äó œÅ_Y ‚àò Œ±Àò$

    Proof

     Let's show the first one only.

          Id ‚äó Œª_{X ‚äó Y}
       =  œÅ ‚äó Id_{X ‚äó Y} ‚àò Œ±
       =  œÅ ‚äó (Id_X ‚äó Id_Y) ‚àò Œ±
       =  Œ±Àò ‚àò ((œÅ ‚äó Id_X) ‚äó Id_Y) ‚àò Œ± ‚àò Œ±
       =  Œ±Àò ‚àò (((Id ‚äó Œª_X) ‚àò Œ±Àò) ‚äó Id_Y) ‚àò Œ± ‚àò Œ±
       =  Œ±Àò ‚àò (Id ‚äó Œª_X) ‚äó Œ±Àò ‚àò Œ± ‚àò Œ±
       =  Œ±Àò ‚àò Œ± ‚àò Id ‚äó (Œª_X ‚äó Œ±Àò) ‚àò Œ±Àò ‚àò Œ± ‚àò Œ±
       =  Id ‚äó (Œª_X ‚äó Œ±Àò) ‚àò Œ±

       MA: Shuchks! ???

       Œª_{X ‚äó Y} = Œª_X ‚äó Id_Y
     ‚â°{ unit-equivalence-left, see below }
       Id ‚äó Œª_{X ‚äó Y} = Id ‚äó (Œª_X ‚äó Id_Y)
     ‚â°{ unitor law }
       (œÅ ‚äó Id_{X ‚äó Y}) ‚àò Œ± = Id ‚äó (Œª_X ‚äó Id_Y)
     ‚â°{ BiFunctoriality }
       (œÅ ‚äó (Id_X ‚äó Id_Y)) ‚àò Œ± = Id ‚äó (Œª_X ‚äó Id_Y)
     ‚â°{ Œ± naturality; Œ± invertible }
       Œ±Àò ‚àò ((œÅ ‚äó Id_X) ‚äó Id_Y) ‚àò Œ± ‚àò Œ± = Id ‚äó (Œª_X ‚äó Id_Y)
     ‚â°{ unitors; Œ± invertible }
       Œ±Àò ‚àò (((Id ‚äó Œª_X) ‚àò Œ±Àò) ‚äó Id_Y) ‚àò Œ± ‚àò Œ± = Id ‚äó (Œª_X ‚äó Id_Y)
     ‚â°{ unitors; Œ± invertible }
       Œ±Àò ‚àò (((Id ‚äó Œª_X) ‚àò Œ±Àò) ‚äó Id_Y) ‚àò Œ± ‚àò Œ± = Id ‚äó (Œª_X ‚äó Id_Y)


     Œª_{X ‚äó Y} : I ‚äó (X ‚äó Y) ‚Üí X ‚äó Y
     (Œª_X ‚äó Id_Y) ‚àò Œ±Àò

  + Agreement Law :: $Œª_I = œÅ_I$
    Proof

      Since -‚äó Id is an equivalence,

         Œª_I ‚äó Id_I
      =  Œª_{I ‚äó I} ‚àò Œ±Àò     ;; iteration law
      =  (Id_I ‚äó Œª_I) ‚àò Œ±Àò  ;; Œª naturality with f := Œª, then eliminate Œª since it's invertible
      =  (œÅ_I ‚äó Id_I) ‚àò Œ± ‚àò Œ±Àò ;; unitors
      =   œÅ_I ‚äó Id_I

      Thus, Œª_I = œÅ_I.

  Elementary remarks on units in monoidal categories
  https://arxiv.org/pdf/math/0507349.pdf

  :END:

  :Theorems:

  1. Id ‚äó Œª ‚àò Œ±Àò = œÅ ‚äó Id   ---duh, from unitors
  2. Œª_I = œÅ_I

     Proof:   Œª = œÅ ‚áî Id ‚äó Œª = Id ‚äó œÅ ‚áî p ‚äó Id ‚àò Œ± = Id ‚äó œÅ ‚áî{ œÅ invertible} p ‚àò p ‚äó Id ‚àò Œ± = p ‚àò Id ‚äó œÅ ‚áî œÅ ‚àò œÅ ‚àò Œ± = œÅ ‚àò œÅ ‚áî Œ± = Id ???
  3. Œª ‚àò Œ±Àò = Œª ‚äó Id
  4. Id ‚äó œÅ = œÅ ‚àò Œ±
  5. Œª_{I ‚äó X} = Id ‚äó Œª_X

     Proof: Œª ‚àò Id ‚äó Œª ={ naturality } Œª ‚àò Œª
            Whence, since Œª invertible, Id ‚äó Œª = Œª  :-)

  6. œÅ_{I ‚äó X} = œÅ_X ‚äó Id

     See (5)

  7. The unit object, I, is unique up to unique isomorphism; ie if I‚Ä≤, Œª‚Ä≤, œÅ‚Ä≤ is another unit object then I ‚âÖ I‚Ä≤.

  :End:
  :More:
  Moreover, the two obvious maps (I ‚äó A) ‚äó B ‚Üí A ‚äó B, namely Œª ‚äó Id and Œª ‚àò Œ±Àò,
  can be shown to coincide.

  Why?

     Œª ‚äó Id = Œª ‚àò Œ±Àò
  ‚â°  Œª ‚äó Id ‚àò Œ± = Œª

  --

  1. Œ± ‚àò Œ± = Œ± ‚äó Id ‚àò Œ± ‚àò Id ‚äó Œ±  ‚îÄassocitator
  2. Id ‚äó Œª = œÅ ‚äó Id ‚àò Œ±   ‚îÄunitors
  3. (Id ‚äó) is an equivalence
  4. ‚à¥ WTS: Id ‚äó (Œª ‚äó Id) = Id ‚äó (Œª ‚àò Œ±Àò)
  5. BiFunctoriality of ‚äó means WTS:
     Id ‚äó (Œª ‚äó Id) = (Id ‚äó Œª) ‚àò (Id ‚äó Œ±Àò).
  6. Œ± ‚àò Id ‚äó (Œª ‚äó Id) = (Id ‚äó Œª) ‚äó Id ‚àò Œ±  ‚îÄnaturality of Œ± applied to Id, Œª, Id
  7. Œ± ‚àò Id ‚äó (Œª ‚äó Id) = (œÅ ‚äó Id ‚àò Œ±) ‚äó Id ‚àò Œ±  ‚îÄusing 2 on 6
  8. Œ± ‚àò Id ‚äó (Œª ‚äó Id) = (œÅ ‚äó Id) ‚äó Id  ‚àò  Œ± ‚äó Id  ‚àò  Œ±  ‚îÄbifunctoriality of ‚äó
  9. Id ‚äó (Œª ‚äó Id) = Œ±Àò ‚àò (œÅ ‚äó Id) ‚äó Id  ‚àò  Œ± ‚äó Id  ‚àò  Œ±  ‚îÄinvertibility of Œ±
  10. Id ‚äó (Œª ‚äó Id) = œÅ ‚äó (Id ‚äó Id) ‚àò Œ±Àò  ‚àò  (Œ± ‚äó Id)  ‚àò  Œ±  ‚îÄnaturality of Œ±
  11. Id ‚äó (Œª ‚äó Id) = œÅ ‚äó Id ‚àò Œ±Àò  ‚àò  (Œ± ‚äó Id)  ‚àò  Œ±  ‚îÄbifunctoriality of ‚äó
  12. Id ‚äó (Œª ‚äó Id) = (Id ‚äó Œª) ‚äó Œ±Àò ‚àò Œ±Àò  ‚àò  (Œ± ‚äó Id)  ‚àò  Œ±  ‚îÄusing (2), note Œ± invertible
  13. Id ‚äó (Œª ‚äó Id) = Œ±Àò ‚àò Id ‚äó (Œª ‚äó Œ±Àò) ‚àò (Œ± ‚äó Id)  ‚àò  Œ±  ‚îÄnaturality of Œ±
  14. Id ‚äó (Œª ‚äó Id) = Œ±Àò ‚àò (Id ‚àò Œ±) ‚äó ((Œª ‚äó Œ±Àò) ‚àò Id) ‚àò  Œ±  ‚îÄBiFunctoriality of ‚äó
  15. Id ‚äó (Œª ‚äó Id) = Œ±Àò ‚àò (Œ± ‚äó (Œª ‚äó Œ±Àò)) ‚àò  Œ±  ‚îÄBiFunctoriality of ‚äó
  16. Id ‚äó (Œª ‚äó Id) = (Œ± ‚äó Œª) ‚äó Œ±Àò ‚àò Œ±Àò ‚àò Œ±  ‚îÄnaturality of Œ±
  17. Id ‚äó (Œª ‚äó Id) = (Œ± ‚äó Œª) ‚äó Œ±Àò  ‚îÄinverses and units

  derp :'(

  :End:
  :Also:

  We can show that Œª = œÅ : I ‚äó I ‚âÖ I.

  1. Œ± ‚àò Œ± = Œ± ‚äó Id ‚àò Œ± ‚àò Id ‚äó Œ±  ‚îÄassocitator
  2. Id ‚äó Œª = œÅ ‚äó Id ‚àò Œ±   ‚îÄunitors
  3. (‚äó Id) is an equivalence.
  4. WTS: Œª ‚äó Id = œÅ ‚äó Id
  5. Œª ‚àò Œ±Àò = Œª ‚äó Id ‚îÄfrom the ‚Äúother‚Äù unit coherence
  6. (Id ‚äó Œª) ‚àò Œ±Àò = œÅ ‚äó Id ‚îÄ(2)
  7. WTS: Œª ‚àò Œ±Àò = (Id ‚äó Œª) ‚äó Œ±Àò
  8. WTS: Œª = (Id ‚äó Œª) ‚äó Œ±Àò ‚àò Œ±

     derp :'(

  :End:

  \room

  \eqn{Unit-Equivalence-Left}{ \Id ‚äó f = \Id ‚äó g  \equivS  f = g }
  \eqn{Unit-Equivalence-Right}{ f ‚äó \Id = g ‚äó \Id \equivS  f = g }
  :Unit-equiv-pf:
  Note e is the unit of ¬∑ precisely when e ¬∑ e = e and both (e¬∑), (¬∑e) are bijective.

  As such, (I ‚äó) and (‚äó I) are equivalences; in particular, they reflect equalities.

    Id ‚äó f = Id ‚äó g
  ‚áí Œª ‚àò Id ‚äó f = Œª ‚àò Id ‚äó g   ;; composition
  ‚áí f ‚àò Œª = g ‚àò Œª             ;; Œª Naturality
  ‚áí f = g                     ;; Œª invertible

  Whence: Id ‚äó f = Id ‚äó g  ‚â°  f = g

  :End:
  :More_attempts:

  Id ‚äó Œª = œÅ ‚äó Id ‚àò Œ±
  œÅ ‚äó Id = (Id ‚äó Œª) ‚àò Œ±Àò

  ??

  1. œÅ ‚äó Id = (Id ‚äó Œª) ‚àò Œ±Àò
  2. Œª ‚àò Œ±Àò = Œª ‚äó Id
  3. Id ‚äó œÅ = œÅ ‚àò Œ±

  For 1:
  1) œÅ ‚äó Id = Id ‚äó Œª ‚àò Œ±Àò ‚îÄunitors
  2)

  For 2:

  1) Œ± ‚àò Œ± = Œ± ‚äó Id ‚àò Œ± ‚àò Id ‚äó Œ±  ‚îÄassocitator
  2) Id ‚äó Œª = œÅ ‚äó Id ‚àò Œ±   ‚îÄunitors
  3) (Id ‚äó) is an equivalence
  4)

        Œª ‚àò Œ±Àò = Œª ‚äó Id
     ‚â°  Id ‚äó (Œª ‚àò Œ±Àò) = Id ‚äó (Œª ‚äó Id)
     ‚â°  Œ± ‚àò Id ‚äó (Œª ‚àò Œ±Àò) = Œ± ‚àò Id ‚äó (Œª ‚äó Id)
     ‚â°  Œ± ‚àò Id ‚äó (Œª ‚àò Œ±Àò) = (Id ‚äó Œª) ‚äó Id ‚àò Œ±
     ‚â°  Œ± ‚àò Id ‚äó (Œª ‚àò Œ±Àò) = ((œÅ ‚äó Id) ‚àò Œ±Àò) ‚äó Id ‚àò Œ±
     ‚â°  Œ± ‚àò Id ‚äó (Œª ‚àò Œ±Àò) = ((œÅ ‚äó Id) ‚àò Œ±Àò) ‚äó (Id ‚àò Id) ‚àò Œ±
     ‚â°  Œ± ‚àò Id ‚äó (Œª ‚àò Œ±Àò) = (œÅ ‚äó Id) ‚äó Id ‚àò (Œ±Àò ‚äó Id) ‚àò Œ±



      Id ‚äó (Œª ‚äó Id)
    = Œ±Àò ‚àò ((Id ‚äó Œª) ‚äó Id) ‚àò Œ±
    = Œ±Àò ‚àò (((œÅ ‚äó Id) ‚äó Id) ‚àò Œ±) ‚àò Œ±
    = (Œ±Àò ‚àò ((œÅ ‚äó Id) ‚äó Id)) ‚àò Œ± ‚àò Œ±
    = ((œÅ ‚äó Id) ‚àò Œ±Àò) ‚àò Œ± ‚àò Œ±
    = (œÅ ‚äó Id) ‚àò Œ±Àò ‚àò Œ± ‚àò Œ±
    = (œÅ ‚äó Id) ‚àò Œ±
    = ((Id ‚äó Œª) ‚àò Œ±Àò) ‚àò Œ±
    = Id ‚äó Œª


     ‚áî  Id ‚äó (Œª ‚äó Id) = (Id ‚äó Œª) ‚àò (Id ‚äó Œ±Àò)
     ‚áî  Id ‚äó (Œª ‚äó Id) = Id ‚äó (Œª ‚äó Œ±Àò)
     ‚áî  Œª ‚äó Id = Œª ‚äó Œ±Àò   (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

  :End:

  \room

  Examples
  + Common examples include preordered monoids thought of as monoidal categories.
  + Functor categories $ùíû^ùíû$ with tensor being functor composition.
  + Any category with finite co/products is monoidal using sums or products.
  + The ‚Äòfree strict monoidal category‚Äô on ùíû has objects being
    finite lists of ùíû-objects where an arrow exists only between equal length
    lists and it is a list of ùíû-morphisms between the corresponding components;
    tensor is catenation with the empty list as the unit object.
    # + The category ùíûùí∂ùìâ is cartesian closed: The internal-hom is the functor category of functors and natural transformations.
  + Symmetric monoidal categories are closed under products, and this has a right
    adjoint yielding functor categories of sym. mon. cats.

  Interestingly, tensor distributes over sums: ~(A + B) ‚äó C ‚âÖ (A ‚äó C) + (B ‚äó C)~.
  :Proof:
  By Yoneda,

   (A + B) ‚äó C  ‚Üí X
  ‚âÖ A + B  ‚Üí  C ‚á® X
  ‚âÖ (A  ‚Üí  C ‚á® X) √ó (B  ‚Üí  C ‚á® X)
  ‚âÖ (A ‚äó C  ‚Üí  X) √ó (B ‚äó C  ‚Üí  X)
  ‚âÖ (A ‚äó C) + (B ‚äó C)  ‚Üí  X

  :End:

  \room

  A *lax monoidal functor* $F : ùí± ‚ü∂ ùí±‚Ä≤$ is a functor that sub-factors over product:
  $F \, x_0 ‚äó ‚ãØ ‚äó F\, x_n ‚ü∂Ãá F(x‚ÇÄ ‚äó ‚ãØ ‚äó x_n)$.
  :More_detail:
  More formally, there are transformations
  $œï : I ‚ü∂Ãá F\, I$ and $œï : F\,X ‚äó F\,Y ‚ü∂Ãá F(X ‚äó Y)$ that are natural in $X$ and $Y$
  that are compatible with the monoidal structure:
  The obvious arrows $I ‚äó F\, X ‚ü∂ F\, X$ coincide as do those for
  $F\, X ‚üµ F\, x ‚äó I$, namely $Œª = F Œª ‚àò œï ‚àò œï ‚äó \Id$ and $œÅ = F œÅ ‚àò œï ‚àò \Id ‚äó œï$,
  and re-associating commutes with functor application in that the two ways
  $(F\, X ‚äó F\, Y) ‚äó F\, Z ‚ü∂ F\, (X ‚äó (Y ‚äó Z))$ coincide, namely
  $F\, Œ± ‚àò œï ‚àò œï ‚äó \Id  = œï ‚àò \Id ‚äó œï ‚àò Œ±$.
  If the transformations are isomorphims, the qualifier ‚Äòlax‚Äò is dropped
  and sometimes replaced by ‚Äòstrong‚Äô.
  :End:

  \room

  \room
  A *Cartesian-closed category* is a monoidal category where the tensor
  is categorical product and all exponentials exist.
  These categories are in correspondence with the models of simply typed
  lambda-calculus. If it has all finite sums as well, then it's known as
  *bicartesian closed*, in which case products necessarily distribute over sums.

  ùí± is *semicartesian* if any of the following equivalent statements is true.
  1. Unit object $I$ is terminal; in which case one says ùí± is *semicartesian.*
  2. It has a natural ‚Äòdeletion‚Äô $‚Äº_X : X ‚ü∂ I$ with $‚Äº_I = \Id_I$.
  3. It has natural ‚Äòprojections‚Äô $œÄ·µ¢ : X‚ÇÅ ‚äó X‚ÇÇ ‚ü∂ X·µ¢$ with $œÄ‚ÇÅ : I ‚äó I ‚âÖ I : ŒªÀò$.
     :FurtherLaws:
     The following can then be shown to be true?

     + œÄ‚ÇÅ ‚àò œÄ‚ÇÅ = œÄ‚ÇÅ ‚àò Œ±   :  (X ‚äó Y) ‚äó Z ‚ü∂ X
     + œÄ‚ÇÇ ‚àò œÄ‚ÇÇ = œÄ‚ÇÇ ‚àò Œ±Àò  :  X ‚äó (Y ‚äó Z) ‚ü∂ Z
     + Projections involving a unit equal to œÅ or Œª; e.g.,
       œÄ‚ÇÅÀ£‚Å± = œÅ.

     :End:

  # Whence, having projections and deletion maps is a property, not a structure!
  :EquivalenceProofs:
  We demonstrate the proof chain 2 ‚áí 1 ‚áí 3 ‚áí 2 to show the equivalences.

  --------------------------------------------------------------------------------
  2 ‚áí 1:

     Let's show I ‚âÖ ùüô, the terminal object with !_X : X ‚ü∂ ùüô.
     Indeed ‚Äº ‚àò ! : I ‚ü∂ I and by naturality of !!,
     this equals !!_I which is Id_I by assumption.

     Likewise, ! ‚àò !! ={ naturality } !_ùüô ={ unicity } Id_ùüô.

     Whence I ‚âÖ 1 with !Àò = !!.

     Whence, !! is a unique map X ‚ü∂ I for any X; indeed
     for any f,g:

        f, g : X ‚ü∂ I
     ‚áí  ! ‚àò f, ! ‚àò g : X ‚ü∂ ùüô
     ‚áí  ! ‚àò f = ! ‚àò g
     ‚â°  f = g , since ! is post inverse !!.

  --------------------------------------------------------------------------------
  1 ‚áí 3:

     Let œÄ‚ÇÅ : X‚ÇÅ ‚äó X‚ÇÇ ‚ü∂ X‚ÇÅ := œÅ ‚àò (Id ‚äó !)

     This is indeed natural: For any f : X ‚ü∂ Y,
     œÄ‚ÇÅ ‚àò (f ‚äó f) = f ‚àò œÄ‚ÇÅ as follows.

        œÄ‚ÇÅ ‚àò (f ‚äó f)
     =  œÅ ‚àò (Id ‚äó !) ‚àò (f ‚äó f)
     =  œÅ ‚àò ((Id ‚àò f) ‚äó (! ‚àò f))
     =  œÅ ‚àò (f ‚äó !)                ;; identity and naturality of !
     =  œÅ ‚àò (f ‚äó Id)               ;; coherency of !!_I = Id_I
     =  f ‚àò œÅ                      ;; naturality of œÅ
     = f ‚àò Id ‚àò œÅ                  ;; Identities
     = f ‚àò œÅ ‚àò (Id ‚äó Id)           ;; naturality of œÅ
     = f ‚àò œÅ ‚àò (Id ‚äó !)            ;; coherency of !!_I = Id_I
     = f ‚àò œÄ‚ÇÅ

     This proof was constructed by ‚Äúburning the candle‚Äù at both ends;
     i.e., simultaneously rewriting both sides until they met.

     Likewise œÄ‚ÇÇ can be formed and found to be natural.

     The coherency condition, œÄ‚ÇÅ : I ‚äó I ‚âÖ I is proven by finding an
     inverse i as follows.

        i ‚àò œÄ
     ={ i : I ‚ü∂ I ‚äó I, so inverse of Œª_I = œÅ_I is a good candidate for i }
        œÅÀò ‚àò œÄ
     ={ definition of œÄ }
        œÅÀò ‚àò œÅ ‚àò (Id_I ‚äó !_I)
     ={ Inverses and coherency of ! }
        Id_I ‚äó Id_I
     ={ BiFunctoriality }
        Id_I

     Neato!

  --------------------------------------------------------------------------------
  3 ‚áí 2:


     Let !!_X : X ‚ü∂ I :=  œÄ‚ÇÅ ‚àò ŒªÀò

     This is natural:

       !! ‚àò f
     = œÄ‚ÇÅ ‚àò ŒªÀò ‚àò f
     = œÄ‚ÇÅ ‚àò (Id ‚äó f) ‚àò Œª Àò  ;; naturality of ŒªÀò is (Id ‚äó g) ‚àò Œª Àò = Œª Àò ‚àò g
     = Id ‚àò œÄ‚ÇÅ ‚àò Œª Àò        ;; naturality of œÄ‚ÇÅ
     = !!                   ;; identities and definition of !!

    Moreover, it is coherent, !! = œÄ‚ÇÅ ‚àò ŒªÀò = Id, by the coherency of œÄ‚ÇÅ.
  :End:

  If in addition it is symmetric with (natural involution) $œÉ : X ‚äó Y ‚ü∂ Y ‚äó X$
  and has a natural ‚Äòdiagonal‚Äô $Œî_X : X ‚ü∂ X ‚äó X$
  such that the obvious maps $X ‚ü∂ X$ coincide
  --- i.e., $Œª ‚àò (! ‚äó Id) ‚àò Œî = Id = œÅ ‚àò (Id ‚äó !) ‚àò Œî$,
  ‚Äúduplicating data, then deleting a copy, is the same as doing nothing‚Äù---
  then it is necessairly cartesian!

  :Cartesian_SemiProof:
  For any A and B, let us show that A ‚äó B is their product.
  That is, for any f : C ‚ü∂ A and g : C ‚ü∂ B
  let us construct a unique map ‚ü®f, g‚ü© : C ‚ü∂ A ‚äó B
  whose projections are f and g.

  Let us try to use whatever's lying around to construct something
  of type C ‚ü∂ A ‚äó B then define that to be ‚ü®f,g‚ü©.

     f : C ¬≠‚Üí A  ‚àß  g : C ‚ü∂ B
  ‚áí  f ‚äó g : C ‚äó C ‚Üí A ‚äó B
  ‚áí  f ‚äó g ‚àò Œî : C ‚Üí A ‚äó B

  ‚à¥ Define ‚ü®f, g‚ü© := f ‚äó g ‚àò Œî

  Components are extracted by projections:

     œÄ‚ÇÅ ‚àò ‚ü®f , g‚ü©
  =  œÄ‚ÇÅ ‚àò f ‚äó g ‚àò Œî
  = { naturality of œÄ‚ÇÅ }
    f ‚àò œÄ‚ÇÅ ‚àò Œî
  = { claim }
    f

  Where I claim œÄ‚ÇÅ ‚àò Œî : X ‚Üí X ‚Äúdrop after duplication‚Äù is the identity:

     œÄ‚ÇÅ ‚àò Œî
  = { identities }
    Id ‚àò œÄ‚ÇÅ ‚àò Œî
  = { naturality }
    œÄ‚ÇÅ ‚àò (Id ‚äó !) ‚àò Œî
  = { coherency of Œî }
    œÄ‚ÇÅ ‚àò œÅÀò
  = { Projections involving a unit equal to œÅ or Œª }
    Id
:End:

# So, a symmetric monoidal category
# becomes a category with finite products when we can duplicate and
# discard.
#

  \room

  An /exponential for Y/ is characterised by the following adjoint isomorphism
  that is natural in /Y/ and /Z:/
  #+begin_export latex
  \eqn{Exponential-Char}{‚åä\_{}‚åã \;:\; X ‚äó Y ‚Üí Z \quad‚âÖ\quad X ‚Üí (Y ‚û© Z) \;:\; ‚åà\_{}‚åâ }
  #+end_export

  \room
  + Note that ‚åä_‚åã generalises currying, and ‚åà_‚åâ generalises uncurrying.
  + The counit $\eval_Z = ‚åà\Id_{Y ‚û© z}‚åâ : (Y ‚û© Z) ‚äó Y ‚Üí Z$ is called the /evaluation morphism./

#+BEGIN_EXPORT latex
\begineqns

\eqn{Exp-Internalised-Char}{ X ‚û© (Y ‚û© Z)  \quad‚âÖ\quad  (X ‚äó Y) ‚û© Z}

\eqn{Exp-Unit}{ I ‚û© Z \quad‚âÖ\quad Z }

% false?
% \eqn{Exp-Distributivity}{X ‚û© (Y ‚äó Z) \quad‚âÖ\quad (X ‚û© Y) ‚äó (X ‚û© Z)}

% false?
% \eqn{Exp-Terminality}{ Z ‚û© I \quad‚âÖ\quad I }

% Self, Char, Id, Fusion, Unique, Compose?
%
% \eqn{CoEq-Char}{ x ‚àò p = q \equivS x = q ‚ï± p }
%
% \eqn{CoEq-Self}{ q‚ï±p ‚àò p = q}
%
% \eqn{CoEq-Id}{p‚ï±p = \Id}
%
% \eqn{CoEq-Fusion}{x ‚àò q‚ï±p = (x ‚àò q)‚ï±p}
%
% \eqn{CoEq-Unique}{x ‚àò p = y ‚àò p \impliesS x = y}
%
% \eqn{CoEq-Compose}{r‚ï±q ‚àò q‚ï±p = r‚ï±p}
%
\endeqns
#+END_EXPORT
:Exp-Internalised-Char_PROOF:
By Yoneda,

  A ‚Üí X ‚û© (Y ‚û© Z)
‚âÖ A ‚äó X ‚Üí (Y ‚û© Z)
‚âÖ (A ‚äó X) ‚äó Y ‚Üí Z
‚âÖ A ‚äó (X ‚äó Y) ‚Üí Z
‚âÖ A ‚Üí (X ‚äó Y) ‚û© Z
:End:
:Exp-Unit_PROOF:
By Yoneda,

  A ‚Üí I ‚û© Z
‚âÖ A ‚äó I ‚Üí Z
‚âÖ A ‚Üí Z
:End:

  \room
  When exponentials always exists, one refers to $\_{}‚û©\_{} : ùíû √ó ùíû^{op} ‚Üí ùíû$
  as /the internal hom/ and says /(ùíû, ‚äó, I, Œ±, Œª, œÅ, ‚û©)/ is a *closed monoidal category*.

  \room
  In the cartesian case, the /entire/ collection of morphisms $X ‚Üí Y$
  is encoded by the /single/ object $X ‚û© Y$. That is, $X ‚Üí Y \quad‚âÖ\quad 1 ‚Üí (X ‚û© Y)$ in ùíÆ‚ÑØùìâ.

  \room
  # Claim:
  # The following natural transformation is natural in $X$ and $Y$, and
  # dinatural in $W$.
  #
  # Proof?

  # Claim: The second one is dinatural in X; proof?

  #+BEGIN_EXPORT latex
  \begineqns

  \eqn{Left-Internal-Yoneda}{
  ‚åà‚åà \eval \,‚àò\, \Id ‚äó \eval \,‚àò\, Œ±^{-1}‚åâ‚åâ
  \;:\; (X ‚û© Y) ‚Üí (W ‚û© X) ‚û© (W ‚û© Y)
  }

  \eqn{Internal-Identities}{ ‚åà Œª_X ‚åâ \;:\; I ‚Üí (X ‚û© X) }
  \endeqns
#+END_EXPORT

  \room
  More generally, a *closed category* is a category ùíû with a bifunctor
  $\_{}‚û©\_{}$ and two ‚Äòcoherent‚Äô transformations as above.

  :Left_Yoneda__Proof:

    (X ‚û© Y)  ‚Üí  (W ‚û© X) ‚û© (W ‚û© Y)
  ‚âÖ ((X ‚û© Y) ‚äó (W ‚û© X)) ‚äó W  ‚Üí  Y

  We now compose:

    ((X ‚û© Y) ‚äó (W ‚û© X)) ‚äó W
  ‚âÖ{ Œ±^{-1}_{X ‚û© Y, W ‚û© X, W} }
    (X ‚û© Y) ‚äó ((W ‚û© X) ‚äó W)
  ‚Üí{ Id ‚äó eval_W }
    (X ‚û© Y) ‚äó X
  ‚Üí{ eval_X }
    Y

 Whence,
 ‚åà ‚åà eval_X ‚àò \Id ‚äó eval_W ‚àò Œ±^{-1}_{X ‚û© Y, W ‚û© X, W} ‚åâ_{(X ‚û© Y) ‚äó (W ‚û© X),W, Y}
 ‚åâ_{X ‚û© Y, W ‚û© X, W ‚û© Y}
 :End:

  :Internal_Ids_Proof:

    I ‚Üí (X ‚û© X)
  ‚âÖ I ‚äó X ‚Üí X

  Whence,
    ‚åà Œª_X ‚åâ : I ‚Üí (X ‚û© X)
  :End:

  \room

  It is common to notate $X ‚û© Y, ‚åäf‚åã$ by $Y^X, \transpose{f}$.
#+BEGIN_EXPORT latex
\begineqns

% i.e., g is the ‚Äútranspose‚Äù of f.
\eqn{Transpose-Char}{ f \,=\, \eval \,‚àò\, g ‚äó \Id \equivS \transpose{f} = g }

\eqn{Transpose-Self}{ \eval \,‚àò\, \transpose{f} ‚äó \Id \eqs f}

% \eqn{Transpose-Id}{\transpose{\eval} \eqs \Id}

\eqn{Transpose-Fusion}{ \transpose{f} ‚àò h \eqs \transpose{f \,‚àò\, h ‚äó \Id } }
%
% \eqn{CoEq-Unique}{x ‚àò p = y ‚àò p \impliesS x = y}
%
% \eqn{CoEq-Compose}{r‚ï±q ‚àò q‚ï±p = r‚ï±p}
%
\endeqns
#+END_EXPORT
:Transpose-char-pf:

Given f : X ‚äó Y ‚Üí Z
show ‚àÉ‚ÇÅ g : X ‚Üí (Y ‚û© Z) such that f = eval_A ‚àò g ‚äó Id_A

Indeed,

  eval ‚àò (g ‚äó Id)
= ‚åà Id ‚åâ ‚àò (g ‚äó Id)
= ‚åà Id ‚àò g ‚åâ  , by rad-fusion
= ‚åà g‚åâ

Whence, f = ‚åàg‚åâ and so g = ‚åä f ‚åã lol

:End:
:Transpose-fusion-pf:

Given f : X ‚äó A ‚Üí B and h : Y ‚Üí X,

   ‚åäf‚åã ‚àò h = ‚åä f ‚àò h ‚äó Id ‚åã : Y ‚Üí A ‚û© B

By lad fusion, or:

   ‚åäf‚åã ‚àò h = ‚åä ? ‚åã
‚â°  ‚åä?‚åã = ‚åäf‚åã ‚àò h                      ;; symmetry of ‚Äò=‚Äô
‚â°  ? = eval ‚àò (‚åäf‚åã ‚àò h) ‚äó Id          ;; transpose-char
‚â°  ? = eval ‚àò (‚åäf‚åã ‚àò h) ‚äó (Id ‚àò Id)   ;; identities
‚â°  ? = eval ‚àò (‚åäf‚åã ‚äó Id) ‚àò (h ‚äó Id)   ;; bi-functoriality
‚â°  ? = f ‚àò (h ‚äó Id)                   ;; transpose-self

:End:
:Transpose-compose-pf:
   ‚åäf‚åã ‚àò ‚åäg‚åã = ‚åä?‚åã
 ‚â° ? = eval ‚àò (‚åäf‚åã ‚àò ‚åäg‚åã) ‚äó Id
 ‚â° ? = eval ‚àò (‚åäf‚åã ‚àò ‚åäg‚åã) ‚äó (Id ‚àò Id)
 ‚â° ? = eval ‚àò (‚åäf‚åã ‚äó Id) ‚àò (‚åäg‚åã ‚äó Id)
 ‚â° ? = f ‚àò (‚åäg‚åã ‚äó Id)
:End:

# \newpage

* Enrichment & Internal Algebraic Structures

  A *Category ùí≥ enriched in a monoidal category ùí±* or a *ùí±-category*
    is essentially a category but its hom-types are objects of ùí±.
    Formally, there is a collection ~Obj ùí≥~ and for each pair ~A, B~
    of such ‚Äòobjects‚Äô there is a ‚Äòhom-object‚Äô ~ùí≥(A, B)~ in ùí±,
    and there are two ùí±-morphisms:
    1. Composition: $Œº_{A, B, C} : ùí≥(B, C) ‚äó ùí≥(A, B) ‚ü∂ ùí≥(A, C)$
       - Associativity: The two obvious ways $(ùí≥(C, D) ‚äó ùí≥(B, C)) ‚äó ùí≥(A, B) ‚ü∂ ùí≥(A, D)$
         coincide.
    2. Identities:  $Œ∑_A : I ‚ü∂ ùí≥(A, A)$.
       - Unity: The obvious maps $I ‚äó ùí≥(A, B) ‚ü∂ ùí≥(A, B)$ coincide,
         as do the obvious maps $ùí≥(A, B) ‚äó I ‚ü∂ ùí≥(A, B)$.

   \room
   A usual category is just a ùíÆ‚ÑØùìâ-category.

   \room
   A /monoid in ùí±/ is an object $M$ along with two morphisms
   $Œº : M ‚äó M ‚ü∂ M, Œ∑ : I ‚ü∂ M$ such that the former is associative
   and has the latter as unit. Notice that monoids /in/ ùí± are ‚Äòuntyped‚Äô
   analogues of ùí±-categories. A ‚Äòmonad‚Äô is a monoid in a category
   of endofunctors with composition as tensor.
   - If M is a monoid in ùí± and F : ùí± ‚ü∂ ùí≤ is a monoidal functor,
     then F M is a monoid in ùí≤. Woah!

   \room
   In a monoidal category with natural transformations ‚Äòdiscard‚Äô
   $!_X : X ‚ü∂Ãá I$ and ‚Äòduplicate‚Äô $Œî_X : X ‚ü∂Ãá X ‚äó X$,
   such as Cartesian monoidal categories, a /group/ is like a monoid but with
   an additional morphism $i : M ‚ü∂ M$ such that the inverse axioms
   hold; e.g., $e = x ¬∑ x^{-1}$ takes the point-free shape
   $Œ∑ ‚àò !_M = Œº ‚àò (\Id ‚äó i) ‚àò Œî$.
   In an arbitrary monoidal category, a /Hopf algebra/ is like a group
   where $Œî_M$ and $!_M$ exist for our specific $M$. These generalise groups.

* COMMENT Why Monads Matter

Suppose the output of the producer function $g$ is /T-times more elaborate/
than the input of the consumer function $f$, then a composition scheme
is devised for such functions:

#+BEGIN_EXAMPLE haskell
T (T C)  ‚üµT f‚üµ T B ‚üµg‚üµ A
‚Üì                  ‚ãÆ
Œº                  ‚ãÆ
‚Üì                  ‚ãÆ
T C      ‚üµ  f‚üµ  B

Desired:  T C ‚üµ f ‚óá g ‚üµ A
#+END_EXAMPLE

Given by $f ‚óá g = Œº ‚àò T f ‚àò g$, where $Œº : T ‚ÜêÃ£ T¬≤$ is a suitable polymorphic function.

Together with a unit function $Œ∑ : T ‚ÜêÃ£ Id$, datatype T forms a so-called /monad/ type.

The simplest of all monads is the /identity monad/ $T X = X$, which is such that
$Œº = id, Œ∑ = id, f ‚óá g = f ‚àò g$. So ---in a sense--- the /whole functional discipline/
studied thus far was already /monadic/, living inside the simplest of all monads: The identity.
Put in other words, such functional discipline can be framed into a wider discipline in which
an arbitrary monad is present.


Kleisli Composition is assocatiive with identity Œ∑ ---which coincide, for the identity monad,
to the usual composition and identity laws of functions---
and Œº = Id ‚óá Id and we have the fusion laws:
+ (f ‚óá g) ‚àò h = f ‚óá (g ‚àò h)     -- ‚óá-‚àò mutual associtivity
+  (f ‚àò g) ‚óá h = f ‚óá (T g ‚àò h)  -- ‚àò-‚óá fusion
+ T f ‚àò (h ‚óá k) = (T f ‚àò h) ‚óá k  -- T‚àò-‚óá mutual associtvity


If Œ∑ is the identity of ‚óá, then what happens when we compose with Id?
f ‚óá Id accepts a value of type $T B$ that is passed to $f : T C ‚Üê B$,
yielding an output of type $T\, C$. This construction is called /binding/:
$>>=f \;=\; f ‚óá Id$

Expressed pointwise we get $x >>= f \;=\; (Œº ‚àò T f) x$ which is exactly $f\, x$ for
the identity monad, so $>>=$ can be regarded as denoting /monadic function application/!

+ (f ‚óá g) a  =  do {b ‚Üê g a; f b}     =  g a >>= f
+ T f     x  =  do {a ‚Üê   x; Œ∑(f x)}  =  x   >>= Œ∑ ‚àò f

  That is: map f = unpack x, apply f, pack result using Œ∑.

+ x >>= f          =  do {a ‚Üê x; f x}
+ (x >>= g) >>= f  =  x >>= (f ‚óá g)

For enjoyable reading on monadic IO in Haskell see [18] chapter 18.

Adjunctions play a major role in [16]

Neato: Œº ‚àò Œ∑ = Id

From an adjunction L ‚ä£ R, a monad T = R ‚àò G arises defined by
Œ∑ = ‚åàId‚åâ and Œº = R‚åäId‚åã.

* COMMENT Old Category Theory Theorem List

** Pullbacks
 \heading{Pullbacks}

 \def\Pb{ \operatorname{\mathsf{Pb}} }

 A \emph{pullback} of $f,g$ is an object $\Pb \, f \, g$ with two morphisms $f \nearrow g$ and $g \nearrow f$,
 and an operation ``named'' $(g \nearrow f , f \nearrow g)\under(-,-)$ with the following properties

 \NTHM{}{Axiom, Pullback Definition}{ $(g \nearrow f) \fcmp f \eqs (f \nearrow g) \fcmp g$}

 \NTHM{}{Axiom, Pullback Typing}{
   $p \fcmp f \eqs q \fcmp f \impliesS (g \nearrow f , f \nearrow g)\under(p, q) : \Pb\,f\,g \to \src p$}

 \NTHM{}{Axiom, Pullback Char}{
   $(g \nearrow f , f \nearrow g) \fcmp (x, x) \eqs (p, q) \;\equivs\; x \eqs (g \nearrow f , f \nearrow g)\under(p, q) $}

 \NTHM{}{Pullback Self, projections}{ \\
   {\color{white}.\hfill}
   $
   (g \nearrow f) \fcmp \big((g \nearrow f , f \nearrow g)\under(p, q)\big) \eqs p
   \landS
   (f \nearrow g) \fcmp \big((g \nearrow f , f \nearrow g)\under(p, q)\big) \eqs q
   $
   }

 \NTHM{}{Pullback Identity}{$\Id_{\Pb\,f\,g} \eqs (g \nearrow f , f \nearrow g)\under (g \nearrow f , f \nearrow g)$}

 \NTHM{}{$\nearrow$-Uniqueness, ``Jointly Epic''}{ \\
   {\color{white}.\hfill}
   $
   (g \nearrow f , f \nearrow g) \fcmp (x, x)
   \eqs
   (g \nearrow f , f \nearrow g) \fcmp (y, y)
   \impliesS x \eqs y
   $}

 \NTHM{}{Pullback-Fusion, ``Composition into Numerator''}{ \\
     {\color{white}.\hfill}
   $
   \bigg((g \nearrow f , f \nearrow g)\under(p, q)\bigg) \fcmp x
   \eqs
   (g \nearrow f , f \nearrow g)\under\bigg( (p, q) \fcmp (x,x) \bigg)
   $
   }

 \def\eq{\approx}
 \def\Eq{\mathsf{Eq}}

** Equalisers
 \heading{Equalisers}

 Equalisers generalise the notion of ``solution set to an equation''
 or the domain of the common image of two morphisms.

 An \emph{equaliser} of $f,g$, with $\src f = \src g$, is an object $\Eq\, f\, g$, a morphism $[f \eq g] : \Eq\,f\, g \to \src\, f$, and a
 function $-\over[f \eq g]$ with the following properties

 \NTHM{}{Axiom, Definition}{ $[f \eq g] \fcmp f \eqs [f \eq g] \fcmp g$}

 \NTHM{}{Axiom, Typing}{
   $q \fcmp f \eqs q \fcmp g \impliesS q \over [f \eq g] : \src q \to \Eq\,f\,g$}

 \NTHM{}{Axiom, Characterisation}{
   $x \fcmp\, [f \eq g] \eqs q \equivS x \eqs q \over [f \eq g] $}

 \NTHM{}{Identity}{$\Id_{\Eq\,f\,g} \eqs [f \eq g] \over [f \eq g]$}

 \NTHM{}{PreFusion, ``PreComposition into Numerator''}{
   $x \fcmp ( q \over [f \eq g]) \eqs (x \fcmp q) \over [f \eq g]$}

 \NTHM{}{Self, Denominator Cancellation}{
   $ \big(q \over [f \eq g]\big) \fcmp [f \eq g] \eqs q
   \\
     \text{\hspace{18.4em}} \big(q \fcmp [f \eq g]\big) \over [f \eq g] \eqs q
   $
 }

 \NTHM{}{Epic}{
   $x \fcmp [f \sim g] \eqs y \fcmp [f \sim g] \impliesS x \eqs y$}

 \newpage

 \NTHM{}{ X }{ Y }

 \todo rewrite this section: Too much text. Introduce heuristics.
** Finality

 \heading{Finality}
 \def\final#1{ \mbox{!}_#1 }

 \NTHM{}{Axiom, final-Characterisation}{$f : B \to 1 \equivS f \eqs \final{B}$}

 \NTHM{}{final-Self}{$\final{1} : 1 \to 1$}

 \NTHM{}{final-Identity}{$\Id_1 \eqs \final{1}$}

 \NTHM{}{final-Uniqueness}{$f,g : B \to 1 \impliesS f \eqs g$}

 \NTHM{}{final-Fusion / Post-absorption}{$f : B \to C \impliesS f \fcmp \final{B} \eqs \final{C} $}

 \NTHM{}{initial-final Coincidence}{$\initial{1} \eqs \final{0}$}
** Pushouts
 \kern4ex
 \heading{Pushouts}

   Taking $D$ and $\mathcal{D}$ as suggested by
   $D\,\mathcal{D}:
     \spot\!\!\!\!_B\overset{f}{\text{\tiny$\longleftarrow$}} \!\!
     \spot\!\!\!\!_A\overset{g}{\text{\tiny$\longrightarrow$}}\!\!\spot\!\!\!\!_C
   $

 Working out the details and simplifying, we find that $\bigvee D$
 has objects morphism-pairs $p,q$ that post-equalise $f$ and $g$ in that $f \fcmp p \eqs g \fcmp q$, and morphisms
 $x : (p,q) \to (p',q') \equivS x : \tgt p \to \tgt p' \lands (p', q') \eqs (p,q) \fcmp x$.
 \iffalse details

 Since D is just the inclusion, we have that a cocone for the above diagram
 is a triple (p,q,r) to a single object and have sources (B,A,C) respectively
 such that r = f;p = g;q and so r is determined uniquely by p and q; whence it
 can be ignored.

 then a morphism between such pairs (p,q) and (p',q') is a morphism from the target
 of the former to the target of the latter such that the resulting triangles commute :-)

 Draw the diagrams!

 A \emph{pushout} of $f,g$ is an inital object in this category.

 Initiality means there exists an
 object $Po\, f\, g$ with two morphisms $f \searrow g$ and $g \searrow f$,
 and there exists a function $(f , g)\under(-,-)$ with the following properties

 \NTHM{}{Axiom, Pushout-Definition}{ $f \fcmp (f \searrow g) \eqs g \fcmp (g \searrow f)$}

 \NTHM{}{Axiom, Pushout-Typing}{
   $f \fcmp p \eqs g \fcmp q \impliesS (f , g) \under (p , q) : Po\,f\,g \to \tgt p$}

 \todo this looks wrong!\\
 \NTHM{}{Axiom, Pushout-Characterisation}{
   $(f , g) \fcmp (x , x) \eqs (p , q) \equivS x \eqs (f , g) \under (p , q) $}

 \NTHM{}{Pushout-Self, projections}{
   $f \fcmp (f , g) \under (p , q) \eqs p
   \landS
   g \fcmp (f , g) \under (p , q) \eqs q$
   }

 \NTHM{}{Pushout-Identity}{$\Id_{Po\,f\,g} \eqs (f , g) \under (f , g)$}

 \NTHM{}{$\under$-Uniqueness, ``Jointly Epic''}{
   $(f , g) \fcmp (x , x) \eqs (f , g) \fcmp (y , y) \impliesS x \eqs y$}

 \NTHM{}{Pushout-Fusion, ``Composition into Numerator''}{ \\
   $\big((f , g) \under (p , q)\big) \fcmp x \eqs (f , g) \under \big( (p , q) \fcmp (x,x)\big)$}
** Functions and Contracts

 What do we want functions for? If we ask this question to a physician or engineer
 the answer is very likely to be: one wants functions for modelling and reasoning
 about the behaviour of real things.

 So we get a naive purpose of functions: we want them to be applied to arguments
 in order to obtain results.

 A function /f : B ‚üµ A/ can be regarded as a kind of ‚Äúcontract‚Äù: /f/ commits
 itself to producing a /B/-value provided it is supplied with an /A/-value. How is such
 a value produced? In many situations one wishes to ignore it because one is just
 using function /f/. In others, however, one may want to inspect the internals of the
 ‚Äúblack box‚Äù in order to know the function‚Äôs computation rule.

 How free are we to fulfill the ‚Äúgive me an /A/ and I will give you a /B/ ‚Äù contract of
 declaration /f : B ‚üµ A/? In general, the choice of /f/ is not unique. Some /f/s will do as little
 as possible while others will laboriously compute non-trivial outputs. At one of
 the extremes, we find functions which ‚Äúdo nothing‚Äù for us, that is, the added-value
 of their output when compared to their input amounts to nothing:
 /f a = a/.
 In this case /B = A/, of course, and /f/ is said to be the identity function on /A/.

 Observe that ‚Äúnaturality laws‚Äù /f ¬∑ h = h ¬∑ f = f/ have a unique solution for /h/: ‚Äúthe‚Äù id-entity function.

** Sums
 Given two functions /f : C ‚üµ A/ and /g : C ‚üµ B/ with a common target, we can ‚Äúglue‚Äù them
 together to obtain a function ‚Äúeither /f/ or /g/‚Äù /[f , g] : C ‚üµ A + B/ to that same common target but whose
 source is the sum of the sources. This function behaves like /f/ when the input comes from the
 ‚Äú/A/-side‚Äù and behaves like /g/ when the input comes from the ‚Äú/B/-side‚Äù.

 The inputs can be ‚Äúinjected‚Äù into this new composite source via two new combinators:
 /inl : A + B ‚üµ A/ and /inr : A + B ‚üµ B/.

 # From this property it follows that the injections do not confuse inputs, i.e., are jointly-injective.
 Indeed the property above could be thought of as ensuring /no-junk and no-confusion/.
 - /no-junk/: Everything starting at a sum /h : C ‚üµ A + B/ is necessarily expressible as a case: /h = [ h . inl , h . inr].
 - /no-confusion/: Casing does not mix-up distinct inputs, /[f , g] = [h , k] ‚áí f = h ‚àß g = k/.

** Products

 When two morphisms do not compose but instead have a common source then we can /glue/
 them with the /pairing/ combinator /‚ü®-,-‚ü©/ by forming the product of their targets.
 When the morphisms are not necessarily related, we can still /glue/ them together via the /product/ combinator;
 namely if /f : A ‚üµ C/ and /g : B ‚üµ D/ then, /product of f and g/, /f √ó g : A √ó B ‚üµ C √ó D/.

 Both gluing combinators maintain the information of their individual arguments, in the same way
 (Cartesian) product /A √ó B/ keeps the information of /A/ and /B/.

 + Product is essentially symmetric
   - /swap := ‚ü® snd , fst ‚ü©/ is an involution witnessing /A √ó B ‚âÖ B √ó A/
   - In programming, where products are records, /swap/ can be re-interpreted as a guarantee that one
     does not lose (or gain) anything in swapping fields in struct or record datatypes.

 + Product is essentially associative
   - ‚Äúassociate to the right‚Äù, /assocr := ‚ü® fst . fst , snd √ó Id ‚ü© : A √ó (B √ó C) ‚üµ (A √ó B) √ó C/
   - This is an isomorphism with inverse /assocl := ‚ü® Id √ó fst , snd ‚àô snd ‚ü© : (A √ó B) √ó C ‚üµ A √ó (B √ó C)/.

** The Exchange Law

 /Datatype constructions, such as A + B and A √ó B, arise as devices for expressing
 the types of the results of gluing given morphisms./

 Two morphisms /A‚Ä≤ ‚üµ A/ and /B‚Ä≤ ‚üµ B/ can thus be combined by our combinators to
 obtain a morphism /A‚Ä≤ √ó B‚Ä≤ ‚üµ A + B/. Since such a morphism has source a sum, it
 can be obtained via the casing combinators; conversely, since it has target a product,
 it can be obtained via the pairing combinators. Naturally both forms coincide due to
 the /Exchange Law/ which expressed the equivalence of case-of-pairs and pair-of-cases:
 /[ ‚ü®f,g‚ü© , ‚ü®h,k‚ü© ]  =  ‚ü® [f,h] , [g,k] ‚ü©/.

 For example, applying this rule to the expression /‚ü® [ fst , fst ] , [ inl . snd , inr . snd] ‚ü©/
 yields the familiar /un-distribute-right/ operation /undistr = [ Id √ó inl , Id √ó inr ] : A √ó (B + C) ‚üµ (A √ó B) + (A √ó C)/.

** typechecking and gluing

  Formally, a ‚Äútype checking‚Äù discipline can be expressed in terms of compositional rules which
 check for functional expression wellformedness.

 I really like this approach you are promoting: Construing high-order combinators as
 variations on composition.

** LaTeX Matter To Utilise

%{{{ header

\documentclass[11pt]{article}

\usepackage[hmargin=10mm, vmargin=10mm, landscape]{geometry}
\usepackage{multicol}

\usepackage[svgnames]{xcolor}
%
% See Section-4 for colors by name at:
% ftp://ftp.mackichan.com/swandswp55/tcitex/doc/latex/contrib/xcolor/xcolor.pdf

\usepackage{amsmath,amssymb}

\usepackage{CalcStyleV9} % http://calccheck.mcmaster.ca/
\usepackage{calculation} % https://ctan.org/pkg/calculation
\parindent0pt\parskip0.6ex % Better for literate code.

\pagestyle{empty}

%{{{ main control macros

% bold item and place it in a box; intended to section-off related theorems
\def\heading#1{\fbox{\bf #1}}

% handy-dandy things to try in this domain we're learning.
\newcommand\heuristic[1][]{ {\color{red} \bf Heuristic \if#1\empty\else\ldq#1\rdq\fi:} }

% a notice ``to do'' sign for current construction sites
\def\todo{ {\color{DarkSlateBlue}\;\fbox{\sc \textbf{To Do ::}}\;} }

% 1 number or referencing item
% 2 name of theorem
% 3 theorem statement
\def\theorem#1#2#3{\parbox{3em}{#1} \ \textbf{#2:} \ \ {#3}}

%}}}
%{{{ logical operators with padding

% suffixes:
% 's' for a ``little'' bit    of space
% 'S' for a ``large''  amount of space

\def\equivS{\qquad \equiv \qquad}

\def\eqs{\quad = \quad}

\def\lands{\quad \land \quad}
\def\landS{\qquad \land \qquad}

%}}}
%{{{ category theory identifiers

% identity morphism
\def\Id{\mathsf{id}}

% source and target
\def\src{\mathsf{src}\,}
\def\tgt{\mathsf{tgt}\,}

% converse morphism notation
\def\from{\leftarrow}

% natural transformation
\def\natTo{\mathrel{\ooalign{\,$\longrightarrow$\cr\quad.}}}
%}}}

\theorem{}{Principle of Duality}{
  A statement $S$ is true about $\mathcal{C}$
  iff it's dual $S[\fcmp \,:=\, \circ]$ is true about $\mathcal{C}^{op}$. }

\theorem{}{{\color{gray} Cancellation / } Projection Definitions}{ $\fst \cdot \< f , g \> = f \landS \snd \cdot \< f , g \> = g$ }

\theorem{}{{\color{gray}Fusion / } Pointwise Definition of Pairing}{ $\<f , g \> \cdot h \eqs \<f \cdot h , g \cdot h\>$ }

\theorem{}{Axiom, Product bi-map definition}{ $f \x g \,:=\, \< f \cdot \fst , g \cdot \snd \>$ }

\theorem{}{{\color{gray} Induced} Pointwise Definition of Product bi-map }
        { \hspace{-1em} $(f \x g) \cdot \<i , j \> \eqs \<f \cdot i , g \cdot j\>$ }

\theorem{}{{\color{gray}Absorption /} Induced Definition of Casing}
        { $\[ f , g \] \cdot (i \+ j) = \[ f \cdot i , g \cdot j \]$ }
** COMMENT Coequaliser

 # $Dùíü = \left( \overset{A}{‚Ä¢} \overset{\overset{f}{\rightrightarrows}}{g} \overset{B}{‚Ä¢} \right)$.
 #
 Take $D$ and $ùíü$ as suggested by $Dùíü = \left( \overset{A}{‚Ä¢} \rightrightarrows^f_g \overset{B}{‚Ä¢} \right)$;
 where $f,g : A ‚Üí B$ are given.
 Then a cocone Œ¥ for $D$ is a two-member family $Œ¥ = (q', q)$
 with $q' : A ‚Üí C, q : B ‚Üí C, C = \tgt\,\delta$ and $Œ¥_A ‚àò \const{C} h = D h ‚àò Œ¥_B$; in-particular
 $q' = f ‚àò q = g ‚àò q$ whence $q'$ is fully-determined by $q$ alone.

 Let $Œ≥ = (p', p) : Obj(‚ãÅD)$ be a colimit for $D$ and write $-p‚ï±$ in-place of $-‚ï±Œ≥$, then the ‚ï±-laws
 yield: /$p$ is a coequaliser of $(f,g)$/ if there is a mapping $-‚ï±p$ such that /CoEq-Type/ and
 /CoEq-Char/ hold.

 #+BEGIN_EXPORT latex
 \begineqns

 \eqn{CoEq-Type}{ f ‚àò q =  g ‚àò q \impliesS q‚ï±p : \tgt\, p ‚Üí \tgt\,q}

 \vspace{2ex}
 Well-formedness convention: In each law the variables are quantified
 in such a way that the premise of \ref{CoEq-Type} is met.
 The notation $q‚ï±‚ãØ$ is only senseful if $f ‚àò q = g ‚àò q$,
 like in arithmetic where the notation $m \div n$ is only sensful if $n$ differs from 0.

 \eqn{CoEq-Char}{ x ‚àò p = q \equivS x = q ‚ï± p }

 \eqn{CoEq-Self}{ q‚ï±p ‚àò p = q}

 \eqn{CoEq-Id}{p‚ï±p = \Id}

 \eqn{CoEq-Fusion}{x ‚àò q‚ï±p = (x ‚àò q)‚ï±p}

 \eqn{CoEq-Unique}{x ‚àò p = y ‚àò p \impliesS x = y}

 \eqn{CoEq-Compose}{r‚ï±q ‚àò q‚ï±p = r‚ï±p}
 %%
 %% \eqn{?‚ï≤-Functor-Dist}{F(Œ¥‚ï±Œ≥) = FŒ¥ ‚ï± FŒ≥}
 %%
 %% \eqn{?‚ï≤-Pre-Functor-Elim}{Œ¥F‚ï±Œ≥F = Œ¥‚ï±Œ≥}
 %%
 \endeqns
 #+END_EXPORT

 # CoEqualisers generalise the notion of induced equivalence relation.

 \vfill

 \iffalse

   Taking $D$ and $\mathcal{D}$ as suggested by
   $D\,\mathcal{D}:$
   $ \raisebox{6pt}{$\spot$}
   \overset{ \overset{f}{\text{\tiny$\longrightarrow$}}
     }{ \overset{\longrightarrow}{\text{\tiny$g$}}  }
   \raisebox{6pt}{$\spot$}
   $

 Now call the category $\bigvee D$ by the name $\bigvee(f \,|\!|\, g)$:
 it has objects morphisms that post-equalise $f$ and $g$, and morphisms
 $x : p \to q \equivS x : \tgt p \to \tgt q \lands p \fcmp x \eqs q$

 A \emph{coequaliser} of $f,g$ is an initial object in
 $\bigvee(f \,|\!|\, g)$.

 \fi

 # coEqualiser-Fusion, ``Composition into Numerator''
** COMMENT Naturality
 0. The arrow category $ùíû^‚Üí$ has objects being ùíû-arrows, and arrows $f ‚Üí g$ are
    pairs $(h, k)$ of ùíû-morphisms that yield commuting squares: $k ‚àò f = g ‚àò h$.
    Composition is the pasting of commuting diagrams; i.e., component-wise.

    - This gives rise to two functors $ùíÆùìáùí∏, ùíØ‚Ñäùìâ : ùíû^‚Üí ‚Üí ùíû$ that project that
      morphisms from the pairs.

    - Observe that ùíû-commuting cubes can be construed as objects of $(ùíû^‚Üí)^‚Üí$.

 + A natural transformation Œ∑ : F ‚Üí G : ùíû ‚Üí ùíü is precisely
   a functor $Œ∑ : ùíû ‚Üí ùíü^‚Üí$ where $ùíÆùìáùí∏ ‚àò Œ∑ = F \lands ùíØ‚Ñäùìâ ‚àò Œ∑ = G$.

   - That Œ∑ is a functor to the arrow category of ùíü means that
     for each object A of ùíû, there is a ùíü-arrow Œ∑_A;
     and for each morphism f : A ‚Üí B, there is a ùíü-commuting square
     $(h, k) : Œ∑_A ‚Üí Œ∑_B$; i.e., $k ‚àò Œ∑_A = Œ∑_B ‚àò h$.

  - By the constraints on Œ∑, we know $F f = (ùíÆùìáùí∏ ‚àò Œ∑) f = h$
    and $G f = (ùíØ‚Ñäùìâ ‚àò Œ∑) f = k$.

    Thus, we have $G f ‚àò Œ∑_A = Œ∑_B ‚àò F f$.

 + A natural transformation is invertible precisely when its components are all invertible; i.e., (Œ∑Àò)‚Çê = (Œ∑‚Çê)Àò.

* COMMENT Maybe move to README
** Gluing functions which do not compose -- products         :move_to_readme:

 Composition is the basis for gluing morphisms together to build more complex morphisms.
 However, not every two morphisms can be glued together by composition.

 # $f : A ‚Üê C$ and $g : B ‚Üê C$
 For instance, functions $A \overset{f}{\longleftarrow} C \overset{g}{\longrightarrow} B$
 do not compose with each other since the source of one is not the target of the other.

 \room

 Since $f$ and $g$ share the same source, their outputs can be paired: $c ‚Ü¶ (f\, c, g\, c)$.
 We may think of the operation which pairs the outputs of $f$ and $g$ as a new function
 combinator: $‚ü®f, g‚ü© = c ‚Ü¶ (f\, c, g\, c)$ ---read ‚Äú$f$ /split/ $g$‚Äù.

 \room

 $‚ü®f, g‚ü©\, c = ‚ü®f\, c, g\, c‚ü©$ duplicates $c$ so that $f$ and $g$ can be executed in ‚Äúparallel‚Äù on it.

 \room

 Function $‚ü®f,g‚ü©$ keeps the information of both $f$ and $g$ in the same way
 Cartesian product $A √ó B$ keeps the information of $A$ and $B$.
 So, in the same way that $A$ data or $B$ data can be retrieved from $A √ó B$ data
 via the projections $A \overset{\fst}{\longleftarrow} A √ó B \overset{\snd}{\longrightarrow} B$,
 $f$ and $g$ can be retrieved via the same projections:
 \eqn{Cancellation}{\fst ‚àò ‚ü®f, g‚ü© = f \lands \snd ‚àò ‚ü®f, g‚ü© = g}

 \room

 A /split/ arises wherever two functions do not compose but share the same source.

 \room

 How do we glue functions that fail such a requisite, say $f : A ‚Üê C$ and $g : B ‚Üê D$?
 We regard their sources as projections of a product:
 $A \overset{f ‚àò \fst}{\longleftarrow} C √ó D \overset{g ‚àò \snd}{\longrightarrow} B$.
 Now they have the same source and so the split combinator can be used:
 $f √ó g = (c, d) ‚Ü¶ (f\, c, g\, d)$.
 #
 This corresponds to the ‚Äúparallel‚Äù application of $f$ and $g$, each with its /own/ input.

 \room

 What is the /interplay/ among the functional combinators: Composition, split, product?
 The first two relate to each other via the fusion law
 \eqn{Fusion}{‚ü®f, g‚ü© ‚àò c = ‚ü®f ‚àò c, g ‚àò c‚ü©}
 Notice how it looks like the /definition/ of the split operator but all applications have
 been lifted to compositions! Woah!
   + Moreover, the absorption property is just the lifting of the pointwise definition! Woah!

 \room

 All three combinators interact via the √ó-absorption property.

 # \room
 #
 # The following is self-inverse,
 # \eqn{swap-Def}{swap = ‚ü®\snd, \fst‚ü© : A √ó B ‚âÖ B √ó A}

** Gluing functions which do not compose -- coproducts       :move_to_readme:

 In the scenario $A \overset{f}{\rightlongarrow} C \overset{g}{\leftlongarrow} B$,
 it is clear that the kind of glue we need should make it possible to apply $f$
 if the input is from the ‚Äú$A$ side‚Äù or apply $g$ if it is from the ‚Äú$B$ side‚Äù.

 \room

 We denote this new combinator ‚Äúeither $f$ or $g$‚Äù, $[f, g] : A + B ‚Üí C$, where the values of $A + B$
 can be thought of as ‚Äúcopies‚Äù of $A$ or $B$ values which are ‚Äústamped‚Äù with different
 tags in order to guarantee that values which are simultaneously in $A$ and $B$ do not
 get mixed up.

 \room

 Duality is of great /conceptual economy/ since everything that can be said of concept /X/
 can be rephrased for /co-X/. *That $\composition$-listing provides eloquent evidence of duality.*

 \room

 Notice that the fusion law,
 \eqn{Fusion}{ f ‚àò [g, h] = [f ‚àò g, f ‚àò h]}
 Is essentially the definition: If we're in the left `g` then the result is `f` applied to it;
 otherwise if we're in the right `h` then the result is `f` applied to it! Woah: From pointwise to pointfree.
** COMMENT An Introduction to Pointfree Programming

 # Functional programming literally means ‚Äúprogramming with functions‚Äù.
 The main emphasis is on /compositionality/, one of the main advantages
 of ‚Äúthinking functionally‚Äù, explaining how to construct new functions
 out of other functions using a minimal set of predefined functional
 combinators. This leads to a style which is /pointfree/ in the sense that
 function descriptions dispense with variables --also known as /points/.

 \room

 Why do people look for compact notations?
 A compact notation leads to shorter documents, less lines of code
 in programming, in which patterns are easier to identify and reason
 about. Properties can be stated in clear-cut, one-line long equations
 which are easy to memorise.
 #
 # Backus' FP and Iverson's APL are examples of pointfree programming
 # languages; look them up ;-)

 \room

 The notation ‚Äú$f : A ‚Üí B$‚Äù focuses on what is relevant about $f$
 and can it be regard as a kind of contract:
 #+BEGIN_QUOTE
 $f$ /commits itself/ to producing a /B/-value provided it is supplied
 with an /A/-value.
 #+END_QUOTE

 \room

 Types provide the ‚Äúglue‚Äù, or interface, for putting functions
 together to obtain more complex functions.

 \room

 What do we want functions for?
 One wants functions for modelling and reasoning about the
 behaviour of real things.

 \room

 In order to switch between the pointwise and pointfree settings
 we need two ‚Äúbridges‚Äù: One lifting equality to the function level
 and the other lifting function application.

 \room

 Two functions $f, g : A ‚Üí B$ are the same function iff they agree
 at the pointwise level:
 \eqn{Extensionality}{ f = g \equivS \left(‚àÄ a : A ‚Ä¢ f\, a = g\, a \right)}

** COMMENT Gluing functions which do not compose --exponentials

 Functional application is the bridge between the pointfree and pointwise worlds.

 Suppose we are given the task to combine two functions, one binary
 $B \overset{f}{\leftlongarrow}{C √ó A}$ and the other unary $D \overset{g}{\leftlongarrow} A$.
 Clearly none of the combinations $f ‚àò g, ‚ü®f, g‚ü©$, or $[f, g]$ is well-typed. Hence $f$ and $g$
 cannot be put together and require some extra interfacing.

 \room

 Note that $‚ü®f, g‚ü©$ would be well-defined in case the $C$ components of $f$'s source
 could be somehow ‚Äúignored‚Äù. Suppose, in fact, that in some particular context
 the first argument of $f$ happens to be ‚Äúirrelevant‚Äù, or to be frozen to some $c : C$.
 It is easy to derive a new function $f_c : A ‚Üí B : a ‚Ü¶ f(c, a)$ from $f$, combines
 nicely with $g$ via the split combinator: $‚ü®f_c , g‚ü©$ is well-typed and bears the type
 $B √ó D ‚Üê A$. ---MA: The typing looks erroneous.

 \room

 Since $f_c$ denotes a function of type $B ‚Üê A$, we will say $f_c : B^A$, where the exponential
 is an alternate notation for the arrow --the reason to adopt it is that it is functorial, as will be shown.

 We want functions so as to apply them, so it's natural to introduce the /apply/ operator which applies
 a function to an argument:
 \[ ap : B ‚Üê B^A √ó A \]
 \[ ap(f, a) = f \ a \]

 #+LaTeX: \def\transpose#1{ \overline{#1} }

 #+BEGIN_EXPORT latex
 The above ‚Äútranspose‚Äù operation $f ‚Ü¶ f_c$ is of type $B^A ‚Üê C$.
 It expresses $f$ as a kind of /C/-indexed family of functions $B ‚Üê A$.
 It will be denoted by $\transpose{f}$ with the definition $(\transpose{f}\, c)\, a = f(c, a)$.

 Observe that $\transpose{f}$ is more tolerant than $f$: The latter is a binary operator and so
 requires /both/ arguments $(c,a)$ to become available before application, whereas the former is happy
 to be produced with $c$ first  and with $a$ later on.

 \eqn{exponential-Char}{ k = \transpose{f} \equivS f = ap ‚àò (k √ó \Id) }

 Pointwise, $(ap ‚àò (\transpose{f} √ó \Id))\, (c, a) = ap \, (\transpose{f}\, c, a) = \transpose{f} \, c\, a$
 which should be equal to $f(c,a)$ and indeed it is --in pointfree form:

 \eqn{exponential-Cancellation}{ f = ap ‚àò (\transpose{f} √ó \Id) }

 \eqn{exponential-Id}{ \transpose{ap} = \Id_{B^A} }

 \eqn{exponential-Fusion}{ \transpose{g ‚àò (f √ó \Id)} \eqS \transpose{g} ‚àò f }

 We can thus introduce a new functional combinator, which arises as the transpose
 of $f ‚àò ap$:

 \eqn{exponential-Functor-Type}{ f^A : C^A ‚Üê B^A \providedS f : C ‚Üê B}

 $B^A$ can be thought of as a /syntactical/ representation of the /semantical/ $A ‚Üí B$
 --they are the `same', but the way we treat them and think of them is different.
 [ This differs from $(-‚Üí-)$ when discussing adjunctions earlier, since that was
   the `external hom-/set/'; this is the /internal/ hom! ]

 \eqn{exponential-Functor-Defn}{ f^A = \transpose{f ‚àò ap} }
 #+END_EXPORT

 Pointwise: $f^A\, g = f ‚àò g$ --so $f^A$ is the ‚Äúcompose with $f$‚Äù functional combinator.
 # Indeed:
 #
 #     f·µÉ = T(f . ap)
 # ‚â°   f . ap = ap ‚àò (f·µÉ √ó Id)                 exp-Char
 # ‚â°   f . ap (g, a) = ap ‚àò (f·µÉ √ó Id) (g, a)   extensionality
 # ‚â°   f (g a)       = ap ‚àò (f·µÉ g, a)          √ó-simpl
 # ‚â°   f (g a)       = f·µÉ g a                  ap-simpl
 # ‚â°   f ‚àò g         = f·µÉ g                    extensionality

 \eqn{exponential-Functorial}{ (g ‚àò h)^A \eqs g^A ‚àò h^A \landS \Id^A = \Id }

 *Interestingly:*

 #+BEGIN_EXPORT latex
 \eqn{Oh‚ÇÄ}{ \transpose{\snd} \eqs \const{\Id} }

 \eqn{Oh‚ÇÅ}{ \transpose{f}\, a \eqs f ‚àò ‚ü® \constant{a} , \Id ‚ü© }

 \eqn{Oh‚ÇÇ}{ \const{g} \eqs \transpose{g ‚àò \snd} }

 Also $\transpose{\snd}$ is a constant function:
 \eqn{Oh‚ÇÉ}{ \transpose{\snd} ‚àò f \eqs \transpose{\snd} }
 #+END_EXPORT


+ Absorption: g·¥¨ ‚àò \transpose{h} = \transpose{g ‚àò h}

   Whence Closed definition: \transpose{g} = g·¥¨ ‚àò \transpose{Id}.

+ Naturality: h ‚àò \transpose{Id} = \transpose{Id} ‚àò (h·¥¨ √ó Id‚Çê)

* COMMENT Maybe move to a different project
  F-Algebras: ‚ÄúRecursion in the Pointfree Style‚Äù
** COMMENT ¬ß3 Recursion in the Pointfree Style

 This section provides a naive introduction to algorithm analysis and synthesis
 by showing how a quite elementary class of algorithms --equivalent to for-loops
 in C or any imperative language-- arise from elementary properties of the underlying
 maths domain.

 The /for-loop/ combinator is defined by
 \[ for \; f \; e \; 0 = e \]
 \[ for \; f \; e \; (n+1) = f (for \; f \; e \; n) \]

 Which can be implemented, in C:
 #+BEGIN_EXAMPLE
T total = e;
for(int j=0; j<n; j++)
   total = f(total);
 #+END_EXAMPLE

 This is the catamorphism for ‚Ñï!

 #+BEGIN_EXPORT latex
 \eqn{in-‚Ñï}{ in = [ \const{0}, succ] : 1 + ‚Ñï ‚âÖ ‚Ñï }

 The above witness: Every natural number is either 0 or the successor of another natural number.
 --That is, such $in$'s characterise inductive types!--

 \eqn{for-loop-universal}{ f = for \; g \; e \equivS f ‚àò in = [ \const{k}, g] ‚àò (\Id + f)] \eqs ‚¶á [\const{k}, g] ‚¶à}

 \eqn{for-loop-Id}{ for\; succ\; 0 \eqs \Id}

 \eqn{for-loop-fusion}{ h ‚àò for\; g\; k \eqs for\; j \; (h\, k) \providedS h ‚àò g = j ‚àò h}
 % Proof: Universal property along with fact (a+) ‚àò Id = (a+).
 #+END_EXPORT

 *Heuristic* Implement a given function $f$ as a for-loop by using for-loop-Id then for-loop-fusion
 and solving for unknown $j$ along the way; e.g.,

 #+begin_calculation latex
   f
 \step{ Identities and for-loop-Id }
   f ‚àò for\; succ\; 0
 \step{ For-loop-fusion, calculute for unknown $j$ in $f ‚àò succ = j ‚àò f$ }
   for \; j \; (f\; 0)
 #+end_calculation

 Really the $j$ is what $f$ does at the inductive step
 --we cover the base step by computing $f\; 0$ directly.

 For example, in this way we obtain $(a+) = for\; succ\; a$.

 Other fun stuff:
 #+BEGIN_EXPORT latex
 \eqn{simple-optimisation}{ for\; \const{k} \; k \eqs for\; \Id \; k}
 #+END_EXPORT

** COMMENT ¬ß3.12 F-catamorphisms

 For a polynomial functor $F$ a particular iso /F/-algebra always exists, which
 is denoted by $in : ŒºF ‚Üê F (ŒºF)$ and has special properties. First, its carrier
 is the smallest among the carriers of other iso /F/-algebras, and this is why it
 is denoted by $ŒºF$ ---$Œº$ for ‚Äúminimal‚Äù.

 #+BEGIN_EXPORT latex
 \eqn{cata-Char}{k = ‚¶áŒ±‚¶à \equivS k ‚àò in = Œ± ‚àò F k }

 \eqn{cata-Id}{ ‚¶áin‚¶à = \Id_{ŒºF} }


 \eqn{cata-cancellation}{‚¶áŒ±‚¶à ‚àò in = Œ± ‚àò F ‚¶áŒ±‚¶à}

 That is, since in is an iso, ‚ÄúDecompose input, via out, then recurse, then apply Œ±‚Äù:

 \eqn{cata-cancellation}{‚¶áŒ±‚¶à = Œ± ‚àò F ‚¶áŒ±‚¶à ‚àò out}

 \eqn{cata-Fusion}{ f ‚àò ‚¶áŒ±‚¶à = ‚¶áŒ≤‚¶à \providedS f ‚àò Œ± = Œ≤ ‚àò F f}
 #+END_EXPORT

 *Go back and re-read ¬ß3.13* Then do exercises 3.11, 3.16, 3.17.

** COMMENT ¬ß3.13 Introducing Inductive Datatypes

 A comment on the particular choice of terminology: ~in~ suggests that we are
 going inside, or constructing values of the datatype; whereas ~out~ suggests
 that we are going out, or destructing, analysing, values of the datatype.

 A nifty duality.

** COMMENT ¬ß3.16 The mutual-recursion law

 Suppose we are executing two (possibly mutually recursive) functions $f$ and $g$ in parallel, which may be catamorphisms
 and so somewhat costly. Could we turn these into a single function call to a catamorphism?

 Solving for $h, k$ in $‚ü®f, g‚ü© = ‚¶á‚ü®h, k‚ü©‚¶à$ yields ‚ÄúFokkinga's Law‚Äù, aka

 #+BEGIN_EXPORT latex
 \eqn{Mutual-Recursion-Law}{ ‚ü®f, g‚ü© = ‚¶á‚ü®h, k‚ü©‚¶à \equivS f ‚àò in = h ‚àò F ‚ü®f, g‚ü© \landS g ‚àò in = k ‚àò F‚ü®f, g‚ü©}
 #+END_EXPORT

 This law is useful in combining two mutually recursive functions into a single catamorphism
 --with added efficiency by possibly using the exchange law.

 *Heuristic*
 We can apply this law to a single function by looking at an ‚Äúinefficient‚Äù subpart and
 extracting that into its own function, then trying to apply the law, with possibly more extractions.

  - Isn't the computing-cubes-in-linear-time problem solved this way?

 For example, there is much re-calculation in the definition of fib:
 \[ fib \; 0 = 1 \]
 \[ fib \; 1 = 1 \]
 \[ fib \; (n+2) = fib \; (n+1) + fib\; n \]
 Can we improve its performance?
 The clue is to regard the two instances of $fib$ in the recursive branch as mutually recursive
 over the natural numbers. The clue is /suggested/ not only by $fib$ having two base cases
 --so, perhaps it hides two functions-- but also by the lookahead $n + 2$ in the recursive clause.
 Introducing $f$ by the /specification/ $f\; n = fib(n + 1)$ then using that to obtain a recursive definition,
 possibly depending on $fib$, allows us to use the mutual recursive law to obtain a linear function
 from which $fib$ is obtained via a simple projection --say $\snd$.

 The mutual recursive law generalises to more than two mutually recursive functions, in this case three:
 #+BEGIN_EXPORT latex
 \eqn{Mutual-Recursion-Law}{ ‚ü®f‚ÇÄ, ‚ü®f‚ÇÅ, f‚ÇÇ‚ü©‚ü© = ‚¶á‚ü®h‚ÇÄ, ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©‚ü©‚¶à \equivS ‚àÄi:0..2 ‚Ä¢ f·µ¢ ‚àò in = h·µ¢ ‚àò F‚ü®f‚ÇÄ, ‚ü®f‚ÇÅ, f‚ÇÇ‚ü©‚ü© }
 #+END_EXPORT

 Now go do exercises 3.23, 3.26, 3.28 ;-)

 An immediate consequence of Mutual-Recursion-Law is
 #+BEGIN_EXPORT latex
 \eqn{Banana-Split-Law}{ ‚ü®‚¶ái‚¶à, ‚¶áj‚¶à‚ü© = ‚¶á(i √ó j) ‚àò ‚ü®F \fst, F \snd‚ü© ‚¶à }

 This law provides us with a very useful tool for ‚Äúparallel loop‚Äù fusion.
 #+END_EXPORT

** COMMENT ¬ß2.14 Guards and McCarthy's conditional

 Define
 \eqn{?-Defn}{(p?)\, a = \mathsc{If}\, p\, a \,\mathsc{Then}\, \inl\, a \,\mathsc{Else}\, \inr\, a \mathsc{Fi}}

 We call $p? : A ‚Üí A + A$ the /guard/ associated to predicated /p : A ‚Üí ùîπ/.
 The guard is more informative than /p/ alone: It provides information about the outcome of testing /p/
 on some input /a/, encoded in terms of the sum injections, $\inl$ for /true/ and $\inr$ for /false/,
 without losing the input /a/ itself.

 #+BEGIN_EXPORT latex
 \begineqns
 \eqn{McCarthy-Conditional-Defn}{ p ‚Üí g,h \quad=\quad [g, h] ‚àò p?}

 Hence to reason about conditionals one may seek help in the algebra of sums.

 \eqn{conditional-Fusion‚ÇÅ}{ f ‚àò (p ‚Üí g, h) \quad=\quad p ‚Üí f ‚àò h, f ‚àò h}

 \eqn{conditional-Fusion‚ÇÇ}{ (p ‚Üí g, h) ‚àò k \quad=\quad p ‚àò k ‚Üí g ‚àò k, h ‚àò k}

 \eqn{conditional-product-Fusion}{ k ‚àò ‚ü® (p ‚Üí f,h) , (p ‚Üí g, i) ‚ü©  \eqs p ‚Üí k ‚àò ‚ü®f, g‚ü© , k ‚àò ‚ü®h, i‚ü© }

 %
 %   k ‚àò ‚ü® (p ‚Üí f,h) , (p ‚Üí g, i) ‚ü©
 % = k ‚àò ‚ü® [f,h] ‚àò p? , [g, i] ‚àò p? ‚ü©
 % = k ‚àò ‚ü® [f,h] , [g, i] ‚ü© ‚àò p?
 % = k ‚àò [ ‚ü®f, g‚ü© , ‚ü®h, i‚ü© ] ‚àò p?
 % = [ k ‚àò ‚ü®f, g‚ü© , k ‚àò ‚ü®h, i‚ü© ] ‚àò p?
 % = p ‚Üí k ‚àò ‚ü®f, g‚ü© , k ‚àò ‚ü®h, i‚ü©

 \eqn{conditional-Abides-Distributivity}{ ‚ü® (p ‚Üí f,h) , (p ‚Üí g, i) ‚ü©  \eqs p ‚Üí ‚ü®f, g‚ü© , ‚ü®h, i‚ü© }

 \eqn{conditional-Idempotency}{p ‚Üí f,f \eqs f}

 \eqn{conditional-‚ü®‚ü©-Distributivity}{ ‚ü® f, (p ‚Üí g, h)‚ü© \quad=\quad p ‚Üí ‚ü®f, g‚ü©, ‚ü®f, h‚ü© }

 \eqn{conditional-√ó-Distributivity}{ (p ‚Üí g, h) √ó f \quad=\quad p ‚àò \fst ‚Üí g √ó f, h √ó f}

 \endeqns
 #+END_EXPORT

 \room

 *As well as their duals!*

** COMMENT Wow --another example-- involving conditionals
  Just as in the case of proving /tails/ is a natural transformation *without* using
  any implementing definitions, here's a similar example.

  \room

  Here's an illustration of how /smart/ pointfree algebra can be in reasoning about
  functions that /one does not actually defined explicitly/.

  It also shows how relevant the /natural properties/ are.

  The issue is that our definition of a guard, \ref{?-Defn}, is pointwise and most
  likely unsuitable to prove facts such as, for instance,
  \[ p? ‚àò f = (f + f) ‚àò (p ‚àò f)? \]
  Thinking better, instead of `inventing' \ref{?-Defn}, we might --and perhaps should!--
  have defined
  \eqn{two-Defn}{2  \;‚âÖ\; 1 + 1}
  \eqn{double-Defn}{2 √ó A \;‚âÖ\; A + A}
  \eqn{?-Defn-Pointfree}{ p? = double ‚àò ‚ü®p, \Id‚ü© }

  which actually express rather closely our strategy of switching from products
  to coproducts in the definition of $(p?)$.

  In particular, *we do not need to define /double/ explicitly*.
  From its type we immediately infer its natural, or free, property:
  \[ double ‚àò (\Id √ó f) \eqs (f + f) ‚àò double \]

  It turns out that this is the /knowledge/ we need about $double$
  in order to prove the above mentioned property.

  \room

  The less one has to write to solve a problem, the better.
  One saves time and one's brain, adding to productivity.
  This is often called /elegance/ when applying a scientific method.
** Importance of Compositional Combinators                           :ignore:

 # Paraphrasing Oliveira, ¬ß2.13
 \vspace{3ex}
 The compositional combinators put forward here are equipped with a concise /set of properties/
 which enable programmers to transform programs, reason about them, and perform useful calculations.
 This raises a /programming methodology/ which is scientific and stable.

** Compact Notation

 Why do people look for compact notations? A compact notation leads to
 shorter documents (less lines of code in programming) in which patterns are easier
 to identify and to reason about. Properties can be stated in clear-cut, one-line long
 equations which are easy to memorize. And diagrams such as (2.4) can be easily
 drawn which enable us to visualize maths in a graphical format.

* COMMENT ToDo's
Include:
+ Page 23: Associativity of ~C~ product structs.
+ Page 25: Realisation of sums in ~C~.
+ Pages 31-32: Datatypes, void, unit, bool, maybe.
+ Page 51: Table 2.1 Abstract notation versus programming language data-structures.

+ Go do all the exercises --we have a handy cheat-sheet to help! Let the exercises reinforce the learning!
  - Some of the insightful, or fun ones, maybe include here ;-)
  - ¬ß2.19 is all exercises!

+ Also, notice that we have natural transformations
   $\initial{-} : \K 0 \natTo \mathsf{Id}$
   and $\final{-} : \mathsf{Id} \natTo \K 1$

   Claim?

   the cat has a final element iff identity endofunctor has a colimit.
   ie the final element is the union of all elements and so is the
   top or maximal element ;)

   $1 \cong CoLim \, \mathsf{Id}$
   where $\final{-} = \gamma$ is the witnessing family?

+ Provide a /calculational/ proof of: if a category J has a terminal object 1,
   then the colimit of any functor F:J‚ÜíC is just F(1), with the cocone defined by the maps F(œÑj):F(j)‚ÜíF(1).

   Hint: https://math.stackexchange.com/questions/1210440/given-a-mathcalc-rightarrow-mathcale-when-does-operatornamecolim
** COMMENT TODO Generalise Exchange Law to arbitrary colimits and limits xD

* COMMENT Duality: Sums & Products :uniform_notation:artefact:

#  \NTHM{}{Principle of Duality}{
#    A statement $S$ is true about $\mathcal{C}$
#    iff it's dual $S[\fcmp \,:=\, \circ]$ is true about $\mathcal{C}^{op}$. }
#
#+BEGIN_EXPORT latex
\def\fst{\mathsf{fst}}
\def\snd{\mathsf{snd}}
#+END_EXPORT

#+LaTeX_HEADER: \usepackage{stackengine}
#
# \topinset{*}{O}{1pt}{}
#
#+LaTeX: \def\composition{ \topinset{Ôπî}{‚àò}{0.4pt}{} }

In category theory there are two popular notations for composition,
$f Ôπî g = g ‚àò f$, and there are two arrow notations $A ‚Üí B \;=\; B \leftarrow A$,
known as the ‚Äúforwards‚Äù and ‚Äúbackwards‚Äù notations.

\room

Some people prefer one notation and stick with it; however having both in-hand
allows us to say: The /dual/ of a categorical statement formed with
$Ôπî,‚Üí$ is obtained by syntactically replacing these two with $‚àò, \leftarrow$ respectively
while leaving variables and $\Id$'s alone.

\room

#+LaTeX: \def\dual{\mathsf{dual}}
#
#
For example, applying this process to sums yields /products/:
\vspace{-0.5em}
#+begin_calculation latex
   h = ‚ü®f, g‚ü©
\step{  We define products as dual to sums }
   h = \dual [f, g]
\step{  dual operation definition }
  \dual\left( h = [f,g] \right)
\step{  []-Char and Leibniz }
  \dual\left( \inl Ôπî h = f  \lands  \inr Ôπî h = g\right)
\step{  dual operation definition }
  \dual\left(\inl Ôπî h\right) = f  \lands  \dual\left(\inr Ôπî h\right) = g)
\step{  dual operation definition }
  \dual \text{ } \inl ‚àò h = f  \lands  \dual \text{ }  \inr ‚àò h = g
\step{  Define: $\fst = \dual\, \inl$, $\snd = \dual\, \inr$ }
  \fst ‚àò h = f  \lands  \snd ‚àò h = g
\step{  Switch back to Ôπî-notation }
   h Ôπî \fst = f  \lands  h Ôπî \snd = g
#+end_calculation

# Dualising the other sum artefacts yields:
/$(\fst, \snd, A √ó B)$ form a product of A and B/ if there is an operation
$‚ü®-,-‚ü©$ satisfying the Char and Type laws below; from which we obtain a host of corollaries.

#+BEGIN_EXPORT latex
\begineqns

\eqn{$\langle\rangle$-Type}{f : C ‚Üí A \lands g : C ‚Üí B \impliesS ‚ü®f, g‚ü© : C ‚Üí A √ó B}

\eqn{$\langle\rangle$-Char}{ x Ôπî \fst = f \lands x Ôπî \snd = g \equivS x = ‚ü®f, g‚ü© }

\eqn{$\langle\rangle$-Cancellation; $\langle\rangle$-Self}{ ‚ü®f, g‚ü© Ôπî \fst = f \landS ‚ü®f, g‚ü© Ôπî \snd = g}

\eqn{$\langle\rangle$-Id}{ ‚ü®\fst, \snd‚ü© = \Id}

\eqn{$\langle\rangle$-Unique}{ x Ôπî \fst = y Ôπî\fst  \lands x; \snd = y Ôπî \snd \impliesS x = y}

\eqn{$\langle\rangle$-Fusion}{ x Ôπî ‚ü®f , g‚ü© = ‚ü®xÔπîf, x Ôπî g‚ü© }

\eqn{$\langle\rangle$-Functor-Dist}{F \, ‚ü®f, g‚ü©_ùíû = ‚ü®F \, f , F \, g‚ü©_ùíü \qquad\text{ where } F : ùíû ‚Üí ùíü}

\endeqns
#+END_EXPORT

\room

These are essentially a re-write of the sum laws; let's write the next set of laws only once.

\room

Let the tuple ‚Äú‚üÖ ‚üÜ, ‚ãÜ, $l$, $r$, $\composition$‚Äù be either
‚Äú‚ü® ‚ü©, √ó, $\fst$, $\snd$, $‚àò$‚Äù or ‚Äú[ ], +, $\inl$, $\inr$, $Ôπî$‚Äù.

\room

For categories in which sums and products exist, we define for $f : A ‚Üí B$ and $g : C ‚Üí D$,

\begineqns

\eqn{$\star$-Definition}{ f ‚ãÜ g = ‚üÖ f \composition l, g \composition r‚üÜ : A ‚ãÜ C ‚Üí B ‚ãÜ D}

\eqn{$l,r$-Naturality}{ l \composition (f ‚ãÜ g) = f \composition l \landS r \composition (f ‚ãÜ g) = g \composition r }

\eqn{Extensionality}{ ‚üÖl \composition h, r \composition h‚üÜ = h}

\eqn{Absorption}{ (f ‚ãÜ g) \composition ‚üÖh, j‚üÜ = ‚üÖf \composition h, g \composition j‚üÜ }

\eqn{$\star$-Bi-Functoriality}{ \Id ‚ãÜ \Id = \Id \landS (f ‚ãÜ g) \composition (h ‚ãÜ j) = (f \composition h) ‚ãÜ (g \composition j)}

\eqn{Structural Equality}{ ‚üÖf,g‚üÜ = ‚üÖh, j‚üÜ \equivS f = h \lands g = j }

\eqn{Interchange Rule}{ ‚ü®[f,g], [h,j]‚ü© = [‚ü®f,h‚ü©,‚ü®g,j‚ü©] }

\endeqns

\room

Notice that the last law above is self-dual.

* COMMENT README

C-c C-c: evalute src block

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp :results none
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     #+HTML: <h1> CatsCheatSheet </h1>
     # OPTIONS: toc:nil

     This project is to contain a listing of common theorems in elementary category theory.

     *The repo contains other articles I've written on Category Theory;*
     *which may be read in a blog-format at:*
     https://alhassy.github.io/blog/categories/#categorytheory

     *The listing sheet, as PDF, can be found [[https://github.com/alhassy/CatsCheatSheet/blob/master/CheatSheet.pdf][here]]*,
     while below is an unruly html rendition.

     This reference sheet is built around the system https://github.com/alhassy/CheatSheet

     #+TOC: headlines 2
     #+INCLUDE: CheatSheet.org
    ")
    ;; (set-visited-file-name "ReadIt2.md")
    (org-mode)
    (org-md-export-to-markdown)
)
#+END_SRC

* COMMENT footer

(find-file "CheatSheet.el")

# Local Variables:
# eval: (org-babel-tangle)
# eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# eval: (load-file "CheatSheet.el")
# compile-command: (my-org-latex-export-to-pdf)
# End:
