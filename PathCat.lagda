#+TITLE: Graphs are to categories as lists are to monoids
#+DATE: 2018-12-24
#+AUTHOR: Musa Al-hassy
#+EMAIL: alhassy@gmail.com
#+DESCRIPTION: A fast-paced introduction to Category Theory based on the notion of graphs.
#+DESCRIPTION: Claims are proven in the Haskell-like proof assistant Agda.
# Numbers are the lengths of lists which are the flattenings of trees which are
# the spannings of graphs.
#+STARTUP: indent
#+CATEGORIES: CategoryTheory
#+OPTIONS: html-postamble:nil toc:nil d:nil
#+IMAGE: ../assets/img/PathCat.png
#+SOURCE: https://raw.githubusercontent.com/alhassy/CatsCheatSheet/master/PathCat.lagda

#+INCLUDE: ~/alhassy.github.io/content/MathJaxPreamble.org

# Begin server
#
# cd ~/alhassy.github.io/ ; bundle exec jekyll serve
#
# (preview-article)

* Abstract                                                           :ignore:
#+BEGIN_CENTER
*Abstract*
#+END_CENTER
Numbers are the lengths of lists which are the flattenings of trees which are
the spannings of graphs.
Unlike the first three, graphs have /two/ underlying types of interest
--the vertices and the edges-- and it is getting to grips with this complexity
that we attempt to tackle by considering their ‚Äòalgebraic‚Äô counterpart: Categories.

# trees are just those graphs for which arbitrary points are connected by a unique undirected path.

In our exploration of what graphs could possibly be and their relationships to lists are,
we shall /mechanise,/ or /implement,/ our claims since there will be many details and it is easy
to make mistakes --moreover as a self-learning project, I'd feel more confident to make
*bold* claims when I have a proof assistant checking my work ;-)

Assuming slight familiarity with the Agda programming language, we motivate the need for
basic concepts of category theory with the aim of discussing adjunctions with
a running example of a detailed construction and proof of a free functor.
Moreover, the article contains a host of ~exercises~ whose solutions can be found in the
literate source file. Raw Agda code can be found [[https://github.com/alhassy/CatsCheatSheet/blob/master/PathCat.agda][here.]]

Since the read time for this article is more than two hours, excluding the interspersed
exercises, it may help to occasionally consult a [[https://github.com/alhassy/CatsCheatSheet/blob/master/CheatSheet.pdf][Reference Sheet For Elementary Category Theory]].

Coming from a background in order theory, I love Galois Connections and so
our categorical hammer will not be terminal objects nor limits, but rather adjunctions.
As such, /everything is an adjunction/ is an apt slogan for us :-)

# ?universal algebra: signatures, graphs, monoids, cats

# ?However, similar to nearly everything else in this document, we can leave the setoid-approach as an exercises
# for the reader, which of course has solutions being in the literate source.

# ?instance resolution, difference from typeclass, look at tp.

#
# The approach taken here is to motivate categories from posets and the main
# tools used there are indirect reasoning (yoneda) and galois connections (adjunctions).

# \tableofcontents

#+BEGIN_SRC :tangle "PathCat.agda" 
-- This file has been extracted from https://alhassy.github.io/PathCat/
-- Type checks with Agda version 2.6.0.
#+END_SRC
* Photograph Credit                                                  :ignore:

#+LaTeX: \iffalse
#+HTML: <small> <center>
( Photo by
[[https://unsplash.com/@miklevasilyev][Mikhail Vasilyev]]
on [[https://unsplash.com/][Unsplash]] )
#+HTML: </center> </small>
#+LaTeX: \fi

# "Download free do whatever you want high-resolution photos from Unsplash."

* Introduction
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

** Motivation                                                       :ignore:

Lists give free monoids $‚Ñí\, A = (\List\, A, +\!+, [])$
---a monoid $ùíÆ = (S, ‚äï, 0_‚äï)$ is a triple consisting of a set $S$ with a binary operation 
$‚äï$ on it that is associative and has a unit, $0_‚äï$.
That it is ‚Äòfree‚Äô means that to define a structure-preserving map between monoids
$(\List\, A, +\!+, []) \,‚ü∂\, (S, ‚äï, 0_‚äï)$ it suffices to only provide a map between their
carriers $\List\, A ‚Üí S$ ---freedom means that plain old maps between types freely,
at no cost or effort, give rise to maps that preserve monoid structure.
Moreover, the converse also holds and in-fact we have a bijection:
\[
  (‚Ñí\, A ‚ü∂ ùíÆ) \qquad‚âÖ\qquad (A ‚ü∂ ùí∞\, ùíÆ)
\]
Where we write $ùí∞\, (S, ‚äï, 0_‚äï) = S$ for the operation that gives us the ùí∞nderlying carrier
of a monoid.

Loosely put, one says we have an ‚Äòadjunction‚Äô, written $‚Ñí ‚ä£ ùí∞$.

Observe that natural numbers ~‚Ñï ‚âÖ List Unit~ are a monoid whose operation is commutative.
By using different kinds of elements ~A~ --and, importantly, still not imposing any equations--
we lose commutativity with ~List A~.
Then by generalising further to binary trees ~BinTree A~, we lose associtivity and identity
are are only left with a set and an operation on it ---a structure called a ‚Äòmagma‚Äô.

This is the order that one usually learns about these inductively built structures.
One might be curious as to what the next step up is in this hierarchy of generalisations.
It is a non-inductive type called a ‚Äògraph‚Äô and in this note we investigate them by
comparison to lists.
Just as we shifted structures in the hierarchy, we will
move to a setting called a ‚Äòcategory‚Äô ---such are more structured than magmas
but less restrictive than monoids.

For those who know category theory, this article essentially formalises the
often seen phrase ‚Äúconsider the category generated by this diagram, or graph‚Äù.
Indeed every category is essentially a free category over a graph but with
additional equations that ‚Äòconfuse‚Äô two paths thereby declaring, e.g., that
one edge is the composition of two other edges.

** Imports
:PROPERTIES:
:UNNUMBERED: t
:END:

In our exploration of what graphs could possibly be and their relationships to lists are,
we shall /mechanise/ or /implement/ our claims since there will be many details and it is easy
to make mistakes --moreover as a self-learning project, I'd feel more confident to make
*bold* claims when I have a proof assistant checking my work ;-)

Before reading any further please ingrain into your mind that the Agda keyword
~Set~ is read ‚Äútype‚Äù! This disparity is a historical accident.

Since the Agda prelude is so simple, the core language doesn‚Äôt even come with Booleans or numbers by default
---they must be imported from the standard library. This is a pleasant feature.
As a result, Agda code tends to begin with a host of imports.

#+BEGIN_SRC agda
module PathCat where

open import Level using (Level) renaming (zero to ‚Ñì‚ÇÄ ; suc to ‚Ñìsuc ; _‚äî_ to _‚äç_)

-- Numbers
open import Data.Fin
  using (Fin ; to‚Ñï ; from‚Ñï ; from‚Ñï‚â§ ; reduce‚â• ; inject‚â§)
  renaming (_<_ to _f<_ ; zero to fzero ; suc to fsuc)
open import Data.Nat
open import Relation.Binary using (module DecTotalOrder)
open import Data.Nat.Properties using(‚â§-decTotalOrder ; ‚â§-refl)
open DecTotalOrder Data.Nat.Properties.‚â§-decTotalOrder

-- Z-notation for sums
open import Data.Product using (Œ£ ; proj‚ÇÅ ; proj‚ÇÇ ; _√ó_ ; _,_)
Œ£‚à∂‚Ä¢ : {a b : Level} (A : Set a) (B : A ‚Üí Set b) ‚Üí Set (a ‚äç b)
Œ£‚à∂‚Ä¢ = Œ£
infix -666 Œ£‚à∂‚Ä¢
syntax Œ£‚à∂‚Ä¢ A (Œª x ‚Üí B) = Œ£ x ‚à∂ A ‚Ä¢ B

-- Equalities
open import Relation.Binary.PropositionalEquality using (_‚âó_ ; _‚â°_)
  renaming (sym to ‚â°-sym ; refl to ‚â°-refl ; trans to _‚ü®‚â°‚â°‚ü©_ 
           ; cong to ‚â°-cong ; cong‚ÇÇ to ‚â°-cong‚ÇÇ 
           ; subst to ‚â°-subst ; subst‚ÇÇ to ‚â°-subst‚ÇÇ ; setoid to ‚â°-setoid)
#+END_SRC

Notice that we renamed transitivity to be an infix combinator.

Let us make equational-style proofs available for any type.
#+BEGIN_SRC agda
module _ {i} {S : Set i} where
    open import Relation.Binary.EqReasoning (‚â°-setoid S) public
#+END_SRC

We intend our proofs to be sequences of formulae interleaved with
justifications for how the formulae are related. At times, the justifications
are by definition and so may be omitted, but we may want to mention them
for presentational --pedagogical?-- purposes. Hence, we introduce the
combinator notation ~lhs ‚â°‚ü®" by definition of something "‚ü©‚Ä≤ rhs~.
# --note that this combinator is intended to only be used in calculations.

#+BEGIN_SRC agda
open import Agda.Builtin.String

defn-chasing : ‚àÄ {i} {A : Set i} (x : A) ‚Üí String ‚Üí A ‚Üí A
defn-chasing x reason supposedly-x-again = supposedly-x-again

syntax defn-chasing x reason xish = x ‚â°‚ü® reason ‚ü©‚Ä≤ xish

infixl 3 defn-chasing
#+END_SRC

While we‚Äôre making synonyms for readability, let‚Äôs make another:
#+BEGIN_SRC agda
_even-under_ : ‚àÄ {a b} {A : Set a} {B : Set b} {x y} ‚Üí x ‚â° y ‚Üí (f : A ‚Üí B) ‚Üí f x ‚â° f y 
_even-under_ = Œª eq f ‚Üí ‚â°-cong f eq
#+END_SRC

Example usage would be to prove
~mor G (mor F Id) ‚â° mor G Id~ directly by ~‚â°-cong (mor G) (id F)~ 
which can be written more clearly as
~functor F preserves-identities even-under (mor G)~, 
while longer it is also much clearer and easier to read and understand
--self-documenting in some sense.

Interestingly, our first calculational proof is in section 5 when
we introduced an large ùíûùí∂ùìâegory.

* /Graph me to the moon!/
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

#+BEGIN_CENTER
/What's a graph? Let's motivate categories!/
#+END_CENTER

** Intro                                                            :ignore:
A ‚Äògraph‚Äô is just a parallel-pair of maps,
#+BEGIN_SRC agda
record Graph‚ÇÄ : Set‚ÇÅ where
  field
    V   : Set
    E   : Set
    src : E ‚Üí V
    tgt : E ‚Üí V
#+END_SRC
This of-course captures the usual notion of a set of nodes ~V~ and a set of directed and labelled
edges ~E~ where an edge ~e~ begins at ~src e~ and concludes at ~tgt e~.

What is good about this definition is that it can be phrased in any category: ~V~ and ~E~ are
any two objects and ~src, tgt~ are a parallel pair of morphisms between them.
How wonderful! We can study the notion of graphs in arbitrary categories!
---This idea will be made clearer when categories and functors are formally introduced.

However, the notion of structure-preserving map between graphs, or ‚Äògraph-maps‚Äô for short,
then becomes:

#+BEGIN_SRC agda
record _ùí¢‚ü∂‚ÇÄ_ (G H : Graph‚ÇÄ) : Set‚ÇÅ where
  open Graph‚ÇÄ
  field
    vertex : V(G) ‚Üí V(H)
    edge   : E(G) ‚Üí E(H)
    src-preservation : ‚àÄ e ‚Üí src(H) (edge e) ‚â°  vertex (src(G) e)
    tgt-preservation : ‚àÄ e ‚Üí tgt(H) (edge e) ‚â°  vertex (tgt(G) e)
#+END_SRC
( The fancy ùí¢ and ‚ü∂ are obtained in Agda input mode by ~\McG~ and ~\-->~, respectively. )

This is a bit problematic in that we have two proof obligations and at a first glance it is not
at all clear their motivation besides ‚Äò‚Äòstructure-preserving‚Äô‚Äô.

However, our aim is in graphs in usual type theory, and as such we can use a definition that is
equivalent in this domain: A graph is a
type ~V~ of vertices and a ‚Äòtype‚Äô ~v ‚ü∂ v‚Äô~ of edges for each pair of vertices ~v~ and ~v‚Äô~.
#+BEGIN_SRC agda
-- ‚Äòsmall graphs‚Äô , since we are not using levels
record Graph : Set‚ÇÅ where
  field
    V    : Set
    _‚ü∂_ : V ‚Üí V ‚Üí Set

-- i.e., Graph ‚âà Œ£ V ‚à∂ Set ‚Ä¢ (V ‚Üí V)
-- Graphs are a dependent type!
#+END_SRC

Now the notion of graph-map, and the meaning of structure-preserving, come to the forefront:

#+BEGIN_SRC agda
record GraphMap (G H : Graph) : Set‚ÇÅ where    
    private
      open Graph using (V)
      _‚ü∂g_ = Graph._‚ü∂_ G
      _‚ü∂h_ = Graph._‚ü∂_ H
    field
      ver  : V(G) ‚Üí V(H)                                -- vertex morphism
      edge : {x y : V(G)} ‚Üí (x ‚ü∂g y) ‚Üí (ver x ‚ü∂h ver y) -- arrow preservation

open GraphMap
#+END_SRC

Note ~edge~ essentially says that ~mor~ ‚Äòshifts‚Äô, or ‚Äòtranslates‚Äô, types
~x ‚ü∂g y~ into types ~ver x ‚ü∂h ver y~.

While equivalent, this two-piece definition is preferable over the four-piece one given
earlier since it means less proof-obligations and less constructions in general, but the same
expressiblity. Yay!

Before we move on, let us give an example of a simple chain-graph.
For clarity, we present it in both variations.
#+BEGIN_SRC agda
-- embedding: j < n ‚áí j < suc n
`_ : ‚àÄ{n} ‚Üí Fin n ‚Üí Fin (suc n)
` j = inject‚â§ j (‚â§-step ‚â§-refl) where open import Data.Nat.Properties using (‚â§-step)
#+END_SRC
This' an example of a ‚Äòforgetful functor‚Äô, keep reading!

#+BEGIN_SRC agda
[_]‚ÇÄ : ‚Ñï ‚Üí Graph‚ÇÄ
[ n ]‚ÇÄ = record 
    { V = Fin (suc n)                  -- ‚âà {0, 1, ..., n - 1, n}
    ; E = Fin n                        -- ‚âà {0, 1, ..., n - 1}
    ; src = Œª j ‚Üí ` j
    ; tgt = Œª j ‚Üí fsuc j
    }
#+END_SRC
That is, we have ~n+1~ vertices named ~0, 1, ‚Ä¶, n~ and ~n~ edges named ~0, 1, ‚Ä¶, n-1~
with one typing axiom being ~j : j ‚ü∂ (j+1)~. Alternatively,

#+BEGIN_SRC agda
[_] : ‚Ñï ‚Üí Graph
[ n ] = record {V = Fin (suc n) ; _‚ü∂_ = Œª x y ‚Üí fsuc x ‚â° ` y }
#+END_SRC

** Types Require Casting
However, we must admit that a slight downside of the typed approach
--the two-piece definition-- is now
we may need to use the following ‚Äòshifting‚Äô combinators: 
They shift, or slide, the edge types.

#+BEGIN_EXAMPLE
-- casting
_‚ü´_ : ‚àÄ{x y y‚Äô} ‚Üí  (x ‚ü∂ y) ‚Üí (y ‚â° y‚Äô) ‚Üí (x ‚ü∂ y‚Äô)
e ‚ü´ ‚â°-refl = e

-- Casting leaves the edge the same, only type information changes
‚âÖ-‚ü´ : ‚àÄ{x y y‚Äô} {e : x ‚ü∂ y} (y‚âày‚Äô : y ‚â° y‚Äô) ‚Üí e ‚âÖ (e ‚ü´ y‚âày‚Äô)
‚âÖ-‚ü´ ‚â°-refl = ‚âÖ-refl
#+END_EXAMPLE

Such is the cost of using a typed-approach.

Even worse, if we use homogeneous equality then we‚Äôd have the ghastly operator
#+BEGIN_EXAMPLE
‚â°-‚ü´ : ‚àÄ{x y y‚Äô} {e : x ‚ü∂ y} (y‚âày‚Äô : y ‚â° y‚Äô) ‚Üí e ‚ü´ y‚âày‚Äô ‚â° (‚â°-subst (Œª œâ ‚Üí x ‚ü∂ œâ) y‚âày‚Äô e)
#+END_EXAMPLE

However, it seems that our development does not even make use of these.
Lucky us! However, it is something to be aware of.

** Signatures

A /signature/ consists of ‚Äòsort symbols‚Äô and ‚Äòfunction symbols‚Äô each of which is associated source-sorts
and a target-sort --essentially it is an interface in the programming sense of the word thereby providing
a lexicon for a language.
A /model/ or /algebra/ of a language is an interpretation of the sort symbols as sets and an interpretation of the
function symbols as functions between those sets; i.e., it is an /implementation/ in programming terms.
Later you may note that instead of sets and functions we may use the objects and morphisms of
a fixed category instead, and so get a model in that category.

#+BEGIN_CENTER
| _Math_           | ‚âÖ | _Coding_                             |
| Signature      |   | Interface, record type, class      |
| Algebra        |   | Implementation, instance, object   |
| Language Term  |   | Syntax                             |
| Interpretation |   | Semantics, i.e., an implementation |
#+END_CENTER

Formally, one-sorted signatures are defined:
#+BEGIN_SRC agda
open import Data.Vec 
  using (Vec) 
  renaming (_‚à∑_ to _,,_ ; [] to nil) -- , already in use for products :/
  
-- one sorted
record Signature : Set where
    field
     ùí© : ‚Ñï        -- How many function symbols there are
     ar : Vec ‚Ñï ùí© -- Their arities: lookup i ar == arity of i-th function symbol

open Signature ‚¶É...‚¶Ñ -- ùí© now refers to the number of function symbols in a signature
#+END_SRC

For example, the signature of monoids consists of a single sort symbol ~C~ --which can be
interpreted as the carrier of the monoid-- and two function symbols ~m , u~
--which can be interpreted as the monoid multiplication and unit-- with source-target
sort lists ~((),C) , ((C,C), C)~ ---some would notate this by ~u :‚Üí C , m : C √ó C ‚Üí C~.
#+BEGIN_SRC agda
MonSig : Signature
MonSig = record { ùí© = 2 ; ar = 0 ,, 2 ,, nil }
-- unit u : X‚Å∞ ‚Üí X and multiplication m : X¬≤ ‚Üí X
#+END_SRC

Generalising on monoids by typing the multiplication we obtain
the signature of categories which consists of three sort symbols ~O, A, C~ --which can be
interepreted as objects, arrows, and composable pairs of arrows-- and four function symbols
~‚®æ , src, tgt, id~ with source-target sort lists ~(C,A) , (A,O) , (A,O) , (O,A)~
---notice that only a language of symbols
has been declared without any properties besides those of typing. If we discard ~C, ‚®æ, id~ we
then obtain the signature of graphs. Without knowing what categories are, we have seen that their
signatures are similar to both the graph and monoid signatures and so expect their logics to
also be similar. Moreover we now have a few slogans,
\[\color{green}{\text{Categories are precisely typed monoids!}}\]
\[\color{green}{\text{Categories are precisely graphs with a monoidal structure!}}\]
\[\color{green}{\text{Categories are precisely coherently constructive lattices!}}\]

( The last one is completely unmotivated from our discussion, but it's a good place for the slogan and
  will be touched on when we look at examples of categories. )

A signature can be visualised in the plane by associating a dot for each sort symbol and an arrow
for each function symbol such that the arrow has a tail from each sort in the associated function
symbols source sorts list and the end of the arrow is the target sort of the sort symbol.
That is, a signature can be visualised as a hyper-graph.

+ A signature whose function symbols each have only one sort symbol for source-sorts is called a
  ‚Äògraph signature‚Äô since it corresponds to ---or can be visualised as--- a graph.

+ Then a model of a graph (signature) ~ùí¢~ is an interpreation/realisation of the graph‚Äôs vertices
  as sets and the graph‚Äôs edges as functions between said sets.

+  A model of ~ùí¢~ is nothing more than a graph morphism
   ~ùí¢ ‚ü∂ ùíÆeùìâ~, where ~ùíÆeùìâ~ is the graph with vertices being sets and edges being functions.

Notice that a ~Graph‚ÇÄ~ is precisely a model of the graph ~‚Ä¢ ‚áâ ‚Ä¢~, which consists of 
two vertices and two edges from the first vertex to the second vertex. 
We will return to this point ;-)

Before we move on, it is important to note that a signature does not capture any
constraints required on the symbols --e.g., a monoid is the monoid signature as well
as the constraint that the 2-arity operation is associative and the 0-arity operation is its unit.
More generally, a /specification/ consists of a signature declaring symbols of interest,
along with a set of sentences over it that denote axioms or constraints.
In programming parlance, this is an interface consisting of types and functions
that need to be provided and implemented, along with constraints that are usually documented in comments.
Unsurprisingly, models of specifications also form categories.

* /Cats but no alligators/
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

# Category and functor defns
# {A poor-man‚Äôs definition of Category}

In this section we introduce the notion of a ‚Äò‚Äòpoor-man‚Äôs category‚Äô‚Äô along with the notion of
structure preserving transformations and structure preserving transformations between such
transformations. The former are called /functors/ and the latter are known as /natural transformations/
and are considered one of the most important pieces of the fundamentals of category theory; 
as such, we discuss them at length. 
Afterwards, we relate this section back to our motivating discussion of graphs.

** Strict Categories
A category, like a monoid, is a a few types and operations for which some equations hold.
However, to discuss equations a notion of equality is needed and rather than enforce one
outright it is best to let it be given. This is a ‚Äòset‚Äô in constructive mathematics:
A type with an ~E~-quivalence relation on it ---also called a /setoid/ or an ~E~-set.
However, then the structure must have a few added axioms: The operations must be congruences,
i.e., preserve the equivalence relation, and structure-preserving maps must also be congruences.

For our purposes we will use propositional equality and point-wise propositional equality,
and as such most of the proofs fall out of the fact that propositional equality is an equivalence.
However, this setoid structure becomes a bit of a noise, without providing any real insight for our uses, 
and the issues of equivalences will be a distraction from the prime focus. 
Instead, for our two cases where we use point-wise propositional,
we will postulate two forms of extensionality. Without question this is not a general approach
---then again, our aim is not to develop a library for category theory, which has already been
done so elegantly by Kahl who calls it the [[http://relmics.mcmaster.ca/RATH-Agda/RATH-Agda-2.0.0.pdf][RATH-Agda]] project.

#+BEGIN_SRC agda
module _ where -- An anyonomous module for categorial definitions
    
 record Category {i j : Level} : Set (‚Ñìsuc (i ‚äç j)) where
  infixr 10 _‚®æ_
  field
    Obj      : Set i
    _‚ü∂_     : Obj ‚Üí Obj ‚Üí Set j
    _‚®æ_      : ‚àÄ {A B C : Obj} ‚Üí A ‚ü∂ B ‚Üí B ‚ü∂ C ‚Üí A ‚ü∂ C
    assoc    : ‚àÄ {A B C D} {f : A ‚ü∂ B}{g : B ‚ü∂ C} {h : C ‚ü∂ D} ‚Üí (f ‚®æ g) ‚®æ h ‚â° f ‚®æ (g ‚®æ h)
    Id       : ‚àÄ {A : Obj} ‚Üí A ‚ü∂ A
    leftId   : ‚àÄ {A B : Obj} {f : A ‚ü∂ B} ‚Üí Id ‚®æ f ‚â° f
    rightId  : ‚àÄ {A B : Obj} {f : A ‚ü∂ B} ‚Üí f ‚®æ Id ‚â° f

 open Category using (Obj)
 open Category ‚¶É...‚¶Ñ hiding (Obj)

 -- Some sugar for times when we must specify the category
 -- ‚Äúcolons associate to the right‚Äù ;-)
 
 arr = Category._‚ü∂_ 
 syntax arr ùíû x y  =  x ‚ü∂ y ‚à∂ ùíû    -- ‚Äúghost colon‚Äù

 cmp = Category._‚®æ_
 syntax cmp ùíû f g  =  f ‚®æ g ‚à∂ ùíû    -- ‚Äúghost colon‚Äù
#+END_SRC

However, similar to nearly everything else in this document, we can leave the setoid approach as an exercise
for the reader, which of course has solutions being in the literate source.
#
# I've moved the setoid-based theory to an appendix at the end, 
# it seems I must enforce setoid structure at the outset
# and I really do not think it is worth it for my intended purposes; moreover, 
# it adds noise to the presentation without giving enough insight.

Moreover, lest you‚Äôre not convinced that my usage of extensionality is at all acceptable,
then note that others have used it to simplify their presentations; e.g.,
[[http://cs.ioc.ee/~tarmo/papers/jfr14.pdf][Relative monads formalised]].
Such ‚Äòappeal to authority‚Äô is for the lazy reader who dares not think for him- or her-self,
otherwise one ought to read up on the [[https://ncatlab.org/nlab/show/principle+of+equivalence][evils]]
of using equality instead of equivalence relations so as to understand
[[http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf][when one thing is really another]].

The diligent reader may be interested to know that Maarten Fokkinga has written a very
[[http://maartenfokkinga.github.io/utwente/mmf92b.pdf][gentle introduction to category theory using the calculational approach]]; I highly recommend it!

Anyhow, in place of strict equality, one uses categorical isomorphism instead.
#+BEGIN_SRC agda
 open Category using (Obj) public
 
 record Iso {i} {j} (ùíû : Category {i} {j}) (A B : Obj ùíû) : Set j where
   private instance ùíû‚Ä≤ : Category ; ùíû‚Ä≤ = ùíû
   field
     to   : A ‚ü∂ B
     from : B ‚ü∂ A
     lid  : to ‚®æ from ‚â° Id
     rid  : from ‚®æ to ‚â° Id
     
 syntax Iso ùíû A B = A ‚âÖ B within ùíû
#+END_SRC

Interestingly, we shall later encounter a rather large category named
ùíûùí∂ùìâ possessing the special property of being a [[https://ncatlab.org/nlab/show/2-category][‚Äú2-Category‚Äù]]: 
It has morphisms between objects, as expected, which are now called ‚Äú1-morphisms‚Äù,
and it has morphisms between 1-morphisms, also called ‚Äú2-morphisms‚Äù.

That is, it has morphisms between morphisms.

Above we argued that equality should be deferred in favour of isomorphism
at the morphism level. Hence, in a 2-Category, it is only reasonable to defer
an equation involving objects to be up to isomorphism of 2-morphisms
---this is then called an ‚Äúequivalence‚Äù.
#+BEGIN_EXAMPLE
‚ÑíHS ‚âÉ ‚ÑõHS  ‚áî  Œ£ F ‚à∂ ‚ÑíHS ‚ü∂ ‚ÑõHS ‚Ä¢ Œ£ G ‚à∂ ‚ÑõHS ‚ü∂ ‚ÑíHS ‚Ä¢ F ‚®æ G ‚âÖ G ‚®æ F ‚âÖ Id
#+END_EXAMPLE

Hence when it comes to categories themselves, one usually speaks in terms of 
equivalences rather than isomorphisms.

# E.g., ~ùíÆeùìâ ^ S ‚âÉ ùíÆeùìâ / S~, where ~S~ is construed as a discrete category 
# on the lhs but a set on the rhs.

# also :: every category is equivalent to a skeletal subcategory

For example, let ùí´ùí∂ùìá be the supercategory of ùíÆeùìâ with morphisms being ‚Äòpartial functions‚Äô
\newline ~(A ‚ü∂ B) = (A ‚Üí B + ùüô)~ where the extra element of ~ùüô = { * }~ represents ‚Äòundefined‚Äô
---also known as the ~Partial~, ~Option~, or ~Maybe~ monads.
Moreover, let ùí´ùíÆ‚ÑØùìâ be the category of sets with an elected point.
Then, ~ùí´ùí∂ùìá ‚âÉ ùí´ùíÆeùìâ~ is witnessed by ~(A ‚ü∂ B) ‚Ü¶ ( (A + ùüô, *) ‚ü∂ (B + ùüô, *) )~
and conversely \newline ~( (A , a) ‚ü∂ (B , b) ) ‚Ü¶ ( A - a ‚ü∂ B - b)~ where
~X - x ‚â° Œ£ y ‚à∂ X ‚Ä¢ ¬¨(x ‚â° y)~. \newline Exercise: Work out the remaining details
for the equivalence.

:ParSetup:
\begin{spec}
_‚ü∂_ : Set ‚Üí Set ‚Üí Set
A ‚ü∂ B = A ‚Üí B ‚äé ‚ä§

_‚ü∂‚Äô_ : ‚àÄ {a} (AA BB : Œ£ X ‚à∂ Set a ‚Ä¢ X) ‚Üí Set _
(A , a) ‚ü∂‚Äô (B , b) = Œ£ f ‚à∂ (A ‚Üí B) ‚Ä¢ f a ‚â° b

‚à£_‚à£ : ‚àÄ {A B} ‚Üí A ‚ü∂ B ‚Üí ((A ‚äé ‚ä§) , inj‚ÇÇ tt) ‚ü∂‚Äô ((B ‚äé ‚ä§) , inj‚ÇÇ tt)
‚à£_‚à£ {A} {B} f = f‚Äô , refl
  where f‚Äô : A ‚äé ‚ä§ ‚Üí B ‚äé ‚ä§
        f‚Äô (inj‚ÇÇ tt) = inj‚ÇÇ tt
        f‚Äô (inj‚ÇÅ x) with f x
        ...~ inj‚ÇÅ x‚ÇÅ = inj‚ÇÅ x‚ÇÅ
        ...~ inj‚ÇÇ tt = inj‚ÇÇ tt
#+END_EXAMPLE
:End:

** COMMENT arrows in a particular category :syntax:

 arr-in-cat : ‚àÄ{i j} (ùíû : Category {i} {j}) (A B : Obj ùíû) ‚Üí Set j
 arr-in-cat = Category._‚ü∂_
 infix -66 arr-in-cat
 syntax arr-in-cat ùíû A B  =  A ‚ü∂ B ‚à∂ ùíû -- note the ‚Äúghost colon‚Äù
  
 -- open Category ‚¶É...‚¶Ñ hiding (Obj)
 open Category using (Id)

** Familiar ~ùíÆ‚ÑØùìâ~-tings
Let us give some elementary examples of the notion of a category to exhibit its ubiquity.

*** ùíÆ‚ÑØùìâ's
The collection of small, say level ~i~, types and functions between them and usual function composition
with usual identity form a category and this is not at all difficult to see:
#+BEGIN_SRC agda
 instance
  ùíÆeùìâ : ‚àÄ {i} ‚Üí Category {‚Ñìsuc i} {i} -- this is a ‚Äòbig‚Äô category
  ùíÆeùìâ {i} = record {
      Obj = Set i
    ; _‚ü∂_ = Œª A B ‚Üí (A ‚Üí B)
    ; _‚®æ_ = Œª f g ‚Üí (Œª x ‚Üí g (f x))
    ; assoc = ‚â°-refl
    ; Id = Œª x ‚Üí x
    ; leftId = ‚â°-refl
    ; rightId = ‚â°-refl
    }
#+END_SRC
Sadly, this category is traditionally used to motivate constructions in arbitrary categories
and as such people usually think of objects in an arbitrary category as nothing more than
sets with extra datum ---which is completely false.

For example, the category ~Div~ consists of objects /and/ arrows both being numbers ‚Ñï
and there is an arrow $k : m ‚Üí n$ precisely when ~k √ó m = n~, so that an arrow is a
constructive witness that $m$ divides $n$. Notice that besides ‚Ñï, no sets nor functions
were involved in the making of this useful number-theoretic category.
# --if you know some category theory, convince yourself that this category is interesting
# by showing, for example, that multiplication distributes over gcd where gcd is the 
# categorial product construction.

*** Sets are trivial categories

Recall that a type, or set, is nothing more than a specified collection of values.

Every set is also a category: There is a formal syntactic object associated with each element, the only morphisms are (formal)
identities, and composition is constantly a syntactic identity.
Some define a set to be a category with only identity morphisms; also called a
‚Äòdiscrete category‚Äô when one wants to distance themself from set theory ;)
---less loosely, a discrete category over a type ~S~ has ~Obj = S~ and ~(x ‚ü∂ y) = (x ‚â° y)~,
where the equivalence is classical, having two possible members /true/ or /false/.

Discrete categories are quite an important space for [[http://homotopytypetheory.org/][hott]] people ... 
that‚Äôs right, attractive people are interested in these things.

Observe that all arrows are invertible! ---due to the symmetry of equality.
Categories with this property are known as /groupoids/.

*** Categories are typed monoids

Recall that a monoid ~(M, ‚äï, e)~ is a type ~M~ with an associative operation ~‚äï : M √ó M ‚Üí M~
that has a unit ~e~.

Every monoid is also a category: There is one object, call it ~‚òÖ~, the morphisms are the monoid
elements, and composition is the monoid operation. 
---less loosely, for a monoid ~(M, ‚äï, e)~ we take ~Obj = {‚òÖ} , _‚ü∂_ = M~.

In fact, some would define a monoid to be a one-object category!
--I'm looking at you [[https://books.google.ca/books/about/Categories_Allegories.html?id=fCSJRegkKdoC&printsec=frontcover&source=kp_read_button&redir_esc=y#v=onepage&q&f=false][Freyd & Scedrov]] =)

*** Categories are coherently preordered sets

[[http://www.cs.utexas.edu/~EWD/ewd11xx/EWD1102.PDF][Recall]] that a preordered set, or preset, is a type ~P~ with a relation ~‚â§~ on 
it that satisfies /indirect inequality from above/:
\[
  ‚àÄ x , y ‚Ä¢\qquad x ‚â§ y \quad‚áî\quad (‚àÄ z ‚Ä¢\; y ‚â§ z ‚áí x ‚â§ z)
\]
Equivalently, if it satisfies /indirect equality from below/:
\[ ‚àÄ x , y ‚Ä¢\qquad x ‚â§ y \quad‚áî\quad (‚àÄ z ‚Ä¢\; z ‚â§ x ‚áí z ‚â§ y) \]
If we also have $‚àÄ x , y ‚Ä¢\; x ‚â§ y \,‚àß\, y ‚â§ x \;‚áí\; x = y$, 
then we say ~(P, ‚â§)~ is a ‚Äòposet‚Äô or an ‚Äòordered set‚Äô.

Every (pre)ordered set is also a category:
The objects are the elements, 
the morphisms are the order-relations, 
identities are the relfexitivity of ~‚â§~, 
and composition is transitivity of ~‚â§~.
To see this more clearly, suppose you have a group
$(M, ‚äï, \_{}‚Åª¬π, e)$ and you define $x ‚â§ y \;‚áî\; (‚àÉ m : M ‚Ä¢\; m ‚äï x = y)$
then the this is a preorder whose induced category has a morphism 
$m : x ‚Üí y$ precicely when $m ‚äï x = y$
--now sit down and define the remaining categorical structure of this
‚Äòconstructive‚Äô preorder associated to the group.
# and check that this category has $e$ for identity maps and $‚äï$
# for composition of morphisms.
#
# Preorder:
# If m ‚äï x = y  and n ‚äï y = x
# Then x = n ‚äï y = n ‚äï m ‚äï x whence e = n ‚äï m, whence we have isos not necessarily equality.

Traditionally, classically, the relation ~‚â§~ is precicely a function ~P √ó P ‚ü∂ ùîπ = {true, flase}~
and thus there is at-most one morphism between any two objects
--consequently, categories with this property are called /poset categories/.

In the constructive setting, the relation ~‚â§~ is typed ~P √ó P ‚Üí Set~ and then
for a preset ~(P, ‚â§)~ we take ~Obj = P, _‚ü∂_ = a ‚â§ b~ and insist
on ‚Äòproof-irrelevance‚Äô ~‚àÄ {a b} (p q : a ‚â§ b) ‚Üí p ‚â° q~ so that there is at most one morphism
between any two objects.
The restriction is not needed if we were using actual categories-with-setoids since then we would
/define/ morphism equality to be \\
~((a, b, p) ‚âà (a‚Äô, b‚Äô, q) )  =  (a ‚â° a‚Äô  √ó  b ‚â° b‚Äô)~.

Observe that in the case we have a poset, every isomorphism is an equality:
\[
  ‚àÄ x, y ‚Ä¢\qquad x ‚âÖ y ‚áî x ‚â° y
\]
Categories with this property are called /skeletal/.
Again, hott people like this; so much so, that they want it, more-or-less, to be a
[[http://arxiv.org/abs/1302.4731][foundational axiom]]!

Poset categories are a wonderful and natural motivator for many constructions and definitions in
category theory. This idea is so broad-reaching that it would not be an exaggeration to think of
[[http://www.cs.nott.ac.uk/~psarb2/papers/abstract.html#CatTheory][categories as coherently constructive lattices]]!

*** Groupoids
Equivalence relations are relations that are symmetric, reflexive, and transitive.
Alternatively, they are preorder categories where every morphism is invertible ---this is the
symmetry property. But categories whose morphisms are invertible are groupoids!

Hence, groupoids can be thought of as generalized equivalence relations.
Better yet, as ‚Äúconstructive‚Äù equivalence relations: there might be more than one morphism/construction
witnessing the equivalence of two items.

Some insist that a /true/ ‚Äòset‚Äô is a type endowed with an equivalence relation, that is a setoid.
However, since groupoids generalise equivalence relations, others might insist on a true set to be
a "groupoid". However, in the constructive setting of dependent-type theory, these notions
coincide!

*** Rule of Thumb

It‚Äôs been said that the aforementioned categories should be consulted whenever one learns a new
concept of category theory.
Indeed, these examples show that a category is a generalisation of a system of processes,
a system of compositionality, and an ordered system.

* /Endowing Structure with Functors/
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

** Definition :ignore:
Now the notion of structure-preserving maps, for categories, is just that of graphs 
but with attention to the algebraic portions as well.

#+BEGIN_SRC agda
 record Functor {i j k l} (ùíû : Category {i} {j}) (ùíü : Category {k} {l}) 
  : Set (‚Ñìsuc (i ‚äç j ‚äç k ‚äç l)) where
  private
    instance
      ùíû‚Ä≤ : Category ;  ùíû‚Ä≤ = ùíû
      ùíü‚Ä≤ : Category ;  ùíü‚Ä≤  = ùíü
  field
    -- Usual graph homomorphism structure: An object map, with morphism preservation
    obj   : Obj ùíû ‚Üí Obj ùíü                           
    mor   : ‚àÄ{x y : Obj ùíû} ‚Üí x ‚ü∂ y ‚Üí obj x ‚ü∂ obj y
    -- Interaction with new algebraic structure: Preservation of identities & composition
    id    : ‚àÄ{x   : Obj ùíû} ‚Üí mor (Id {A = x}) ‚â° Id       -- identities preservation
    comp  : ‚àÄ{x y z} {f : x ‚ü∂ y} {g : y ‚ü∂ z} ‚Üí mor (f ‚®æ g) ‚â° mor f ‚®æ mor g

  -- Aliases for readability
  functor_preserves-composition = comp
  functor_preserves-identities  = id

 open Functor public hiding (id ; comp)
#+END_SRC

For a functor ~F~, it is common practice to denote both ~obj F~ and ~mor F~ by ~F~ and this is usually
not an issue since we can use type inference to deduce which is meant. However, in the Agda formalization
we will continue to use the names ~mor , obj~. Incidentally in the Haskell community, ~mor~
is known as ~fmap~ but we shall avoid that name or risk asymmetry in the definition of
a functor, as is the case in Haskell which turns out to be pragmatically useful.

A functor can be thought of as endowing an object with some form of structure
---since categories are intrinsically structureless in category theory---
and so the morphism component of a functor can be thought of as preserving relations:
~f : a ‚ü∂ b ‚áí F f : F a ‚ü∂ F b~ can be read as, ‚Äò‚Äòif ~a~ is related to ~b~ (as witnessed by ~f~)
then their structured images are also related (as witness by ~F f~)‚Äô‚Äô.
Recall the category ~Div~ for constructive divisibility relationships ;-)

** COMMENT Synonyms for Readability

While we‚Äôre close to the definition, let‚Äôs introduce some synonyms for readability
#+BEGIN_EXAMPLE
 module _ {i j k l} {ùíû : Category {i} {j}} {ùíü : Category {k} {l}} {F : Functor ùíû ùíü}
  where

    functors-preserve-composition = Functor.comp F
    functors-preserve-identities  = Functor.id F
#+END_EXAMPLE
We make these as synonyms rather than names in the record since we do not want to use such lengthy
identifiers when realizing functor instances. The reason we do not make these synonyms in the
record but rather in a public dummy module is to make the functor in question found from the ambient
context via the implicit declaration ~{F : Functor ùíû ùíü}~.

Musa: Apparently, the above intention did not work as desired.
Most of the time, I had to supply the functor anyways.

** COMMENT Functor Conventions
In informal mathematics a functor ~F = (obj , mor, preservation proofs)~
is usually presented as \\ /F = (F‚ÇÄ, F‚ÇÅ) is a functor (exercise to reader)/.

‚Äúendo‚Äù-morphism is a morphism with the
same source and target, an ‚Äúauto‚Äù-morphism
is an isomorphism with the same source and
target.

Say ‚Äúco‚Äù-functor as short for ‚Äúco‚Äùntravariant
functor. Notice that the composition of
cofunctors is a covaraint functor ---cf the multiplication of negative numbers is a positive functor.
 
** Examples

A functor among monoids --construed as categories-- is just a monoid homomorphism;
i.e., an identity and multiplication preserving function of the carriers.
\[ (M, ‚äï, e) ‚ü∂ (N, ‚äó, d) \quad=\quad Œ£ h ‚à∂ M ‚Üí N \;‚Ä¢\; ‚àÄ x,y \;‚Ä¢\; h(x ‚äï y) = h x ‚äó h y \;‚àß\; h e = d \]
# By induction, ~h~ preserves all finite multiplications:
# ~h (‚äï i ‚à∂ 1..n ‚Ä¢ x·µ¢) = (‚äó i ‚à∂ 1..n ‚Ä¢ h x·µ¢)~ where
# ~(‚òÖ i ‚à∂ 1..n ‚Ä¢ y·µ¢) ‚âî e ‚òÖ y‚ÇÅ ‚òÖ y‚ÇÇ ‚ãØ ‚òÖ y‚Çô~.
# More generally, 
By induction, ~h~ preserves all finite ‚äï-multiplication and, more generally,
functors preserve finite compositions:
\[ F (f‚ÇÄ ‚®æ f‚ÇÅ ‚®æ ‚ãØ ‚®æ f‚Çô) \;\;=\;\; F\,f‚ÇÄ ‚®æ F\,f‚ÇÅ ‚®æ ‚ãØ ‚®æ F\,f‚Çô \]
Cool beans :-)
# ~F (‚®æ i ‚à∂ 1..n ‚Ä¢ f·µ¢) = (‚®æ i ‚à∂ 1..n ‚Ä¢ F f·µ¢)~
In the same way, sit down and check your understanding!
+ A functor among discrete categories is just a function of the associated sets.
+ A functor among poset categories is an order-preserving function.

Two examples of functors from a poset (category) to a monoid (category):

+ ~monus : (‚Ñï, ‚â§) ‚ü∂ (‚Ñï,+, 0)~ is a functor defined on morphisms by
  \[ i ‚â§ j \quad‚áí\quad \mathsf{monus}(i,j) ‚âî j - i\] 
  Then the functor laws become  ~i - i = 0~ and ~(k - j) + (j - i) = k - i~.

+ ~div : (‚Ñï‚Å∫, ‚â§) ‚Üí (‚Ñö, √ó, 1)~ is defined on morphisms by
  \[i ‚â§ j \quad‚áí\quad \mathsf{div}(i,j) ‚âî j / i\]
  The functor laws become ~i / i = 1~ and ~(k / j) √ó (j / i) = k / i~.

Hey, these two seem alarmingly similar! What gives!
Well, they‚Äôre both functors from posets to monoids ;)
Also, they are instances of ‚Äòresiduated po-monoids‚Äô.
Non-commutative monoids may have not have a general inverse operation,
but instead might have left- and right- inverse operations known as residuals
---we‚Äôll mention this word again when discussing adjunctions and are 
categorically seen as kan extensions.
Alternatively, they‚Äôre are instances of [[http://link.springer.com.libaccess.lib.mcmaster.ca/article/10.1007/s10773-004-7710-7][‚Äò(Kopka) Difference-posets‚Äô]].


For more examples of categories, we will need to reason
by extensionality --two things are ‚Äòequal‚Äô when they have
equivalent properties ... recall Leibniz and his 
[[https://en.wikipedia.org/wiki/Identity_of_indiscernibles][law of indiscernibles]] ;p

# Functors are not determined by where they send objects
# e.g., https://math.stackexchange.com/a/3026355/80406
* /The four postulates of the apocalypse/
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

** Intro :ignore:
Categories have objects and morphisms between them, functors are morphisms between categories,
and then we can go up another level and consider morphisms between functors.
These ‚Äòlevel 2 morphisms‚Äô are pretty cool, so let‚Äôs touch on them briefly.

Recall that a poset ordering is extended to (possibly non-monotone) functions $f , g$ pointwise
\[f \overset{.}{‚â§} g \quad\iff\quad (‚àÄ x ‚Ä¢\; f\, x \,‚â§\, g\, x)\]
As such, with posets as our guide, we extend the notion of ‚Äòmorphism between functors‚Äô 
to be a ‚Äòwitness‚Äô of these orderings $Œ∑ : ‚àÄ {X} ‚Üí F\, X ‚ü∂ G\, X$
--this is a dependent type, note that the second arrow notates category morphisms, whereas
the first acts as a separator from the implicit parameter $X$; sometimes one sees $Œ∑_X$
for each component/instance of such an operation.
# http://www.jmilne.org/not/Mamscd.pdf
#+BEGIN_CENTER
$\require{AMScd}$
\begin{CD}
\color{navy}{F\, A} @>\color{fuchsia}{Œ∑_A}>>      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @>>\color{fuchsia}{Œ∑_B}>      \color{teal}{G\, B}
\end{CD}
#+END_CENTER

However, then for any morphism $f : A ‚ü∂ B$ we have two ways to get from $F\, A$ to $G\, B$ via
~F f ‚®æ Œ∑ {B}~ and ~Œ∑ {A} ‚®æ G f~ and rather than choose one or the other, we request that they
are identical ---similar to the case of associativity.
#+BEGIN_SRC agda
 NatTrans : ‚àÄ {i j i‚Äô j‚Äô}  ‚¶É ùíû : Category {i} {j} ‚¶Ñ ‚¶É ùíü : Category {i‚Äô} {j‚Äô} ‚¶Ñ 
            (F G : Functor ùíû ùíü) ‚Üí Set (j‚Äô ‚äç i ‚äç j)
 NatTrans ‚¶É ùíû = ùíû ‚¶Ñ ‚¶É ùíü ‚¶Ñ F G =
   Œ£ Œ∑ ‚à∂ (‚àÄ {X : Obj ùíû} ‚Üí (obj F X) ‚ü∂ (obj G X))
       ‚Ä¢ (‚àÄ {A B} {f : A ‚ü∂ B} ‚Üí mor F f ‚®æ Œ∑ {B} ‚â° Œ∑ {A} ‚®æ mor G f)
#+END_SRC
The naturality condition is remembered by placing the target component ~Œ∑ {B}~ /after/
lifting ~f~ using the /source/ functor ~F~;
likewise placing the source component /before/ applying the target functor.

Another way to remember it:
~Œ∑ : F ‚ü∂Ãá G~ starts at ~F~ and ends at ~G~, so the naturality also starts with ~F~ and ends
with ~G~; i.e., ~F f ‚®æ Œ∑ {B} = Œ∑ {A} ‚®æ G f~ :-)

It is at this junction that aforementioned problem with our definition
of category comes to light: Function equality is extensional by definition 
and as such we cannot prove it.
Right now we have two function-like structures for which we will postulate a 
form of extensionality,
#+BEGIN_SRC agda
 -- function extensionality
 postulate extensionality : ‚àÄ {i j} {A : Set i} {B : A ‚Üí Set j} 
                              {f g : (a : A) ‚Üí B a}
                          ‚Üí (‚àÄ {a} ‚Üí f a ‚â° g a) ‚Üí f ‚â° g

 -- functor extensionality
 postulate funcext : ‚àÄ {i j k l} ‚¶É ùíû : Category {i} {j} ‚¶Ñ ‚¶É ùíü : Category {k} {l} ‚¶Ñ
                       {F G : Functor ùíû ùíü} 
                     ‚Üí (oeq : ‚àÄ {o} ‚Üí obj F o ‚â° obj G o)
                     ‚Üí (‚àÄ {X Y} {f : X ‚ü∂ Y}
                        ‚Üí mor G f  ‚â°  ‚â°-subst‚ÇÇ (Category._‚ü∂_ ùíü) oeq oeq (mor F f))
                     ‚Üí F ‚â° G

 -- graph map extensionality
 postulate graphmapext : {G H : Graph } {f g : GraphMap G H} 
                       ‚Üí (veq : ‚àÄ {v} ‚Üí ver f v ‚â° ver g v)
                       ‚Üí (‚àÄ {x y} {e : Graph._‚ü∂_ G x y} 
                          ‚Üí edge g e ‚â° ‚â°-subst‚ÇÇ (Graph._‚ü∂_ H) veq veq (edge f e))
                       ‚Üí f ‚â° g

 -- natural transformation extensionality
 postulate nattransext : ‚àÄ {i j i‚Äô j‚Äô} {ùíû : Category {i} {j} } {ùíü : Category {i‚Äô} {j‚Äô} } 
                         {F G : Functor ùíû ùíü} (Œ∑ Œ≥ : NatTrans F G)
                       ‚Üí (‚àÄ {X} ‚Üí proj‚ÇÅ Œ∑ {X} ‚â° proj‚ÇÅ Œ≥ {X})
                       ‚Üí Œ∑ ‚â° Œ≥
#+END_SRC

Natural transformations are too cool to end discussing so briefly
and so we go on to discuss their usage is mathematics later on.

** A very big ~ùíûùí∂ùìâ~

With the notions of categories, functors, and extensionality in-hand we can now discus the
notion of the category of small categories and the category of small graphs. 
Afterwards we give another example of a functor that says how every category can be 
construed as a graph.

First the category of /smaller/ categories,
#+BEGIN_QUOTE
~ùíûùí∂ùìâ~ is a category of kind ~(‚Ñìsuc m, ‚Ñìsuc m)~, where ~m = i ‚äç j~, and its objects
are categories of kind ~(i , j)~ and so it is not an object of itself.

Thank-you Russel and friends!

( You may proceed to snicker at the paradoxical and size issues encountered 
  by those who use set theory.
  ---Then again, I‚Äôve never actually learned, nor even attempted to learn, 
  any ‚Äò‚Äòformal set theory‚Äô‚Äô;
  what I do know of set theory is usually couched in the language of type theory; 
  I heart [[https://www.springer.com/gp/book/9780387941158][LADM]]!
)
#+END_QUOTE

#+BEGIN_SRC agda
 instance
  ùíûùí∂ùìâ : ‚àÄ {i j} ‚Üí Category {‚Ñìsuc (i ‚äç j)} {‚Ñìsuc (i ‚äç j)}
  ùíûùí∂ùìâ {i} {j} = record {
      Obj = Category {i} {j}
    ; _‚ü∂_ = Functor
    ; _‚®æ_ = Œª {ùíû} {ùíü} {‚Ñ∞} F G ‚Üí
        let instance
                   ùíû‚Ä≤ : Category ; ùíû‚Ä≤ = ùíû
                   ùíü‚Ä≤ : Category ; ùíü‚Ä≤ = ùíü  
                   ‚Ñ∞‚Ä≤ : Category ; ‚Ñ∞‚Ä≤ = ‚Ñ∞
        in record
        { obj  =  obj F ‚®æ obj G -- this compositon lives in ùíÆeùìâ
        ; mor  =  mor F ‚®æ mor G
        ; id   =  Œª {x} ‚Üí begin
              (mor F ‚®æ mor G) (Id ‚¶É ùíû ‚¶Ñ {A = x})
            ‚â°‚ü® "definition of function composition" ‚ü©‚Ä≤
              mor G (mor F Id)
            ‚â°‚ü® functor F preserves-identities even-under (mor G) ‚ü©
              mor G Id
            ‚â°‚ü® functor G preserves-identities ‚ü©
              Id
            ‚àé 
        ; comp = Œª {x y z f g} ‚Üí             
             begin
               (mor F ‚®æ mor G) (f ‚®æ g)
            ‚â°‚ü® "definition of function composition" ‚ü©‚Ä≤
               mor G (mor F (f ‚®æ g))
             ‚â°‚ü® functor F preserves-composition even-under mor G ‚ü©
               mor G (mor F f ‚®æ mor F g)
             ‚â°‚ü® functor G preserves-composition ‚ü©
               (mor F ‚®æ mor G) f ‚®æ (mor F ‚®æ mor G) g
             ‚àé
        }
    ; assoc    =  Œª {a b c d f g h} ‚Üí funcext ‚â°-refl ‚â°-refl
    ; Id       =  record { obj = Id ; mor = Id ; id = ‚â°-refl ; comp = ‚â°-refl }
    ; leftId   =  funcext ‚â°-refl ‚â°-refl
    ; rightId  =  funcext ‚â°-refl ‚â°-refl
    }
#+END_SRC

Some things to note,

+ First off: ~functor F preserves-composition even-under mor G~ is a real line of code!
  It consists of actual function calls and is merely an alias for
  ~‚â°-cong (mor G) (mor F)~ but it sure is far more readable than this form!

+ We could have written ~id = ‚â°-cong (mor G) (id F) ‚ü®‚â°‚â°‚ü© id G~,
  but this is not terribly clear what is going on.
  Especially since we introduced categories not too long ago,
  we choose to elaborate the detail.

  Likewise, ~comp = (‚â°-cong (mor G) (comp F)) ‚ü®‚â°‚â°‚ü© (comp G)~.

+ ~assoc~ is trivial since function composition is, by definition, associative.
  Likewise ~leftId, rightId~ hold since functional identity is, by definition, unit of function composition.

# + The definition of composition immediately gives us that ~obj , mor~ distributes over composition:
#   \[ \eqn{ùíûùí∂ùìâ $\obj$ Distributivity}{\obj\, (F ‚®æ G) \quad=\quad \obj\, F \;‚®æ\; \obj\, G}\]
#   \[ \eqn{ùíûùí∂ùìâ $\mor$ Distributivity}{\mor\, (F ‚®æ G) \quad=\quad \mor\, F \;‚®æ\; \mor\, G}\]
# 
** ~ùí¢ùìáùí∂ùìÖùíΩ~
In a nearly identical way, just ignoring the algebraic datum, we can show that
~Graph~'s with ~GraphMap~'s form a graph
#+BEGIN_EXAMPLE
  ùí¢ùìáùí∂ùìÖùíΩ : Category
  ùí¢ùìáùí∂ùìÖùíΩ = {! exercise !}
#+END_EXAMPLE

:Solution:
#+BEGIN_SRC agda
  ùí¢ùìáùí∂ùìÖùíΩ : Category
  ùí¢ùìáùí∂ùìÖùíΩ =
   record
    { Obj   = Graph ; _‚ü∂_ = GraphMap
    ; _‚®æ_   = Œª f g ‚Üí record { ver = ver f ‚®æ ver g ; edge = edge f ‚®æ edge g } -- using ~ùíÆet~
    ; assoc = ‚â°-refl  -- function composition is associtive, by definition
    ; Id    = record { ver = Id ; edge = Id } ; leftId = ‚â°-refl ; rightId = ‚â°-refl
    -- functional identity is no-op, by definition
    }
    where open GraphMap
#+END_SRC
:End:
 
** ~ùíûùí∂ùìâ~'s are ~ùí¢ùìáùí∂ùìÖùíΩ~'s
#+BEGIN_CENTER
/Forgive and forget: The ùí∞nderlying functor./
#+END_CENTER

Let‚Äôs formalise what we meant earlier when we said graphs are categories 
but ignoring the algebraic data.

Given a category, we ignore the algebraic structure to obtain a graph,
#+BEGIN_SRC agda
 ùí∞‚ÇÄ : Category ‚Üí Graph
 ùí∞‚ÇÄ ùíû = record { V = Obj ùíû ; _‚ü∂_ = Category._‚ü∂_ ùíû }
#+END_SRC

Likewise, given a functor we ‚Äòforget‚Äô the property that the map of morphisms needs to preserve all
finite compositions to obtain a graph map:
#+BEGIN_SRC agda
 ùí∞‚ÇÅ : {ùíû ùíü : Category} ‚Üí ùíû ‚ü∂ ùíü ‚Üí ùí∞‚ÇÄ ùíû ‚ü∂ ùí∞‚ÇÄ ùíü
 ùí∞‚ÇÅ F = record { ver = obj F ; edge = mor F }
#+END_SRC
This says that ~ùí∞‚ÇÅ~ turns ~ver, edge~ into ~obj , mor~
--~ùí∞‚ÇÅ ‚®æ ver  ‚â° obj~ and ~ùí∞‚ÇÅ ‚®æ edge ‚â° mor~-- reassuring us that ~ùí∞‚ÇÅ~ acts
as a bridge between the graph structures: ~ver , edge~ of graphs and
~obj , mor~ of categories.

Putting this together, we obtain a functor.
#+BEGIN_SRC agda
-- Underlying/forgetful functor: Every category is a graph
 ùí∞ : Functor ùíûùí∂ùìâ ùí¢ùìáùí∂ùìÖùíΩ
 ùí∞ = record { obj = ùí∞‚ÇÄ ; mor = ùí∞‚ÇÅ ; id = ‚â°-refl ; comp = ‚â°-refl }
#+END_SRC
We forget about the extra algebraic structure of a category and of a functor to
arrive at a graph and graph-map, clearly --~‚â°-refl~-- such ‚Äòforgetfullness‚Äô preserves identities
and composition since it does not affect them at all!

Those familiar with category theory may exclaim that just as I have mentioned
the names ‚Äòunderlying functor‚Äô and ‚Äòforgetful functor‚Äô I ought to mention
‚Äòstripping functor‚Äô as it is just as valid since it brings about connotations of
‚Äòstripping away‚Äô extra structure.
I‚Äôm assuming the latter is less popular due to its usage for
poor mathematical jokes and puns.

Before we move on, the curious might wonder if ‚Äò‚Äòcategories are graphs‚Äô‚Äô 
then what is the analgoue to ‚Äò‚Äò$X$ are hypergraphs‚Äô‚Äô,
it is [[http://arxiv.org/PS_cache/math/pdf/0305/0305049v1.pdf#page=178][multicategories]].

Now the remainder of these notes is to build-up the material
needed to realise the notion of ‚Äòfree‚Äô which is, in some sense,
/the best-possible approximate inverse/ to ‚Äòforgetful‚Äô
--however, forgetting is clearly not invertible since it can easily
confuse two categories as the same graph!

* /How natural is naturality?/
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

# commutative diagrams with MathJax
# http://www.jmilne.org/not/Mamscd.pdf

** Intro                                                            :ignore:
Recall, that a natural transformation $Œ∑ : F \natTo G$ is a family
$‚àÄ \{X \,:\, \Obj ùíû\} \,‚Üí\, F\, X ‚ü∂ G\, X$ that satisfies the naturality condition:
$‚àÄ \{A \; B\} \{f \,:\, A ‚ü∂ B\} \,‚Üí\, F f ‚®æ Œ∑ {B} \;‚â°\; Œ∑ {A} ‚®æ G f$.

  + In the type of Œ∑, note that the first /show/ arrow ‚Äò‚Üí‚Äô acts as a separator from the
    the ‚àÄ-quantified variable $X$, whereas the second /longer/ arrow ‚Äò‚ü∂‚Äô denotes the
    morphism type in the category ùíû.

  + We will freely interchange the informal mathematical rendition $(Œ∑_x : F\, X ‚Üí G\, X)_{x ‚àà \Obj ùíû}$
    with the aforementioned formal Agda forms ~‚àÄ{X : Obj ùíû} ‚Üí F X ‚Üí G ‚Üí X~ and invocation ~Œ∑ {X}~.

#+BEGIN_CENTER
$\require{AMScd}$
\begin{CD}
\color{navy}{F\, A} @>\color{fuchsia}{Œ∑_A}>>      \color{teal}{G\, A}    \\
@V\color{navy}{F\, f}VV    \!=                    @VV\color{teal}{G\, f}V \\
\color{navy}{F\, B} @>>\color{fuchsia}{Œ∑_B}>      \color{teal}{G\, B}
\end{CD}
#+END_CENTER
Let us look at this from a few different
angles; in particular, [[http://mathoverflow.net/questions/56938/what-does-the-adjective-natural-actually-mean/56956][what does the adjective ‚Äònatural‚Äô actually mean?]] 
It‚Äôs been discussed on many forums and we collect a few of the key points here.

** Identification of possible paths ---contraction of choices

Given two functors $F , G$, for any object $~x$ we obtain two objects $F\, x\, , \, G\, x$ and so a morphism
from $F$ to $G$ ought to map such $F\,x$ to $G\, x$. That is, a morphsim of functors is a family \\
$Œ∑ \,:\, ‚àÄ \{x : \Obj ùíû\} \,‚Üí\, F \,x ‚ü∂ G \,x$. Now for any $f : a ‚Üí b$ there are two ways to form a morphism
$F\, a ‚Üí G\, b$: $F f ‚®æ Œ∑ \{b\}$ and $Œ∑ \{a\} ‚®æ G\, f$. Rather than make a choice each time we want such
a morphism, we eliminate the choice all together by insisting that they are identical.
This is the naturality condition.

This is similar to when we are given three morphisms $f : a ‚Üí b , g : b ‚Üí c , h : c ‚Üí d$,
then there are two ways to form a morphism $a ‚Üí d$; namely $(f ‚®æ g) ‚®æ h$ and $f ‚®æ (g ‚®æ h)$.
Rather than make a choice each time we want such a morphism, we eliminate the choice all together
by insisting that they are identical. This is the associativity condition for categories.

Notice that if there‚Äôs no morphism $F\, x ‚ü∂ G\, x$ for some $x$, they by definition there‚Äôs no
possible natural transformation $F \natTo G$.

** No Choice --free will is only an illusion

\begin{align*}
     & \quad\text{the natural $X$}
\\ = & \quad\text{the $X$ which requires no arbitrary choices}
\\ = & \quad\text{the canonical/standard $X$}
\end{align*}

That is,
\begin{align*}
     & \quad \text{it is a natural construction/choice}
\\ = & \quad \text{distinct people would arrive at the same construction;}
\\   & \quad \text{ (no arbitrary choice or cleverness needed) }
\\ = & \quad \text{ there is actually no choice, i.e., only one possiility, }
\\   & \quad \text{ and so two people are expected to arrive at the same ‚Äòchoice‚Äô}
\end{align*}

Thus, if a construction every involves having to decide between distinct routes, then chances are
the result is not formally natural.
Sometimes this ‚Äòinution‚Äô is developed from working in a field for some time; 
sometimes it just ‚Äúfeel‚Äù" natural.
# "natural" = "resonable or expected in the ambient context" ; 

[[http://math.stackexchange.com/questions/939404/do-natural-transformations-make-god-given-precise?rq=1][Some would even say]]: /Natural = God-given/.

** COMMENT Common Properties                            :this_looks_suspect:
"natural solution" = "has properties of all other solutions"

[To consider: is a natural solution then just an initial solution? That is, an intial
transformation?]

{\sc add this to todo‚Äôs list}

** Natural means polymorphic without type inspection

#  nattrans are polyfuncs

A natural transformation can be thought of as a polymorphic function
~‚àÄ {X} ‚Üí F X ‚ü∂ G X~ /where/ we restrict ourselves to avoid inspecting any ~X~.

+ Recall that a ~mono~-morphic operation makes no use of type variables in its signature,
  whereas a ~poly~-morphic operation uses type variables in its signature.

+ For example, in C# one can ask if one type ~is~ a subclass of another thereby
  obtaining specific information, whereas there is no such mechanism in Haskell.
 
Inspecting type parameters or not leads to the distinction of ad hoc plymorphism vs. parametric
polymorphism ---the later is the kind of polymorphism employed in functional language like Haskell
and friends and so such functions are natural transformations by default!
[[http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf][Theorems for free!]]

For example,
#+BEGIN_EXAMPLE
-- Let ùí¶ x y ‚âî Id {x} for morphisms, and ùí¶ x y ‚âî x for objects.

size : ‚àÄ {X} ‚Üí List X ‚Üí ùí¶ ‚Ñï X   
size [x‚ÇÅ, ‚Ä¶, x‚Çô] = n
#+END_EXAMPLE
is a polymorphic function and so naturality follows and is easily shown --show it dear reader!
So we have always have
\[List\; f \;‚®æ\; size \quad=\quad size\]
Since ~ùí¶ ‚Ñï f = Id~, then by extensionality: ~size : List ‚ü∂Ãá ùí¶~.
:Solution:
for any ~f : A ‚ü∂ B~ we have
#+BEGIN_EXAMPLE
  (List f ‚®æ size) [x‚ÇÅ, ‚Ä¶, x‚Çô]
=
  size (List f [x‚ÇÅ, ‚Ä¶, x‚Çô])
=
  size [f x‚ÇÅ, ‚Ä¶, f x‚Çô]
=
  n
=
  Id n
=                  
  (ùí¶ ‚Ñï f) n
=  
  (ùí¶ ‚Ñï f) (size [x‚ÇÅ , ‚Ä¶, x‚Çô])
=  
  (size ‚®æ ùí¶ ‚Ñï f) [x‚ÇÅ, ‚Ä¶, x‚Çô]
#+END_EXAMPLE
Hence, ~size : List ‚ü∂Ãá ùí¶~.
:End:

On the other hand, the polymorphic function
#+BEGIN_EXAMPLE
whyme : ‚àÄ {X} ‚Üí List X ‚Üí ùí¶ Int X
whyme {X} [x‚ÇÅ,‚Ä¶,x‚Çô] = If X = ‚Ñï then 1729 else n
#+END_EXAMPLE
is not natural: The needed equation ~F f ‚®æ Œ∑ {B} = Œ∑ {A} ‚®æ G f~
for any ~f : A ‚Üí B~ breaks as witnessed by
~f = (Œª x ‚Üí 0) : ‚Ñù ‚Üí ‚Ñï~ and any list with length ~n ‚â† 1729~,
and this is easily shown --do so!
:Solution:
#+BEGIN_EXAMPLE
  (List f ‚®æ whyme) [x‚ÇÅ, ‚Ä¶, x‚Çô]
=
  whyme (List f [x‚ÇÅ, ‚Ä¶, x‚Çô])
=
  whyme [f x‚ÇÅ, ‚Ä¶, f x‚Çô]
=
  if ‚Ñï = ‚Ñï then 1729 else n
=
  1729
‚â†
  n
=  
  if ‚Ñù = ‚Ñï then 1729 else n
=
  (ùí¶ ‚Ñï f) (whyme [x‚ÇÅ, ‚Ä¶, x‚Çô])
=
  (whyme ‚®æ ùí¶ Int f) [x‚ÇÅ, ‚Ä¶, x‚Çô]
#+END_EXAMPLE
:End:

One might exclaim, /hey! this only works ‚Äôcuz you‚Äôre using Ramanujan‚Äôs taxi-cab number!/
/1729 is the smallest number expressible as a sum of 2 cubes in 2 ways:/
/$1729 = 12¬≥ + 1¬≥ = 10¬≥ + 9 ¬≥$./ I assure you that this is not the reason that naturality breaks,
and I commend you on your keen observation.

Notice that it is natural if we exclude the type inspected, ‚Ñï.
That is, if we only consider $f : A ‚Üí B$ with $A ‚â† ‚Ñï ‚â† B$.
In general, is it the case that a transformation can be made natural by excluding
the types that were inspected?

Before we move on, observe that a solution in $h$ to the absorptive-equation $F f ‚®æ h = h$
is precisely a natural transformation from $F$ to the aforementioned ‚Äòdiagonal functor‚Äô:
\[F f ‚®æ h \;=\; h \qquad‚áî\qquad ‚àÉ X : Obj \;‚Ä¢\; h ‚àà F \overset{.}{‚ü∂} ùí¶ X ~\]
#
# Recall that ‚ÜíÃá is a Œ£-type for which membership is defined as follows: 
#
# ~(x ‚àà Œ£ y ‚à∂ Y ‚Ä¢ P y) =  (Œ£ y ‚à∂ Y ‚Ä¢ y ‚â° x ‚àß P y)~.
#
# {\sc add to todo‚Äôs: formalise ~‚àà~; trickier than it looks ;) }

# since ~g ‚®æ (Œª _ ‚Üí e) = (Œª x ‚Üí (Œª _ ‚Üí e) (g x) ) = (Œª x ‚Üí e)~
In particular, due to the constant-fusion property $g \,‚®æ\, ùí¶\, e \;=\; ùí¶\, e$, we have that
\[‚àÄ \{F\} \{X\} \{e \,:\, X\} \;‚Üí\; (ùí¶\, e) \,‚àà\, F \overset{.}{‚ü∂} ùí¶\, X \]
Is the converse also true? If $h ‚àà F ‚ü∂Ãá ùí¶ X$ then $h \,=\, ùí¶\, e$ for some $e$?

** COMMENT monomorphic funcs are natural                  :possibly_harmful:

Notice that that monomorphic functions are always natural!

Given ~m : X ‚Üí Y~ we can consture this as ~m : ‚àÄ {Z} ‚Üí ùí¶ X Z ‚Üí ùí¶ Y Z~ and then we obtain
naturality: given ~f : A ‚Üí B~,
#+BEGIN_EXAMPLE
  m ‚®æ ùí¶ X f
= m ‚®æ Id
= m
= Id ‚®æ m
= ùí¶ Y f ‚®æ m
#+END_EXAMPLE

this is probably less insightful, and probably a damaging observation...

** Natural means no reference to types

The idea that a natural transformation cannot make reference to the type variable at all can be
seen by yet another example.

#+BEGIN_EXAMPLE
  data ùüô : Set where ‚òÖ : ùüô

  -- Choice function: For any type X, it yields an argument of that type.
  postulate Œµ : (X : Set) ‚Üí X

  nay : ‚àÄ {X} ‚Üí X ‚Üí X
  nay {X} _ = Œµ X
#+END_EXAMPLE

Now naturality $\Id \, f ‚®æ nay_B \;=\; nay_A ‚®æ \Id \, f$ breaks as witnessed by
$f \;=\; (Œª _ ‚Üí Œµ‚Ñï + 1) \;:\; ùüô ‚Üí ‚Ñï$ --and provided $Œµ‚Ñï ‚â† 0$, otherwise
we could use an $f$ with no fix points.

:Solution:
#+BEGIN_EXAMPLE
  Id f ‚®æ nay {‚Ñï}
=
  f ‚®æ (Œª _ ‚Üí Œµ ‚Ñï)
=
  Œª _ ‚Üí Œµ ‚Ñï
‚â†
  Œª _ ‚Üí Œµ ‚Ñï + 1
=
  Œª _ ‚Üí f (Œµ ùüô)
=
  nay {ùüô} ‚®æ Id f
#+END_EXAMPLE
:End:

From this we may hazard the following:
If we have natural transformations $Œ∑·µ¢ \,:\, ‚àÄ {X : Obj·µ¢} ‚Üí\, F X \overset{.}{‚ü∂} G X$
where the $Obj·µ¢$ partition the objects available --- i.e., $Obj \;=\; Œ£ i \,‚Ä¢\, Obj·µ¢$ ---
then the transformation $Œ∑_{(i, X)} \;=\; Œ∑·µ¢$ is generally unnatural since it clearly makes choices,
for each partition.

** Natural means uniformly and simultaneously defined

A family of morphisms is /natural in x/ precisely when it is defined
/simultaneously/ for all /x/ ---there is no inspection of some particular /x/ here and there,
no, it is uniform! With this view, the naturality condition is thought of as a ‚Äòsimultaneity‚Äô
condition. [[https://www.google.ca/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8&client=ubuntu#q=general%20theory%20of%20natural%20equivalences][Rephrasing GToNE]].

The idea of naturality as uniformly-definable is pursued by [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.2336&rep=rep1&type=pdf][Hodges and Shelah]].

** Naturality is restructure-modify commutativity

Recall that a functor can be thought of as endowing an object with structure.
Then a transformation can be thought of as a restructuring operation and naturality means
that it doesn‚Äôt matter whether we restructure or modify first, as long as we do both.

** Natural means obvious

It may help to think of /there‚Äôs a natural transformation from F to G/ to mean
/there‚Äôs an obvious/standard/canconical way to transform F structure into G structure/.

Likewise, /F is naturally isomorphic to G/ may be read /F is obviously isomorphic to G/.
For example, *TODO* seq-pair or pair-seq ;-)

Sometimes we can show ‚Äò‚ÄòF X is isomorphic to G X, if we make a choice dependent on X‚Äô‚Äô
and so the isomorphism is not obvious, since a choice must be made.

** Naturality is promotion

+ I think Richard Bird refers to the naturality condition as a promotion law where the functors
  involved are thought of as (list) constructions.

+ The nomenclature is used [[https://www.cs.ox.ac.uk/files/3378/PRG56.pdf][to express the idea than operation on a compound structure
  can be ‚Äòpromoted‚Äô into its components.]]
   # http://www.cs.ox.ac.uk/files/3390/PRG69.pdf, orginal source, is a dead link.
   
+ Reading ~F f ‚®æ Œ∑ {B} = Œ∑ {A} ‚®æ G f~ from left to right:
   Mapping $f$ over a complicated structure then handling the result
   /is the same as/
   handling the complex datum then mapping $f$ over the result.

   - `Handling' can be thought of as `processing' or as `reshaping'.
   
Lists give many examples of natural transformations by considering
[[https://link.springer.com/chapter/10.1007/3-540-51305-1_24][a categorical approach to the theory of lists.]]

** Naturality as a rewrite rule

The naturality condition can be seen as a rewrite rule that let‚Äôs us replace a complicated or
inefficient side with a simplier or more efficient yet equivalent expression.
I think I first learned this view of equations at the insistence of
[[https://www.amazon.com/Algebra-Programming-Prentice-hall-International-Computer/dp/013507245X][Richard Bird and Oege de Moor]] 
--whose text can be found [[http://themattchan.com/docs/algprog.pdf][here]], albeit the legitimacy of the link may be suspect.

For example, recall the ùí¶onstant functor now construed only as a polymorphic binary operation:
#+BEGIN_EXAMPLE
_‚ü™_    :  ‚àÄ{A B : Set} ‚Üí A ‚Üí B ‚Üí A
a ‚ü™ b  =  a
#+END_EXAMPLE

The above is a constant time operation, whereas the next two are linear time operations; i.e.,
they take ~n~ steps to compute, where ~n~ is the length of the given list.

#+BEGIN_EXAMPLE
-- This' map for List's; i.e., the mor of the List functor 
map    : ‚àÄ {A B : Set} (f : A ‚Üí B) ‚Üí List A ‚Üí List B
map f []         =  []
map f (x ‚à∑ xs)  =  f x ‚à∑ map f xs

-- Interpret syntax `x‚ÇÄ‚à∑‚ãØ‚à∑x‚Çô‚Çã‚ÇÅ` semantically as `x‚ÇÄ ‚äï ‚ãØ ‚äï x‚Çô‚Çã‚ÇÅ`, where ‚äï = cons.
fold  : ‚àÄ {A B : Set} (cons : A ‚Üí B ‚Üí B) (nil : B) ‚Üí List A ‚Üí B
fold cons nil [] = nil
fold cons nil (x ‚à∑ xs) = cons x (fold cons nil xs)
#+END_EXAMPLE

By /Theorems for Free/, or a simple proof, we have that ~fold~ is a natural
transformation $List \overset{.}{‚Üí} \Id$:
\[ List\; f \;‚®æ\; fold \; cons_B \; nil_B \qquad=\qquad fold \; cons_A \; nil_A \;‚®æ\; f \]
Note that here we are ranging over objects $X$ equipped with $nil_X : X, \; cons_X : X ‚Üí X ‚Üí X$;
as such the equation is not valid when this is not the case.

Now we map compute,
#+BEGIN_EXAMPLE
postulate A B : Set
postulate nil-B : B
postulate f : A ‚Üí B -- possibly expensive operation

head  :  List B ‚Üí B
head  =  fold _‚ü™_ nil-B

compute  :  List A ‚Üí B
compute  =  map f  ‚®æ  head
#+END_EXAMPLE

That is,
#+BEGIN_EXAMPLE
  compute [x‚ÇÄ, ‚Ä¶, x‚Çô‚Çã‚ÇÅ]
= head (map f [x‚ÇÄ, ‚Ä¶, x‚Çô‚Çã‚ÇÅ])
= head [f x‚ÇÄ, ‚Ä¶, f x‚Çô‚Çã‚ÇÅ]
= f x‚ÇÄ  ‚ü™  f x‚ÇÅ ‚ü™ ‚ãØ ‚ü™ ‚ãØ f x‚Çô‚Çã‚ÇÅ ‚ü™ nil-B 
= f x‚ÇÄ
#+END_EXAMPLE

However this approach performs the potentially expensive operation $f$ a total of 
$n = \text{‚Äúlength of input‚Äù}$ times! In spite of that, it only needs the first element of
the list and performs the operation only once! Indeed, by the naturality of ~fold~ we have
an equivalent, and more efficient, formulation:
#+BEGIN_EXAMPLE
compute  =  head  ‚®æ  f
#+END_EXAMPLE

This operation only performs the potentially costly ~f~ once!

A more concrete and realistic example is to produce an efficient version of the function
that produces the ~average xs = div (sum xs, length xs)~ of a list of numbers: This operation
traverses the input list twice, yet we can keep track of the length as we sum-along the list
to obtain an implementation that traverses the list only once!

[[https://scss.tcd.ie/publications/tech-reports/reports.99/TCD-CS-1999-74.pdf][Indeed]],
#+BEGIN_EXAMPLE
div : ‚Ñï √ó ‚Ñï ‚Üí ‚Ñï
div (0, 0) = 0
div (m, n) = m √∑ n

average     :  List ‚Ñï ‚Üí ‚Ñï
average xs  =  div (fold _‚äï_ ùüò xs)  
  where  ùüò = (0 , 0) 
         _‚äï_  : ‚Ñï ‚Üí (‚Ñï √ó ‚Ñï) ‚Üí ‚Ñï
         a ‚äï (b , n) = (a + b , n + 1)
#+END_EXAMPLE

** Naturality is just model morphism

Given two functors $F , G : ùíû ‚ü∂ ùíü$ let us construe them as only graph homomorphisms.
Then each is a model of the graph $ùí∞‚ÇÄ \; ùíû$ ---each intereprets the nodes and edges of ~ùí∞‚ÇÄ ùíû~ as
actual objects and morphisms of ùíü--- and a natrual transformation is then nothing
more than a morphism of models.

# {\sc was the notion of model morphisms mentioned earlier when
# models were introduced?}

** Naturality yields pattern matching

In the setting of types and functions, ~Œ∑ : F ‚ü∂Ãá G~ means we have ~Œ∑ (F f x) = G f (Œ∑ x)~
which when read left-to-right says that ~Œ∑~ is defined by pattern-matching on its argument
to obtain something of the form ~F f x~ then it is defined recursively by examining ~x~ and then
applying ~G f~ to the result ---of course there‚Äôs some base case ~F~ definitions as well.

Alternatively, the input to ~Œ∑~ is of the form ~F ‚Ä¶~ and its
output is of the form ~G ‚Ä¶~ --mind blown!

# Hence, in a pointwise setting, to /define/ a natural transformation Œ∑
# we need to define it at components of the input shape $Œ∑_{F \, f \, x}$
# to have the output shape $G \, f \, Œ∑_{x}$.

For example, I want to define a transformation $\mathsf{List} ‚ü∂Ãá \mathsf{List}$.
0. So let me suppose the input is of the shape $\List \, f\, x$, more concretely
   it is of the shape 
   \\ ~[f x‚ÇÄ, f x‚ÇÅ, ‚Ä¶, f x‚Çô‚Çã‚ÇÅ]~ --for arbitrary $f : A ‚Üí B$.
1. Then the output shape must be $\List \, f\, (Œ∑ \, x)$, more concretely
   it is of the shape \\ ~[f y‚ÇÄ, f y‚ÇÅ, ‚Ä¶, f y‚Çò‚Çã‚ÇÅ]~ where $y \,=\, Œ∑\,x$.
2. So my /only/ choices are $y : \List A$ and $m : ‚Ñï$

   Here are some possibilities and the resulting Œ∑:
   + $y, m = x, n$ :: Identity function
   + $y, m = x, 0$ :: Constantly empty list ~[]~ function
   + $y, m = x, 1$ :: The first element, ‚Äòhead‚Äô, function
   + $y, m = x, k$ :: The first $k < n$ elements function
   + $m = n$ with $y·µ¢ = x‚Çô‚Çã·µ¢$ :: List reversal function
   + $y, m = \mathsf{reverse}(x), k$ :: The last $k < n$ elements, in reverse, function
        - Here we applied an already known natural transformation
          and indeed the composition of naturally transformation is itself natural.

** Examples

+ Pointwise Monotonicity ::

   A functor among poset categories is an order-preserving function and a natural transformation
   $f \natTo g$ is a proof that $f \overset{.}{‚â§} g$ pointwise: $‚àÄ x \,‚Ä¢\, f\, x \;‚â§\; g\, x$ 
   ---all the other pieces for a natural
   transformation are automatic from the definition of begin a poset category.
   
+ conjugation ::
  
  A functor among monoids --construed as categories-- is just a monoid homomorphism:
  \begin{align*}
             & (M, ‚äï, e) ‚ü∂ (N, ‚äó, d) 
  \\ ‚âÖ \quad & Œ£ h ‚à∂ M ‚Üí N ‚Ä¢ ‚àÄ \{x \, y \} ‚Ä¢\; h(x ‚äï y) = h x ‚äó h y \lands h e = d
  \end{align*}
  A natural transformation ~(f, prf) ‚ü∂ (g, prf‚Äô)~ is a point $n : N$ with
  $‚àÄ x ‚à∂ M \;‚Ä¢\; f x ‚äó n \,=\, n ‚äó g x$, a so-called ‚Äòconjugation‚Äô by $n$ that takes $f$ to $g$.
  :Solution:
    Œ∑ ‚àà (f , prf) ‚ü∂ (g , prf‚Äô)
  =                               { defn of natural transformation }
    Œ∑ ‚àà ‚àÄ {x} ‚Üí f x ‚ü∂ g x in M
    with ‚àÄ m ‚Ä¢ f m ‚®æ Œ∑ = Œ∑ ‚®æ g m
  =                               { arrows in monoid categories }
    Œ∑ ‚àà N with ‚àÄ x ‚à∂ M ‚Ä¢ f x ‚®æ Œ∑ = Œ∑ ‚®æ g x
  =                               { composition in monoid categories }
    Œ∑ ‚àà N with ‚àÄ x ‚à∂ M ‚Ä¢ f x ‚äó Œ∑ = Œ∑ ‚äó g x
  :End:
    
+ fold ::
    
    Recall from the introduction $ùí∞(S, ‚äï, e) \;=\; S$ was the underlying functor from monoids to sets.

    Let $ùí∞ √ó ùí∞$ be the functor that for objects $M \;‚Ü¶\; ùí∞\, M \,√ó\, ùí∞\, M$ and for morphisms
    $h \;‚Ü¶\; Œª (x,y) ‚Üí (h\, x, h\, y)$. Then the monoid multiplication (of each monoid) is a natural
    transformation $ùí∞ √ó ùí∞ \natTo ùí∞$, where naturality says that for any monoid homomorphism $h$, the
    application of $ùí∞\, h$ to the (monoid) multiplication of two elements is the same as the
    (monoid) multiplication of the $ùí∞\, h$ images of the two elements, 
    and this is evident from the homomorphism condition.
    
    Extending to finite products, $‚Ñí \;‚âî\; (Œ£ n ‚à∂ ‚Ñï ‚Ä¢ ‚àè i ‚à∂ 1..n ‚Ä¢ ùí∞)$, the natural transformation
    $‚Ñí \natTo ùí∞$ is usually called /fold, reduce, or cata/ and ~‚Ñí~ is known as the
    /free monoid functor/ with notations $A* \;=\; \List A \;=\; ‚Ñí\, A$.
    
    Loosely put,
    #+BEGIN_EXAMPLE
    ‚Ñí‚ÇÄ    :  Monoid ‚Üí Set
    ‚Ñí‚ÇÄ M  =  Œ£ n ‚à∂ ‚Ñï ‚Ä¢ ‚àè i : 1..n ‚Ä¢ ùí∞ M   -- finite sequences of elements from M
    
    ‚Ñí‚ÇÅ : ‚àÄ {M N : Monoid} ‚Üí (M ‚ü∂ N) ‚Üí ‚Ñí‚ÇÄ M ‚Üí ‚Ñí‚ÇÄ N
    ‚Ñí‚ÇÅ (h , prf) = Œª (n , x‚ÇÅ, ‚Ä¶, x‚Çô) ‚Üí (n , h x‚ÇÅ , ‚Ä¶ , h x‚Çô)
    
    fold : ‚àÄ {M : Monoid} ‚Üí ‚Ñí‚ÇÄ M ‚Üí ùí∞‚ÇÄ M
    fold {(M, ‚äï, e)} = Œª (n , x‚ÇÅ, ‚Ä¶, x‚Çô) ‚Üí x‚ÇÅ ‚äï ‚ãØ ‚äï x‚Çô
#+END_EXAMPLE
    
    --The reader would pause to consider implementing this formally using Agda's ~Data.Fin~ and ~Data.Vec~ ;-)--

    Now for any monoid homomorphism ~h~, applying induction, yields
    #+BEGIN_EXAMPLE
    h‚ÇÄ(x‚ÇÅ ‚äï ‚ãØ ‚äï x‚Çô)  =  h‚ÇÄ x‚ÇÅ ‚äï ‚ãØ ‚äï h‚ÇÄ x‚Çô  where  h‚ÇÄ = ùí∞ (h‚ÇÄ, prf) = ùí∞ h
#+END_EXAMPLE
    Which is easily seen to be just naturality -- if we use backwards composition $f ‚®æ g \;=\; g ‚àò f$ --
    #+BEGIN_EXAMPLE
    ùí∞ h ‚àò fold {M}  =  fold {N} ‚àò ‚Ñí h
#+END_EXAMPLE    
    Woah!
    
+ Every operation in any multisorted algebraic structure gives a natural transformation ::

   This is mentioned in the [[http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf][Barr and Wells' /Category Theory for Computing Science/ text]], citing
   Linton, 1969a-b.
    
   For example, ~src, tgt~ ---from the graph signature--- give natural transformations
   $V \natTo E$ from the vertex functor to the edge functor ... keep reading ;)
   
+ Representability ::
   
   Recall that $V(G)$ is essentially $‚Ñô‚ÇÄ ‚ü∂ G$ where
   $‚Ñô‚Çô$ is the graph of $n$ edges on $n+1$ vertices named $0..n$ with typing $i \,:\, i-1 ‚ü∂ i$,
   which I like to call /the path graph of length n/; and in particular $‚Ñô‚ÇÄ$ is the graph of
   just one dot, called 0, and no edges. ---Earlier I used the notation ~[n]~, but I‚Äôm using $‚Ñô$ since
   I like the view point of ‚Ñôaths.
   
   What does it mean to say that /V(G) is essentially ‚Ñô‚ÇÄ ‚ü∂ G/?

   It means that the vertices functor 
   -- $ùí± \;:\; ùí¢ùìáùí∂ùìÖùíΩ ‚ü∂ ùíÆ‚ÑØùìâ$ that takes objects $G ‚Ü¶ V(G)$ and morphisms $h ‚Ü¶ \mathsf{ver}\, h$ -- 
   can be ‚Äòrepresented‚Äô as the Hom functor $(‚Ñô‚ÇÄ ‚ü∂ \_{})$, that is to say
   \[ùí± \quad‚âÖ\quad (‚Ñô‚ÇÄ ‚ü∂ \_{}) \;\mathsf{within \; Func} \; ùí¢ùìáùí∂ùìÖùíΩ \; ùíÆ‚ÑØùìâ\] 
   --~Func~-tor categories will be defined in the next section!--

   Notice that we arrived at this expression by
   ‚Äòeta-reducing‚Äô the phrase /V(G) is essentially ‚Ñô‚ÇÄ ‚ü∂ G/! ;)
   
   More generally, we have the functor $‚Ñô‚Çô ‚ü∂ \_{}$ which yields all paths of length $n$
   for a given graph.
   
   Observe --i.e., show-- that we also have an edges functor.
   :Solution:
   Recall the ‚Äòuntyped edges‚Äô, or arrows, ~A(G) ‚âî Œ£ x ‚à∂ V(G) ‚Ä¢ Œ£ y ‚à∂ V(G) ‚Ä¢ (x ‚ü∂ y)~,
   then (arrows) ~ùíú : Graph ‚ü∂ Set~ takes objects ~G ‚Ü¶ A(G)~ and morphisms
   ~h ‚Ü¶ Œª (x,y,e) ‚Üí (ver h x, ver h y, edge h e)~.
   :End:
* /Functor Categories/
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

** Intro :ignore:
With a notion of morphisms between functors, one is led inexorably to ask
whether functors as objects and natural transformations as morphisms constitute
a category?
They do!
However, we leave their definition to the reader ---as usual, if the reader is ever so desperate
for solutions, they can be found as comments in the unruliness that is the source file.
#+BEGIN_EXAMPLE
 instance
  Func       :  ‚àÄ {i j i‚Äô j‚Äô} (ùíû : Category {i} {j}) (ùíü : Category {i‚Äô} {j‚Äô}) ‚Üí Category _
  Func ùíû ùíü  =  {! exercise !}
#+END_EXAMPLE

+ A hint: The identity natural transformation is the obvious way to get from $F\, X$ to $F\, X$,
  for any $X$ given $F$ ---well the only way to do so, without assuming anything else about the
  functor $F$, is simply $\Id_{F X}$. This is the ‚Äònatural‚Äô choice, any other choice would be
  ‚Äòunnatural‚Äô as it would require some ‚Äòcleverness‚Äô. 

+ Another hint: The obvious way to define $Œ∑ ‚®æ Œ≥$ to get $F\, X ‚ü∂ H\, X$ from 
  $F\, X ‚ü∂ G\, X ‚ü∂ H\, X$ is composition of morphisms in the category!
  That is, pointwise composition. Nothing ‚Äòclever‚Äô, just using the obvious candidates!

:Solution:
#+BEGIN_SRC agda
 instance
  Func : ‚àÄ {i j i‚Äô j‚Äô} (ùíû : Category {i} {j}) (ùíü : Category {i‚Äô} {j‚Äô}) ‚Üí Category {‚Ñìsuc (i ‚äç j ‚äç i‚Äô ‚äç j‚Äô)} {j‚Äô ‚äç i ‚äç j}
  Func {i} {j} {i‚Äô} {j‚Äô} ùíû ùíü = record {
      Obj = Functor ùíû ùíü
    ; _‚ü∂_ = NatTrans
    ; _‚®æ_ = Œª {A B C} Œ∑ Œ≥ ‚Üí comp {A} {B} {C} Œ∑ Œ≥
    ; assoc = Œª {F G H K Œ∑ Œ≥ œâ} ‚Üí nattransext {i} {j} {i‚Äô} {j‚Äô} {ùíû} {ùíü} {F} {K} (comp {F} {H} {K} (comp {F} {G} {H} Œ∑ Œ≥) œâ) (comp {F} {G} {K} Œ∑ (comp {G} {H} {K} Œ≥ œâ)) assoc
    ; Id = Œª {F} ‚Üí iden F
    ; leftId = Œª {F G Œ∑} ‚Üí nattransext {i} {j} {i‚Äô} {j‚Äô} {ùíû} {ùíü} {F} {G} (comp {F} {F} {G} (iden F) Œ∑) Œ∑ leftId
    ; rightId = Œª {F G Œ∑} ‚Üí nattransext {i} {j} {i‚Äô} {j‚Äô} {ùíû} {ùíü} {F} {G} (comp {F} {G} {G} Œ∑ (iden G)) Œ∑ rightId
    }
    where
      instance
        ùíü‚Ä≤ : Category
        ùíü‚Ä≤ = ùíü

      iden : (A : Functor ùíû ùíü) ‚Üí NatTrans A A
      iden A = Id , (rightId ‚ü®‚â°‚â°‚ü© ‚â°-sym leftId)

      -- To avoid long wait times, we avoid instance resolution by
      -- making an alias.
      _‚®æ‚Ä≤_ = Category._‚®æ_ ùíü
      infixr 6 _‚®æ‚Ä≤_

      comp : {A B C : Functor ùíû ùíü} ‚Üí NatTrans A B ‚Üí NatTrans B C ‚Üí NatTrans A C
      comp {F} {G} {H} (Œ∑ , nat) (Œ≥ , nat‚Ä≤) = (Œª {X} ‚Üí Œ∑ {X} ‚®æ‚Ä≤ Œ≥ {X}) , (Œª {A B f} ‚Üí begin
           mor F f ‚®æ‚Ä≤ Œ∑ {B} ‚®æ‚Ä≤ Œ≥ {B}
          ‚â°‚ü® ‚â°-sym assoc ‚ü®‚â°‚â°‚ü© (‚â°-cong‚ÇÇ _‚®æ‚Ä≤_ nat ‚â°-refl ‚ü®‚â°‚â°‚ü© assoc) ‚ü©
            Œ∑ {A} ‚®æ‚Ä≤ mor G f ‚®æ‚Ä≤ Œ≥ {B}
          ‚â°‚ü® ‚â°-cong‚ÇÇ _‚®æ‚Ä≤_ ‚â°-refl nat‚Ä≤ ‚ü®‚â°‚â°‚ü© ‚â°-sym assoc ‚ü©
            (Œ∑ {A} ‚®æ‚Ä≤ Œ≥ {A}) ‚®æ‚Ä≤ mor H f
          ‚àé)
#+END_SRC          
:End:

This is a good exercise as it will show you that there is an identity functor and that composition of functors
is again a functor. Consequently, functors are in abundance: Given any two, we can form [possibly] new ones by composition.

# https://math.stackexchange.com/questions/627676/equivalence-of-categories-and-of-their-functor-categories

It is a common construction that when a type $Y$ is endowed with some structure, then we can endow
the function space $X ‚Üí Y$, where $X$ is any type, with the same structure and we do so
‚Äòpointwise‚Äô. This idea is formalised by functor categories.
Alternatively, one can say we have ‚Äòcategorified‚Äô the idea; where
/categorification/ is the process of replacing types and functions with categories and
functors and possibly adding some coherence laws.

There are people who like to make a show about how ‚Äòbig‚Äô ùíûùí∂ùìâ or ~Func ùíû ùìì~ are;
these people adhere to something called ‚Äòset theory‚Äô which is essentialy type theory but
ignoring types, loosely put they work only with the datatype
#+BEGIN_EXAMPLE
data SET : Set where
  Elem : ‚àÄ {A : Set} ‚Üí A ‚Üí SET
#+END_EXAMPLE
Such heathens delegate types-of-types into ‚Äòclasses‚Äô of ‚Äòsmall‚Äô and ‚Äòbig‚Äô sets and it‚Äôs not
uniform enough for me.
Anyhow, such people would say that functor categories ‚Äò‚Äòcannot be constructed (as sets)‚Äô‚Äô unless
one of the categories involved is ‚Äò‚Äòsmall‚Äô‚Äô. Such shenanigans is ignored due to the hierarchy of
types we are using :-)

We must admit that at times the usage of a single type, a ‚Äòuni-typed theory‚Äô if you will can be
used when one wants to relise types in an extrinsic fashion rather than think of data as
intrinsically typed --E.g., graphs with ~src, tgt~ /then/ deriving a notion of ‚Äòtype‚Äô with ~_‚ü∂_~.
Everything has its place ... nonetheless, I prefer (multi)typed settings!

** Examples

*** All Categories are Functor Categories
Let ~ùüô ‚âî [ ‚Ä¢ ]~ be the discrete category of one object (and only the identity arrow on it).

Then ~ùíû ‚âÖ Func ùüô ùíû~.

*** Powers of Categories are Functor Categories
Let ~ùüö‚ÇÄ ‚âî [‚Ä¢ ‚Ä¢]~ be the discrete category of two objects.
  Then the /ùíû-squared/ category can be defined ~ùíû ‚äó ùíû ‚à∂‚âÖ Func ùüö‚ÇÄ ùíû~:
  This category essentially consists of pairs of ùíû-objects with pairs of ùíû-arrows
  between them.

  The subscript 0 is commonly used for matters associated with objects and
  the name ~ùüö‚ÇÄ~ is suggestive of the category of 2 objects only.
  
  More generally, if ùí© is the discrete category of $n$ objects, then
  the /n/-fold product category is defined by
  ~(‚àè i ‚à∂ 1..n ‚Ä¢ ùíû) ‚à∂‚âÖ Func ùí© ùíû~.

These are also commonly denoted $ùíû^2$ and $ùíû^ùí©$ since they are essentially
products, and more generally ~Func ùí≥ ùí¥~ is also denoted ùí¥^ùí≥ and referred.
 
*** Arrow Categories
We can add an arrow to ~ùüö‚ÇÄ~ to obtain another category...
  
Let ~ùüö ‚âî ‚Ä¢ ‚ü∂ ‚Ä¢~ be the category of two objects, call them 0 and 1, with one arrow between them.
  Then a functor ~ùüö ‚ü∂ ùíû~ is precisely a morphism of ùíû and a natural transformation
~f ‚ü∂ g~ boils down to just a pair of morphisms ~(h,k)~ with ~h ‚®æ g = f ‚®æ k~.

Hence, the /arrow category of ùíû/ is $ùíû^ùüö \;‚âÖ\; ùíû^‚Üí \;‚âÖ\; \mathsf{Func}\, ùüö ùíû$;
which is essentially the category with objects being ùíû-morphisms and morphisms being /commutative squares/.
  
Notice that a functor can be used to 
+ /select/ two arbitrary ùíû objects --if it's source is ùüö‚ÇÄ
+ /select/ two arbitrary ùíû objects with a ùíû arrow between them --if it's source is ùüö
+ /select/ an arbitrary ùíû arrow --if it's source is ùüö

Likewise, a natural transformation can be used to /select/ a commutative diagram.

*** Understand ùíû by looking at Functor Categories
It is a common heuristic that when one suspects the /possibility/ of a category ~ùíû~, then one
can make /probes/ to discover its structure. The objects are just functors ~ùüô ‚ü∂ ùíû~ and the
morphisms are just functors ~ùüö ‚ü∂ ùíû~.

*** Presheaves -- delegating work to ùíÆ‚ÑØùìâ
  
The /category of presheaves of ùíû/ is the category ~PSh ùíû ‚âî Func (ùíû ·µí·µñ) ùíÆeùìâ~.
  
This is a pretty awesome category since it allows nearly all constructions in ùíÆ‚ÑØùìâ to be
realised! Such as subsets, truth values, and even powersets! All these extra goodies make it
a ‚Äòtopos‚Äô aka ‚Äòpower allegory‚Äô ---the first is a category that has all finite limits and
a notion of powerset while the second, besides the power part, looks like a totally different beast;
the exhilaration!
  
*** Slice Categories
The /slice category of ùíû over B : Obj ùíû/ is the category ~ùíû / B ‚âî Œ£ F ‚à∂ Func ùüö ùíû ‚Ä¢ (F 1 = B)~. 

Essentially it is the category of objects being ùíû-morphisms with target $B$ 
and morphisms $f ‚ü∂ g$ being $(h,k)$ with $h ‚®æ g = f ‚®æ k$ but a natural choice for
$k : B ‚ü∂ B$ is $\Id_B$ and so we can use morphism type
$(f ‚ü∂‚Äô g) \;‚âî\; Œ£ h : \src f ‚ü∂ \src g \;‚Ä¢\; h ‚®æ g = f$.

This is seen by the observation \[(h, k) \;‚àà\; f ‚ü∂ g \qquad‚áî\qquad h \;‚àà\; (f ‚®æ k) ‚ü∂‚Äô g\] 
Of course a formal justification is obtained by showing
\[\_{}‚ü∂\_{} \quad‚âÖ\quad \_{}‚ü∂‚Äô\_{} \quad \mathsf{within \; Func }\; (ùíû ·µí·µñ ‚äó ùíû) ùíÆeùìâ \]
...which I have not done and so may be spouting gibberish!
   
:Solution:
    The isomorphism is witnessed as follows.
    
    To :: ~(h,k) : f ‚ü∂ g ‚áí h : (f ‚®æ k) ‚ü∂‚Äô g~,
    
    from :: ~h : f ‚ü∂‚Äô g ‚áí (h, Id) : f ‚ü∂ g~.
    
    Rid ::
    #+BEGIN_EXAMPLE
        (h , k) : f ‚ü∂ g
    ‚áí  h : f ‚®æ k ‚ü∂‚Äô g
    ‚áí (h, Id) : f ‚®æ k ‚ü∂ g
    ‚â° (h , k) : f ‚ü∂ g
    #+END_EXAMPLE
    where the equivalence is just
   ~(h,k) ‚àà f ‚ü∂ g ‚áî (h , Id) ‚àà (f ‚®æ k) ‚ü∂ g~.
    
    Lid ::
    #+BEGIN_EXAMPLE
       h : f ‚ü∂‚Äô g
    ‚áí (h, Id) : f ‚ü∂ g
    ‚áí h : f ‚®æ Id ‚ü∂‚Äô g
    ‚â° h : f ‚ü∂‚Äô g
    #+END_EXAMPLE
    
    Of course none of this is formal(ly in Agda) and so should be taken with great precaution!
    ---since it may be all wrong!
:End:
    
Just as the type ~Œ£ x ‚à∂ X ‚Ä¢ P x~ can be included in the type ~X~, by forgetting the second
component, so too the category ~Œ£ F ‚à∂ ùüö ‚ü∂ ùíû ‚Ä¢ F 1 ‚âà B~ can be included into the category
ùíû and we say it is a /subcategory/ of ùíû.
    
The notation ~Œ£ o ‚à∂ Obj ùíû ‚Ä¢ P o~ defines the subcategory of ùíû obtained by deleting
all objects not satisfying predicate ~P~ and deleting all morphisms incident to such objects; i.e.,
it is the category ùíü with
\[ \Obj ùíü \quad‚â°\quad Œ£ o ‚à∂ \Obj ùíû \,‚Ä¢\, P o    
   \qquad\text{ and }\qquad
   (o , prf) ‚ü∂_ùíü (o' , prf') \quad‚â°\quad o ‚ü∂_ùíû o'
\]
This is the largest/best/universal subcategory of ùíû whose objects satisfy $P$.
\\ Formalise this via a universal property ;)

*** Slices of ~ùíÆeùìâ~ are Functor Categories

# fibres
\[ \Func \; S \; ùíÆeùìâ  \qquad‚âÖ\qquad  ùíÆeùìâ / S \]
Where S in the left is construed as a discrete category and in the right
is construed as an object of ùíÆeùìâ.
    
This is because a functor from a discrete category need only be a function of objects since
there are no non-identity morphisms. That is, a functor $f : S ‚ü∂ ùíÆ‚ÑØùìâ$ 
is determined by giving a set $f\,s$ for each element $s ‚àà S$ ---since there are no non-identity morphisms.
Indeed a functor $f : S ‚ü∂ Set$ yields an /S/-targeted
function
\[ (Œ£ s ‚à∂ S \,‚Ä¢\, f\, s) ‚Üí S  \quad:\quad Œª (s , fs) ‚Üí s \]
Conversely a function $g : X ‚Üí S$ yields a functor by sending elements to their pre-image sets:
\[ S ‚ü∂ Set \quad:\quad Œª s ‚Üí (Œ£ x ‚à∂ X \,‚Ä¢\, g\, x ‚â° s)\]
    
Because of this example, ~ùíû / B~ can be thought of as ‚Äòùíû-objects indexed by B‚Äô
--extending this idea further leads to /fibred categories/.

*** Natural transformations as functor categories
   
In a similar spirit, we can identify natural transformations as functors!
\[\Func \, ùíû \, (ùíü ^ ùüö) \qquad‚âÖ\qquad (Œ£ F , G ‚à∂ ùíû ‚ü∂ ùíü \;‚Ä¢\; \mathsf{NatTrans}\, F\, G)\]
   
A functor $N : ùíû ‚ü∂ ùíü ^ ùüö$ gives, for each object $C : \Obj ùíû$ an object in $ùíü ^ ùüö$ which
is precisely an arrow in $ùíü$, rewrite it as $N_C : F\,C ‚ü∂ G\,C$ where $F\,C \,‚âî\, N\, C\, 0$
and $G\, C \,‚âî\, N\, C\, 1$.

Likewise, for each arrow $f : A ‚ü∂ B$ in ùíû we obtain an arrow $N\, f \,:\, N\, A ‚ü∂ N\, B$ 
in $ùíü ^ ùüö$ which is precisely a commutative square in ùíü;
that is, a pair of ùíü-arrows $(F\,f , G\,f) ‚âî N\,f$ 
with $N_A ‚®æ G\,f \;=\; F\,f ‚®æ N_B$.

Notice that we have implicitly defined two functors $F, G : ùíû ‚ü∂ ùíü$.
Their object and morphism mappings are clear, but what about functoriality? 
We prove it for both $F, G$ together.
   
# \begin{multicols}{2}

_Identity:_
\begin{calc}   
     (F \,\Id \, , \, G\, \Id)
\step{ definition of $F$ and $G$ }
     N \, \Id
\step{ $N$ is a functor }
     \Id \,‚à∂\, ùíü ^ ùüö
\step{ identity in arrow categories }
     (\Id , \Id)
\end{calc}
#   \columnbreak
_Composition:_
\begin{calc}   
     ( F (f ‚®æ g) , G (f ‚®æ g) )
   \step{ definition of $F$ and $G$ }
     N\, (f ‚®æ g)
   \step{ $N$ is a functor }
     N\, f  ‚®æ  N\, g
   \step{ definition of $F$ and $G$ }
     (F\, f, G\, f) ‚®æ (F\,g , G\,g)
   \step{ composition in arrow categories }
     (F\,f ‚®æ F\,g , G\,f ‚®æ G\,g)
\end{calc}
  # \end{multicols}
   
Sweet!
   
Conversely, given a natural transformation $Œ∑ : F \overset{.}{‚ü∂} G$
we define a functor $N : ùíû ‚ü∂ ùíü ^ ùüö$ by sending objects $C$ to $Œ∑_C : F\, C ‚ü∂ G\, C$, 
which is an object is $ùíü ^ ùüö$, and sending morphisms $f : A ‚ü∂ B$ to pairs $(G f , F f)$, 
which is a morphism in $ùíü ^ ùüö$ due to naturality of Œ∑; namely
$Œ∑_A ‚®æ G\, f \;=\; F\, f ‚®æ Œ∑_B$. 
It remains to show that $N$ preserves identities and composition --Exercise!
   
Now it remains to show that these two processes are inverses 
and the isomorphism claim is complete. Woah!
   
Similarly, to show
\[ \Func\, (ùüö ‚äó ùíû) \, ùíü \qquad‚âÖ\qquad (Œ£ F‚ÇÄ , F‚ÇÅ ‚à∂ ùíû ‚ü∂ ùíü ‚Ä¢ \mathsf{NatTrans}\, F‚ÇÅ \, F‚ÇÇ)\] 
# It suffices to show that ‚Äò‚Äòthe universal property of exponentiation‚Äô‚Äô
# ~ùí≥ ‚ü∂ (ùíµ ^ ùí¥) ‚âÖ (ùí≥ ‚äó ùí¥ ‚ü∂ ùíµ~, or more
#   directly: to/from direction obtained 
By setting $H\, i \;=\; F·µ¢$ on objects and likewise for morphisms
but with $H(\Id, 1) \;=\; Œ∑$ where $1 : 0 ‚ü∂ 1$ is the non-identity arrow of ~ùüö~.
   
(Spoilers! Alternatively: ~Arr (Func ùíû ùíü) ‚âÖ ùüö ‚ü∂ ùíû ^ ùíü ‚âÖ ùíû √ó ùüö ‚ü∂ ùíü~ since ~ùíûùí∂ùìâ~ has exponentials,
   and so the objects are isomorphic; i.e., natural transformations correspond to functors ~ùíû√óùüö‚ü∂ùíü~)
   
   Why are we mentioning this alternative statement? Trivia knowledge of-course!

   On a less relevant note, if you‚Äôre familiar with the theory of stretching-without-tearing,
   formally known as topology which is pretty awesome, then you might‚Äôve heard of paths and
   deformations of paths are known as homotopies which are just continuous functions
   $H : X √ó I ‚ü∂ Y$ for topological spaces $X, Y,$ and $I \,=\, [0,1]$ being the unit interval in ‚Ñù.
   Letting $ùí• = ùüö$ be the ‚Äòcategorical interval‚Äô we have that functors $ùíû √ó ùí• ‚ü∂ ùíü$
   are, by the trivia-relevant result, the same as natural transformations.
   That is, /natural transformations extend the notion of homotopies, or path-deformations./
   
On [[http://mathoverflow.net/a/75686/42716][mathoverflow]], the above is recast succinctly as:
   A natural transformation from $F$ to $G$ is a functor, 
   targeting an arrow category, whose ‚Äòsource‚Äô
   is $F$ and whose ‚Äòtarget‚Äô is $G$.
   \[
       \hspace{-2em} F \overset{.}{‚ü∂} G : ùíû ‚ü∂ ùíü \qquad‚âÖ\qquad 
       Œ£ Œ∑ ‚à∂ ùíû ‚ü∂ \mathsf{Arr}\, ùíü ‚Ä¢\; \mathsf{Src} ‚àò Œ∑ = F \;\;‚àß\;\; \mathsf{Tgt} ‚àò Œ∑ = G
   \]
   Where, the projection functors
   \begin{align*}
      \mathsf{Src}&                              &:& \mathsf{Arr}\, ùíü ‚ü∂ ùíü
   \\ \mathsf{Src}& (A‚ÇÅ , A‚ÇÇ , f)                &=& A‚ÇÅ
   \\ \mathsf{Src}& (f  , g  , h‚ÇÅ , h‚ÇÇ , proofs) &=& h‚ÇÅ
   \end{align*}
   with $\mathsf{Tgt}$ returning the other indexed items.
   
** Graphs as functors

We give an example of a functor by building on our existing graphs setup.
After showing that graphs correspond to certain functors, we then
mention that the notion of graph-map is nothing more than the associated
natural transformations!

#+BEGIN_SRC agda
 module graphs-as-functors where
#+END_SRC

Let us construct our formal graph category, which contains the ingredients for
a graph and a category and nothing more than the equations needed of a category.
The main ingredients of a two-sorted graph are two sort-symbols ~E, V~, along with
two function-symbols ~s, t~ from ~E~ to ~V~ ---this is also called ‚Äòthe signature
of graphs‚Äô. To make this into a category, we need function-symbols ~id~ and a composition
for which it is a unit.
#+BEGIN_SRC agda
  -- formal objects
  data ùí¢‚ÇÄ : Set where E V : ùí¢‚ÇÄ

  -- formal arrows
  data ùí¢‚ÇÅ : ùí¢‚ÇÄ ‚Üí ùí¢‚ÇÄ ‚Üí Set where
     s t : ùí¢‚ÇÅ E V              
     id  : ‚àÄ {o} ‚Üí ùí¢‚ÇÅ o o 

  -- (forward) composition
  fcmp : ‚àÄ {a b c} ‚Üí ùí¢‚ÇÅ a b ‚Üí ùí¢‚ÇÅ b c ‚Üí ùí¢‚ÇÅ a c
  fcmp f id = f
  fcmp id f = f
#+END_SRC

Putting it all together,
#+BEGIN_SRC agda
  instance
   ùí¢ : Category
   ùí¢ = record
        { Obj     = ùí¢‚ÇÄ
        ; _‚ü∂_     = ùí¢‚ÇÅ
        ; _‚®æ_     = fcmp
        ; assoc   = Œª {a b c d f g h} ‚Üí fcmp-assoc f g h
        ; Id      = id
        ; leftId  = left-id
        ; rightId = right-id
        }
    where
       -- exercises: prove associativity, left and right unit laws
#+END_SRC

:Solution:
#+BEGIN_SRC agda
       -- proofs are just C-c C-a after some casing

       fcmp-assoc : ‚àÄ {a b c d} (f : ùí¢‚ÇÅ a b) (g : ùí¢‚ÇÅ b c) (h : ùí¢‚ÇÅ c d) ‚Üí fcmp (fcmp f g) h ‚â° fcmp f (fcmp g h)
       fcmp-assoc s id id = ‚â°-refl
       fcmp-assoc t id id = ‚â°-refl
       fcmp-assoc id s id = ‚â°-refl
       fcmp-assoc id t id = ‚â°-refl
       fcmp-assoc id id s = ‚â°-refl
       fcmp-assoc id id t = ‚â°-refl
       fcmp-assoc id id id = ‚â°-refl

       right-id : ‚àÄ {a b} {f : ùí¢‚ÇÅ a b} ‚Üí fcmp f id ‚â° f
       right-id {f = s} = ‚â°-refl
       right-id {f = t} = ‚â°-refl
       right-id {f = id} = ‚â°-refl

       left-id : ‚àÄ {a b} {f : ùí¢‚ÇÅ a b} ‚Üí fcmp id f ‚â° f
       left-id {f = s} = ‚â°-refl
       left-id {f = t} = ‚â°-refl
       left-id {f = id} = ‚â°-refl
#+END_SRC
:End:
 
Now we can show that every graph ~G~ gives rise to a functor: A semantics of ~ùí¢~ in ~ùíÆeùìâ~.
#+BEGIN_SRC agda
  toFunc : Graph ‚Üí Functor ùí¢ ùíÆeùìâ
  toFunc G = record 
    { obj  = ‚ü¶_‚üß‚ÇÄ 
    ; mor  = ‚ü¶_‚üß‚ÇÅ 
    ; id   = ‚â°-refl 
    ; comp = Œª {x y z f g} ‚Üí fcmp-‚®æ {x} {y} {z} {f} {g}
    }
    where
      ‚ü¶_‚üß‚ÇÄ : Obj ùí¢ ‚Üí Obj ùíÆeùìâ
      ‚ü¶ ùí¢‚ÇÄ.V ‚üß‚ÇÄ = Graph.V G
      ‚ü¶ ùí¢‚ÇÄ.E ‚üß‚ÇÄ = Œ£ x ‚à∂ Graph.V G ‚Ä¢ Œ£ y ‚à∂ Graph.V G ‚Ä¢ Graph._‚ü∂_ G x y
          
      ‚ü¶_‚üß‚ÇÅ : ‚àÄ {x y : Obj ùí¢} ‚Üí x ‚ü∂ y ‚Üí (‚ü¶ x ‚üß‚ÇÄ ‚Üí ‚ü¶ y ‚üß‚ÇÄ) 
      ‚ü¶ s ‚üß‚ÇÅ (src , tgt , edg) = src
      ‚ü¶ t ‚üß‚ÇÅ (src , tgt , edg) = tgt
      ‚ü¶ id ‚üß‚ÇÅ x = x

      -- Exercise: fcmp is realised as functional composition
      fcmp-‚®æ : ‚àÄ{x y z} {f : ùí¢‚ÇÅ x y} {g : ùí¢‚ÇÅ y z} ‚Üí ‚ü¶ fcmp f g ‚üß‚ÇÅ ‚â° ‚ü¶ f ‚üß‚ÇÅ ‚®æ ‚ü¶ g ‚üß‚ÇÅ
#+END_SRC
:Solution:
#+BEGIN_SRC agda
      fcmp-‚®æ {f = s} {id} = ‚â°-refl
      fcmp-‚®æ {f = t} {id} = ‚â°-refl
      fcmp-‚®æ {f = id} {s} = ‚â°-refl
      fcmp-‚®æ {f = id} {t} = ‚â°-refl
      fcmp-‚®æ {f = id} {id} = ‚â°-refl
#+END_SRC
:End:

Conversely, every such functor gives a graph whose vertices and edges are the sets
associated with the sort-symbols ~V~ and ~E~, respectively.
#+BEGIN_SRC agda
  fromFunc : Functor ùí¢ ùíÆeùìâ ‚Üí Graph
  fromFunc F = record {
      V      = obj F ùí¢‚ÇÄ.V
    ; _‚ü∂_    = Œª x y ‚Üí Œ£ e ‚à∂ obj F ùí¢‚ÇÄ.E ‚Ä¢ src e ‚â° x √ó tgt e ‚â° y
             -- the type of edges whose source is x and target is y
    }
    where tgt src : obj F ùí¢‚ÇÄ.E ‚Üí obj F ùí¢‚ÇÄ.V
          src = mor F ùí¢‚ÇÅ.s
          tgt = mor F ùí¢‚ÇÅ.t
#+END_SRC

It is to be noted that we can define ‚Äò‚Äògraphs over ùíû‚Äô‚Äô to be the category ~Func ùí¢ ùíû~.
Some consequences are as follows: Notion of graph in any category, the notion of graph-map
is the specialisation of natural transformation (!), and most importantly, all the power of functor categories
is avaiable for the study of graphs.

In some circles, you may hear people saying an ‚Äòalgebra over the signature of graphs‚Äô is an interpretation
domain (~ùíû~) and an operation (~Functor ùí¢ ùíû~) interpreting the symbols. /Nice!/

# We no longer make use of this two-sorted approach to graphs.
#
# Yes, I do: To motivate, rather find, my definition of graphs!
* A few categorical constructions
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

We briefly take a pause to look at the theory of category theory.
In particular, we show a pair of constructions to get new categories from old ones,
interpret these constructions from the view of previously mentioned categories, and
discuss how to define the morphism type ~_‚ü∂_~ on morphisms themselves, thereby
yielding a functor.

** Opposite
The ‚Äòdual‚Äô or ‚Äòopposite‚Äô category ùíû·µí·µñ is the category constructed from ùíû by
reversing arrows: $(A ‚ü∂_{ùíû·µí·µñ} B) \;‚âî\; (B ‚ü∂_ùíû A)$, then necessarily
$(f ‚®æ_{ùíû·µí·µñ} g) \;‚âî\; g ‚®æ_ùíû f$.
A ‚Äòcontravariant functor‚Äô, or ‚Äòcofunctor‚Äô, is a functor F from an opposite category and so
there is a reversal of compositions: $F(f \,‚®æ\, g) \;=\; F g \,‚®æ\, F f$.
#+BEGIN_EXAMPLE
 _·µí·µñ : ‚àÄ {i j} ‚Üí Category {i} {j} ‚Üí Category
 ùíû ·µí·µñ = {! exercise !}
#+END_EXAMPLE
:Solution:
#+BEGIN_SRC agda
 _·µí·µñ : ‚àÄ {i j} ‚Üí Category {i} {j} ‚Üí Category {i} {j}
 ùíû ·µí·µñ         = record {
      Obj     = Obj ùíû
    ; _‚ü∂_     = Œª A B ‚Üí (B ‚ü∂ A)
    ; _‚®æ_     = Œª f g ‚Üí (g ‚®æ f)
    ; assoc   = ‚â°-sym assoc
    ; Id      = Id
    ; leftId  = rightId
    ; rightId = leftId
    }
    where instance ùíû‚Ä≤ : Category ; ùíû‚Ä≤ = ùíû
#+END_SRC
:End:

Notice that $(ùíû ·µí·µñ) ·µí·µñ \;=\; ùíû$ and $ùíû ·µí·µñ \;‚âÖ\; ùíû$
--one may have an intuitive idea of what this isomorphsim means,
but formally it is only meaningful in the context of an ambient category; keep reading ;)

We must admit that for categories, the notion of isomorphism is considered less useful
than that of equivalence which weakens the condition of the to-from functors being
inverses to just being naturally isomorphic to identities; C.f., ‚Äòevil‚Äô above.

Some interpretations:

+  ùíÆeùìâ·µí·µñ is usual sets and functions but with ‚Äòbackwards composition‚Äô:
   #+BEGIN_SRC agda
 infix 10 _‚àò_
 _‚àò_ : ‚àÄ {i j } ‚¶É ùíû : Category {i} {j}‚¶Ñ {A B C : Obj ùíû} ‚Üí B ‚ü∂ C ‚Üí  A ‚ü∂ B ‚Üí A ‚ü∂ C
 f ‚àò g = g ‚®æ f
#+END_SRC
   Indeed, we have ~g ‚®æ f within ùíû  =  f ‚àò g within ùíû ·µí·µñ~; which is how these composition operators
    are usually related in informal mathematics (without mention of the ambient categories of course).
   
   On a more serious note, the opposite of ùíÆeùìâ is clearly ùìâ‚ÑØùíÆ haha
   ---technically for the purposes of this pun we identify the words ‚Äòopposite‚Äô and ‚Äòreverse‚Äô.
   
+
  For a discrete category, its opposite is itself.
  
+
  For a monoid (viewed as a category), its opposite is itself if the monoid operation is commutative, otherwise
  it is the ‚Äòdual monoid‚Äô.

+
  For a poset (viewed as a category), its opposite is the ‚Äòdual poset‚Äô: $(P, ‚äë)·µí·µñ \;=\; (P, ‚äí)$.

  In particular, the ‚Äòleast upper bound‚Äô, or ‚Äòsupremum‚Äô in $(P, ‚äë)$ of two elements
  $x,y$ is an element $s$ with the ‚Äòuniversal property‚Äô: $‚àÄ z ‚Ä¢\; x ‚äë z ‚àß y ‚äë z \;‚â°\; s ‚äë z$.
  However, switching ‚äë with ‚äí gives us the notion of ‚Äòinfimum‚Äô, ‚Äògreatest upper bound‚Äô!
  So any theorems about supremums automatically hold for infimums since the infifum is nothing
  more than the supremum in the dual category of the poset.

  It is not difficult to see that this idea of ‚Äú2 for the price of 1‚Äù for theorems holds for all
  categories.

+ *Stone Duality:*
  ~FinBoolAlg ‚âÉ FinSets ·µí·µñ~ , witnessed by considering the collection of 
  atoms of a Boolean Algebra in one direction and the power set in the other.
  Finiteness can be removed at the cost of completeness and atomicitiy,
  ~CompleteAtomicBoolAlg ‚âÉ ùíÆ‚ÑØùìâ ·µí·µñ~.

+ What about the category of functors and natural transformations?

Speaking of functors, we can change the type of a functor by ~·µí·µñ~-ing its source and target,
while leaving it alone,
#+BEGIN_SRC agda
 -- this only changes type
 opify : ‚àÄ {i j i‚Äô j‚Äô} {ùíû : Category {i} {j}} {ùíü : Category {i‚Äô} {j‚Äô}} 
      ‚Üí Functor ùíû ùíü ‚Üí Functor (ùíû ·µí·µñ) (ùíü ·µí·µñ)
 opify F = record { obj   =  obj F 
                  ; mor   =  mor F 
                  ; id    =  Functor.id F 
                  ; comp  =  Functor.comp F 
                  }
#+END_SRC

#+BEGIN_QUOTE
Category Theory is the ‚Äòop‚Äôium of the people!

--- Karl Marx might say it had cats existed in his time
#+END_QUOTE

This two definitions seem to indicate that we have some form of opposite-functor ‚Ä¶ ;)
---keep reading!

~opify~ seems to show that ~Functor ùíû ùíü ‚â° Functor (ùíû ·µí·µñ) (ùíü ·µí·µñ)~, or alternatively a
functor can have ‚Äòtwo different types‚Äô ---this is akin to using the integers as reals
without writing out the inclusion formally, leaving it implicit; however, in the Agda mechanization
everything must be made explicit ---the type system doesn‚Äôt let you get away with such things.
Professor Maarten Fokkinga has informed me that
the formalization allowing multiple-types is called a
[[http://maartenfokkinga.github.io/utwente/mmf92b.pdf][pre-category]].
 
*** ah-yeah: ‚àÇ and dagger categories

With ~ùíûùí∂ùìâ~ in-hand, we can formalise the opposite, or ‚àÇual, functor:
#+BEGIN_SRC agda
 ‚àÇ : ‚àÄ {i j} ‚Üí Functor (ùíûùí∂ùìâ {i} {j}) ùíûùí∂ùìâ
 ‚àÇ = record { obj = _·µí·µñ ; mor = opify ; id = ‚â°-refl ; comp = ‚â°-refl }
#+END_SRC

Conjecture: Assuming categories are equipped with a contravariant involutionary functor
that is identity on objects, we can show that the identity functor is naturally isomorphic 
to the opposite functor.

#+BEGIN_SRC agda
 ah-yeah : ‚àÄ {i j} (let Cat = Obj (ùíûùí∂ùìâ {i} {j}))
     -- identity on objects cofunctor, sometimes denoted _Àò
     ‚Üí (dual : ‚àÄ (ùíû : Cat) {x y : Obj ùíû}  ‚Üí  x ‚ü∂ y ‚à∂ ùíû  ‚Üí  y ‚ü∂ x ‚à∂ ùíû)
     ‚Üí (IdÀò : ‚àÄ ‚¶É ùíû : Cat ‚¶Ñ {x : Obj ùíû} ‚Üí dual ùíû Id  ‚â°  Id {A = x})
     ‚Üí (‚®æ-Àò : ‚àÄ ‚¶É ùíû : Cat ‚¶Ñ {x y z : Obj ùíû} {f : x ‚ü∂ y} {g : y ‚ü∂ z}
            ‚Üí dual ùíû (f ‚®æ g ‚à∂ ùíû)  ‚â°  (dual ùíû g) ‚®æ (dual ùíû f) ‚à∂ ùíû)
     -- which is involutionary
     ‚Üí (ÀòÀò : ‚àÄ ‚¶É ùíû : Cat ‚¶Ñ {x y : Obj ùíû} {f : x ‚ü∂ y} ‚Üí dual ùíû (dual ùíû f) ‚â° f)
     -- which is respected by other functors
     ‚Üí (respect : ‚¶É ùíû ùíü : Cat ‚¶Ñ {F : ùíû ‚ü∂ ùíü} {x y : Obj ùíû} {f : x ‚ü∂ y}
                ‚Üí mor F (dual ùíû f) ‚â° dual ùíü (mor F f))
     -- then
     ‚Üí ‚àÇ ‚âÖ Id within Func (ùíûùí∂ùìâ {i} {j}) ùíûùí∂ùìâ     
#+END_SRC
#+BEGIN_EXAMPLE
 ah-yeah = {! exercise !}
#+END_EXAMPLE
:Solution:
#+BEGIN_SRC agda
 ah-yeah {i} {j} _Àò IdÀò ‚®æ-Àò ÀòÀò respect = record
   { to = II
   ; from = JJ
   ; lid = nattransext {ùíû = ùíûùí∂ùìâ} {ùíûùí∂ùìâ} {‚àÇ} {‚àÇ} (Category._‚®æ_ ùí©ùìâ {‚àÇ} {Id} {‚àÇ} II JJ) (Category.Id ùí©ùìâ {‚àÇ}) Œª {ùíû} ‚Üí funcext ‚â°-refl (‚â°-sym (ÀòÀò ‚¶É ùíû ‚¶Ñ ))
   ; rid = nattransext {ùíû = ùíûùí∂ùìâ} {ùíûùí∂ùìâ} {Id} {Id} (Category._‚®æ_ ùí©ùìâ {Id} {‚àÇ} {Id} JJ II) (Category.Id ùí©ùìâ {Id}) Œª {ùíû} ‚Üí funcext ‚â°-refl (‚â°-sym (ÀòÀò ‚¶É ùíû ‚¶Ñ))
   }
   where
   
     ùí©ùìâ = Func (ùíûùí∂ùìâ {i} {j}) (ùíûùí∂ùìâ {i} {j}) -- the category of ~ùí©~atural transormations as morphisms
     
     I : ‚¶É ùíû : Category {i} {j} ‚¶Ñ ‚Üí Functor (obj ‚àÇ ùíû) ùíû
     I ‚¶É ùíû ‚¶Ñ = record { obj = Id ; mor = _Àò ùíû ; id = IdÀò ; comp = ‚®æ-Àò }

     _‚®æf_ = Category._‚®æ_ (ùíûùí∂ùìâ {i} {j})

     Inat : ‚¶É ùíû ùíü : Category {i} {j} ‚¶Ñ {F : Functor ùíû ùíü} ‚Üí mor ‚àÇ F ‚®æf I ‚¶É ùíü ‚¶Ñ  ‚â°  I ‚¶É ùíû ‚¶Ñ ‚®æf F
     Inat ‚¶É ùíû ‚¶Ñ ‚¶É ùíü ‚¶Ñ {F} = funcext ‚¶É ùíû = ùíû ·µí·µñ ‚¶Ñ ‚¶É ùíü ‚¶Ñ { mor ‚àÇ F ‚®æf I ‚¶É ùíü ‚¶Ñ } { I ‚¶É ùíû ‚¶Ñ ‚®æf F } ‚â°-refl Œª {x} {y} {f} ‚Üí respect ‚¶É ùíû ‚¶Ñ ‚¶É ùíü ‚¶Ñ {F} {y} {x} {f}

     II : NatTrans ‚àÇ Id
     II = I , (Œª {ùíû} {ùíü} {F} ‚Üí Inat ‚¶É ùíû ‚¶Ñ ‚¶É ùíü ‚¶Ñ {F})

     J : ‚¶É ùíû : Category {i} {j} ‚¶Ñ ‚Üí ùíû ‚ü∂ obj ‚àÇ ùíû
     J ‚¶É ùíû ‚¶Ñ = record { obj = Id ; mor = _Àò ùíû ; id = IdÀò ; comp = ‚®æ-Àò }

     Jnat : ‚¶É ùíû ùíü : Category {i} {j} ‚¶Ñ {F : ùíû ‚ü∂ ùíü}  ‚Üí  F ‚®æf J ‚¶É ùíü ‚¶Ñ  ‚â°  J ‚¶É ùíû ‚¶Ñ ‚®æf mor ‚àÇ F
     Jnat ‚¶É ùíû ‚¶Ñ ‚¶É ùíü ‚¶Ñ {F} = funcext ‚¶É ùíû = ùíû ‚¶Ñ ‚¶É ùíü ·µí·µñ ‚¶Ñ {F ‚®æf J ‚¶É ùíü ‚¶Ñ} {J ‚¶É ùíû ‚¶Ñ ‚®æf mor ‚àÇ F} ‚â°-refl (Œª {x y f} ‚Üí respect ‚¶É ùíû ‚¶Ñ ‚¶É ùíü ‚¶Ñ {F} {x} {y} {f})

     JJ : NatTrans ‚¶É ùíûùí∂ùìâ {i} {j} ‚¶Ñ ‚¶É ùíûùí∂ùìâ ‚¶Ñ Id ‚àÇ
     JJ = J , (Œª {ùíû} {ùíü} {F} ‚Üí Jnat ‚¶É ùíû ‚¶Ñ ‚¶É ùíü ‚¶Ñ {F})
#+END_SRC
:End:

Some things to note.

+
  Categories whose morphisms are all isomorphisms are called ‚Äògroupoids‚Äô ---groups are just one-object groupoids.
  Consequently, restricted to groupoids the opposite functor is naturally isomorphic to the identity functor!
  
  In fact, the group case was the motivator for me to conjecture the theorem, which took a while to prove since I hadn‚Äôt
  a clue what I needed to assume. Here we‚Äôd use ~a Àò ‚âî a ‚Åª¬π~.
   
+
  Consider the category ~Rel~ whose objects are sets and whose morphisms are ‚Äòtyped-relations‚Äô $(S, R, T)$, 
  where $R$ is a relation from set $S$ to set $T$, and
  composition is just relational composition
  ---the notion of ‚Äòuntyped‚Äô, or multi-typed, morphisms is formalized as pre-categories;
  see [[http://maartenfokkinga.github.io/utwente/mmf92b.pdf][Fokkinga]].
  Then we can define an endofunctor by taking ~-Àò~ to be relational converse: $x \,(R Àò)\, y \;‚â°\; y \,R\, x$.
  Consequently, restricted to the category ~Rel~ we have that the opposite functor is naturally isomorphic to the identity functor.
  
  :NeatObservation:
  Indeed, in the proof above, all quantification‚Äôs become over a unit type: only possibility is
  ~Rel~.
  
  Then, ~I : Rel ·µí·µñ ‚ü∂ Rel~ and ~J : Rel ‚ü∂ Rel ·µí·µñ~, and the lid-rid proofs amount to saying that
  the two are inverses.
  :End:
  
The above items are instance of a more general concept, of course.

A category with an involutionary contravariant endofunctor that is the identity on objects
is known as /a dagger category, an involutive/star category, or a category with converse/
---and the functor is denoted as a superscript suffix by ~‚Ä†, *, Àò~, respectively.
The dagger notation probably comes from
the Hilbert space setting while the converse notation comes from the relation algebra setting.
As far as I know, the first two names are more widely known.
A dagger category bridges the gap between arbitrary categories and groupoids.

Just as matrices with matrix multiplication do not form a monoid but rather a category, we have
that not all matrices are invertible but they all admit transposition and so we have a dagger
category. In the same vein, relations admit converse and so give rise to a category with converse.

Besides relations and groupoids, other examples include:
+ discrete categories with the dagger being the identity functor
+ every monoid with an anti-involution is trivially a dagger category; e.g.,
   lists with involution being reverse.
+ commutative monoids are anti-involutive monoids with anti-involution being identity

Spoilers!! Just as the category of categories is carestian closed, so too is the category of dagger
categories and dagger preserving functors --c.f.,the ~respect~ premise above.

:PseudoHeaps:
a pseudoheap is a set H with an binary-operation assigning function  ‚ü®_‚ü© : H ‚Üí (H √ó H ‚Üí H)
such that
mutual-assoc:  (a ‚ü®b‚ü© c) ‚ü®d‚ü© e = a ‚ü®b‚ü© (c ‚ü®d‚ü© e)
commutative: x ‚ü®a‚ü© y = y ‚ü®a‚ü© x

Every involutive monoid is a pseudoheap: x ‚ü®y‚ü© z ‚âî x ¬∑ y Àò ¬∑ z
:End:

** Products

For any two categories ùíû and ùíü we can construct their ‚Äòproduct‚Äô category
$ùíû ‚äó ùíü$ whose objects and morphisms are pairs with components from ùíû and ùíü:
$\Obj\, (ùíû ‚äó ùíü) \;\;=\;\; \Obj\, ùíû \,√ó\, \Obj\, ùíü$ and
$(A , X) ‚ü∂_{ùíû ‚äó ùíü} (B , Y) \;\;=\;\; (A ‚ü∂_ùíû B) \,√ó\, (X ‚ü∂_ùíü Y)$.
#+BEGIN_EXAMPLE
 -- we cannot overload symbols in Agda and so using ‚Äò‚äó‚Äô in-place of more common ‚Äò√ó‚Äô.
 _‚äó_ : ‚àÄ {i j i‚Äô j‚Äô} ‚Üí Category {i} {j} ‚Üí Category {i‚Äô} {j‚Äô} ‚Üí Category
 ùíû ‚äó ùíü = {! exercise !}
#+END_EXAMPLE
:Solution:
#+BEGIN_SRC agda
 infix 5 _‚äó_
 _‚äó_ : ‚àÄ {i j i‚Äô j‚Äô} ‚Üí Category {i} {j} ‚Üí Category {i‚Äô} {j‚Äô} ‚Üí Category {i ‚äç i‚Äô} {j ‚äç j‚Äô}
 ùíû ‚äó ùíü = record
           { Obj = Obj ùíû √ó Obj ùíü
           ; _‚ü∂_ = Œª{ (A , X) (B , Y)  ‚Üí  (A ‚ü∂ B) √ó (X ‚ü∂ Y) }
           ; _‚®æ_ = Œª{ (f , k) (g , l) ‚Üí (f ‚®æ g , k ‚®æ l) }
           ; assoc = assoc ‚â°√ó‚â° assoc
           ; Id = Id , Id
           ; leftId = leftId ‚â°√ó‚â° leftId
           ; rightId = rightId ‚â°√ó‚â° rightId
           }
           where
             _‚â°√ó‚â°_ : ‚àÄ {i j} {A : Set i} {B : Set j} {a a‚Äô : A} {b b‚Äô : B} ‚Üí a ‚â° a‚Äô ‚Üí b ‚â° b‚Äô ‚Üí (a , b) ‚â° (a‚Äô , b‚Äô)
             ‚â°-refl ‚â°√ó‚â° ‚â°-refl = ‚â°-refl
             instance
               ùíû‚Ä≤ : Category
               ùíû‚Ä≤ = ùíû
               ùíü‚Ä≤ : Category
               ùíü‚Ä≤ = ùíü
#+END_SRC
:End:

Observe that in weaker languages, a category is specified by its objects, morphisms, and composition
---the proof obligations are delegated to comments, if they are realized at all.
In such settings, one would need to prove that this construction actually produces a full-fledged
category. Even worse, this proof may be a distance away in some documentation.
With dependent types, our proof obligation is nothing more than another component of the program,
a piece of the category type.

In a similar fashion we can show that the sum of two categories is again a category and in general
we have the same for quantified variants: ~Œ† ùíû ‚à∂ Family ‚Ä¢ ùíû~, likewise for ‚ÄòŒ£‚Äô.
For the empty family, the empty sum yields the category ~ùüò~ with no objects and
the empty product yields the category ~ùüô~ of one object.
One can then show the usual ‚Äòlaws of arithmetic‚Äô ---i.e., √ó,+ form a commutative monoid, up to isomorphism---
hold in this setting: Letting ~‚òÖ ‚àà {+,√ó}~, we have
associtivity ~A ‚òÖ (B ‚òÖ C) ‚âÖ (A ‚òÖ B) ‚òÖ C~, symmetry ~A ‚òÖ B ‚âÖ B ‚òÖ A~,
unit ~ùüô √ó A ‚âÖ ùüò + A ‚âÖ A~, and zero ~ùüò √ó A ‚âÖ ùüò~.
These notions can be defined for any category though the objects may or may not exist
--- in ~ùíÆeùìâ~ and ~ùí¢ùìáùí∂ùìÖùíΩ~, for example, they do exist ;) ---and these associated arithmetical
laws also hold.

/Question!/ What of the distributivity law,
~A √ó (B + C) ‚âÖ (A √ó B) + (A √ó C)~, does it hold in the mentioned cases?
Let ~ùí´ùíÆeùìâ~ be the category of sets with a distinguished point, i.e.,  ~Œ£ S : Obj ùíÆeùìâ ‚Ä¢ S~, and
functions that preserve the ‚Äòpoint‚Äô, one can then show ---if he or she so desires, and is not
lazy--- that this category has notions of product and sum but distributivity fails.

Some interpretations:
+ 
  For discrete categories, this is the usual Cartesian product.
+
  For monoid (or poset) categories, this says that the product of two monoids (or posets) is again
  a monoid (respectively poset. This follows since the product does not affect the number of
  objects and so the product is again a one-object category, i.e., a monoid (poset respectively).
+ Interestingly, the /sum/ of two monoids is *not* formed by their disjoint union: Instead
  it is the set of all alternating lists of elements from the two given monoids.
  Exercise: Find the associated operation ;-)

As expected, we have projections,
#+BEGIN_SRC agda
 Fst : ‚àÄ {i j i‚Äô j‚Äô} {ùíû : Category {i} {j}} {ùíü : Category {i‚Äô} {j‚Äô}} 
     ‚Üí Functor (ùíû ‚äó ùíü) ùíû
 Fst = record { obj = proj‚ÇÅ ; mor = proj‚ÇÅ ; id = ‚â°-refl ; comp = ‚â°-refl }

 Snd : ‚àÄ {i j i‚Äô j‚Äô} {ùíû : Category {i} {j}} {ùíü : Category {i‚Äô} {j‚Äô}} 
     ‚Üí Functor (ùíû ‚äó ùíü) ùíü
 Snd = record { obj = proj‚ÇÇ ; mor = proj‚ÇÇ ; id = ‚â°-refl ; comp = ‚â°-refl }
#+END_SRC

*** Currying

For types we have \[ (ùí≥ √ó ùí¥ ‚ü∂ ùíµ) \quad‚âÖ\quad (ùí≥ ‚ü∂ ùíµ ^ ùí¥) \quad‚âÖ\quad (ùí¥ ‚ü∂ ùíµ ^ ùí≥)\]
Since categories are essentially types endowed with nifty structure,
we expect it to hold in that context as well.
#+BEGIN_EXAMPLE
  -- Everyone usually proves currying in the first argument,
  -- let‚Äôs rebel and do so for the second argument
 curry‚ÇÇ : ‚àÄ {ix jx iy jy iz jz}
          {ùí≥ : Category {ix} {jx}} {ùí¥ : Category {iy} {jy}} {ùíµ : Category {iz} {jz}}
        ‚Üí Functor (ùí≥ ‚äó ùí¥) ùíµ ‚Üí Functor ùí¥ (Func ùí≥ ùíµ)
 curry‚ÇÇ = {! exercise !}
#+END_EXAMPLE
:Solution:
#+BEGIN_SRC agda
 curry‚ÇÇ : ‚àÄ {ix jx iy jy iz jz} ‚¶É ùí≥ : Category {ix} {jx} ‚¶Ñ ‚¶É ùí¥ : Category {iy} {jy} ‚¶Ñ ‚¶É ùíµ : Category {iz} {jz} ‚¶Ñ
         ‚Üí Functor (ùí≥ ‚äó ùí¥) ùíµ ‚Üí Functor ùí¥ (Func ùí≥ ùíµ)
 curry‚ÇÇ ‚¶É ùí≥ = ùí≥ ‚¶Ñ ‚¶É ùí¥ ‚¶Ñ ‚¶É ùíµ ‚¶Ñ F = record {
    obj =  funcify
  ; mor =  natify
  ; id =  Œª {x} ‚Üí nattransext {F = funcify x} {funcify x} (natify (Id {A = x})) (Category.Id (Func ùí≥ ùíµ) {A = funcify x}) (Functor.id F)
  ; comp =  Œª {x y z f g} ‚Üí nattransext {F = funcify x} {funcify z} (natify (f ‚®æ g)) ( Category._‚®æ_ (Func ùí≥ ùíµ) {A = funcify x} {B = funcify y} {C = funcify z} (natify f) (natify g) ) (begin
             mor F (Id , f ùí¥.‚®æ g)
           ‚â°‚ü® ‚â°-cong (Œª e ‚Üí mor F (e , f ùí¥.‚®æ g)) (‚â°-sym ùí≥.rightId) ‚ü©
             mor F (Id ùí≥.‚®æ Id , f ùí¥.‚®æ g)
           ‚â°‚ü® functor F preserves-composition ‚ü©
             mor F (Id , f) ùíµ.‚®æ mor F (Id , g)
           ‚àé) }
  where
        module ùí≥ = Category ùí≥
        module ùí¥ = Category ùí¥
        module ùíµ = Category ùíµ
        funcify : (y : Obj ùí¥) ‚Üí Functor ùí≥ ùíµ
        funcify = Œª Y ‚Üí record {
            obj = Œª X ‚Üí obj F (X , Y)
          ; mor = Œª f ‚Üí mor F (f , Id ‚¶É ùí¥ ‚¶Ñ {A = Y})
          ; id = Functor.id F
          ; comp = Œª {x y z f g} ‚Üí begin
                mor F (f ùí≥.‚®æ g , Id ‚¶É ùí¥ ‚¶Ñ)
              ‚â°‚ü® ‚â°-cong (Œª x ‚Üí mor F (f ùí≥.‚®æ g , x)) (‚â°-sym ùí¥.rightId) ‚ü©
                mor F (f ùí≥.‚®æ g , Id ùí¥.‚®æ Id)
              ‚â°‚ü® Functor.comp F ‚ü©
                mor F (f , Id ‚¶É ùí¥ ‚¶Ñ) ùíµ.‚®æ mor F (g , Id ‚¶É ùí¥ ‚¶Ñ)
              ‚àé }
        
        natify : {x y : Obj ùí¥} ‚Üí x ùí¥.‚ü∂ y ‚Üí NatTrans (funcify x) (funcify y)
        natify {x} {y} f = (Œª {z} ‚Üí mor F (Id {A = z} , f)) , (Œª {a b g} ‚Üí begin
                mor F (g , Id) ùíµ.‚®æ mor F (Id , f)
              ‚â°‚ü® ‚â°-sym (functor F preserves-composition) ‚ü©
                 mor F (g ùí≥.‚®æ Id , Id ùí¥.‚®æ f)
              ‚â°‚ü® ‚â°-cong‚ÇÇ (Œª x y ‚Üí mor F (x , y)) ùí≥.rightId ùí¥.leftId ‚ü©
                 mor F (g , f)
              ‚â°‚ü® ‚â°-sym (‚â°-cong‚ÇÇ (Œª x y ‚Üí mor F (x , y)) ùí≥.leftId ùí¥.rightId) ‚ü©
                 mor F (Id ùí≥.‚®æ g , f ùí¥.‚®æ Id)
              ‚â°‚ü® functor F preserves-composition ‚ü©
                mor F (Id , f) ùíµ.‚®æ mor F (g , Id)
              ‚àé)
#+END_SRC
:End:

** Pointwise extensions and the hom functor
Just as addition can be extended to number-valued functions pointwise, $f + g \;‚âî\; Œª x ‚Üí f x + g x$,
we can do the same thing with functors.
#+BEGIN_EXAMPLE
 -- For bifunctor ‚Äò‚äï‚Äô and functors ‚ÄòF, G‚Äô, we have a functor ‚ÄòŒª x ‚Üí F x ‚äï G x‚Äô
 pointwise : ‚àÄ {ic jc id jd ix jx iy jy}
   {ùíû : Category {ic} {jc}} {ùíü : Category {id} {jd}} {ùí≥ : Category {ix} {jx}} {ùí¥ : Category {iy} {jy}}
   ‚Üí Functor (ùí≥ ‚äó ùí¥) ùíü ‚Üí Functor ùíû ùí≥ ‚Üí Functor ùíû ùí¥
   ‚Üí Functor ùíû ùíü
 pointwise = {! exercise !}
#+END_EXAMPLE
:Solution:
#+BEGIN_SRC agda
 pointwise : ‚àÄ {ic jc id jd ix jx iy jy} {ùíû : Category {ic} {jc}} {ùíü : Category {id} {jd}}
   {ùí≥ : Category {ix} {jx}} {ùí¥ : Category {iy} {jy}}
   (_‚äï_ : Functor (ùí≥ ‚äó ùí¥) ùíü) (F : Functor ùíû ùí≥) (G : Functor ùíû ùí¥) ‚Üí Functor ùíû ùíü
 pointwise {ùíû = ùíû} {ùíü} {ùí≥} {ùí¥} Bi F G =
   let module ùí≥ = Category ùí≥
       module ùí¥ = Category ùí¥
       module ùíû = Category ùíû
       module ùíü = Category ùíü
   in record {
     obj = Œª C ‚Üí obj Bi (obj F C , obj G C)
   ; mor = Œª {x y} x‚Üíy ‚Üí mor Bi (mor F x‚Üíy , mor G x‚Üíy)
   ; id = Œª {x} ‚Üí begin
          mor Bi (mor F ùíû.Id , mor G ùíû.Id)
        ‚â°‚ü® ‚â°-cong‚ÇÇ (Œª f g ‚Üí mor Bi (f , g)) (Functor.id F) (Functor.id G) ‚ü©
          mor Bi (ùí≥.Id , ùí¥.Id)
        ‚â°‚ü® functor Bi preserves-identities ‚ü©
          ùíü.Id
        ‚àé
   ; comp = Œª {x y z x‚ü∂y y‚ü∂z} ‚Üí begin
       mor Bi (mor F (x‚ü∂y ùíû.‚®æ y‚ü∂z) , mor G (x‚ü∂y ùíû.‚®æ y‚ü∂z))
     ‚â°‚ü® ‚â°-cong‚ÇÇ (Œª f g ‚Üí mor Bi (f , g)) (Functor.comp F) (Functor.comp G) ‚ü©
       mor Bi (mor F x‚ü∂y ùí≥.‚®æ mor F y‚ü∂z , mor G x‚ü∂y ùí¥.‚®æ mor G y‚ü∂z)
     ‚â°‚ü® functor Bi preserves-composition ‚ü©
      (mor Bi (mor F x‚ü∂y , mor G x‚ü∂y)) ùíü.‚®æ (mor Bi (mor F y‚ü∂z , mor G y‚ü∂z))
     ‚àé
     }
#+END_SRC
:End:

By ‚Äòextensionality‚Äô ~p ‚â° (proj‚ÇÅ p , proj‚ÇÇ p)~, we have that the pointwise extension along the projections
is the orginal operation.
#+BEGIN_SRC agda
 exempli-gratia : ‚àÄ {ùíû ùíü ùí≥ ùí¥ : Category {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ}} (‚äï : Functor (ùí≥ ‚äó ùí¥) ùíü)
                ‚Üí let _‚ü®‚äï‚ü©_ = pointwise ‚äï
                   in
                      Fst ‚ü®‚äï‚ü© Snd ‚â° ‚äï
 exempli-gratia Bi = funcext (‚â°-cong (obj Bi) ‚â°-refl) (‚â°-cong (mor Bi) ‚â°-refl)
#+END_SRC

An example bifunctor is obtained by extending the ‚Äò‚ü∂‚Äô to morphisms:
Given ~f : A ‚ü∂ B , g : C ‚ü∂ D~ we define ~(f ‚ü∂ g) : (B ‚ü∂ C) ‚Üí (A ‚ü∂ C)~ by
~Œª h ‚Üí f ‚®æ h ‚®æ g~ as this is the only way to define it so as to meet the type requirements.
#+BEGIN_SRC agda
 Hom : ‚àÄ {i j} {ùíû : Category {i} {j} } ‚Üí Functor (ùíû ·µí·µñ ‚äó ùíû) (ùíÆeùìâ {j})
   -- hence contravariant in ‚Äòfirst arg‚Äô and covaraint in ‚Äòsecond arg‚Äô
 Hom {ùíû = ùíû} =
   let
     module ùíû = Category ùíû
     instance ùíû‚Ä≤ : Category ; ùíû‚Ä≤ = ùíû
     ‚®æ-cong‚ÇÇ : ‚àÄ {A B C : Obj ùíû} {f : A ùíû.‚ü∂ B} {g g‚Äô : B ùíû.‚ü∂ C}
             ‚Üí g ‚â° g‚Äô ‚Üí f ùíû.‚®æ g ‚â° f ùíû.‚®æ g‚Äô
     ‚®æ-cong‚ÇÇ  q  =  ‚â°-cong‚ÇÇ ùíû._‚®æ_ ‚â°-refl q
   in record {
     obj = Œª{ (A , B) ‚Üí  A ‚ü∂ B }
   ; mor = Œª{ (f , g) ‚Üí Œª h ‚Üí f ‚®æ h ‚®æ g }
   ; id = extensionality (Œª {h} ‚Üí begin
        Id ùíû.‚®æ h ùíû.‚®æ Id
      ‚â°‚ü® leftId ‚ü©
        h ùíû.‚®æ Id
      ‚â°‚ü® rightId ‚ü©
        h
      ‚àé)
   ; comp =  Œª {x y z fg fg‚Äô} ‚Üí
       let (f , g) = fg ; (f‚Äô , g‚Äô) = fg‚Äô in extensionality (Œª {h} ‚Üí begin
            (f‚Äô ùíû.‚®æ f) ùíû.‚®æ h ùíû.‚®æ (g ùíû.‚®æ g‚Äô)
          ‚â°‚ü® assoc ‚ü©
            f‚Äô ùíû.‚®æ (f ùíû.‚®æ (h ùíû.‚®æ (g ùíû.‚®æ g‚Äô)))
          ‚â°‚ü® ‚®æ-cong‚ÇÇ (‚â°-sym assoc) ‚ü©
            f‚Äô ùíû.‚®æ ((f ùíû.‚®æ h) ùíû.‚®æ (g ùíû.‚®æ g‚Äô))
          ‚â°‚ü® ‚®æ-cong‚ÇÇ (‚â°-sym assoc) ‚ü©
            f‚Äô ùíû.‚®æ ((f ùíû.‚®æ h) ùíû.‚®æ g) ùíû.‚®æ g‚Äô
          ‚â°‚ü® ‚®æ-cong‚ÇÇ (‚â°-cong‚ÇÇ ùíû._‚®æ_ assoc ‚â°-refl) ‚ü©
            f‚Äô ùíû.‚®æ (f ùíû.‚®æ h ùíû.‚®æ g) ùíû.‚®æ g‚Äô
          ‚àé)
     }           
#+END_SRC
The naming probably comes from the algebra/monoid case where the functors are
monoid ~hom~-omorphisms. Some prefer to use the name ~Mor~, short for ~mor~-phisms,
and that‚Äôs cool too. While Haskell programmers might call this the ~Reader~ functor.

Usual notation for this functor is ~Hom~, but I like Fokkinga‚Äôs much better.
He uses ~(_‚ü∂_)~ and writes ~(f ‚ü∂ g) = Œª h ‚Ä¢ f ‚®æ h ‚®æ g~
---the first argument of Hom is the first argument of the composition and the last
argument to Hom is the last argument of the resulting composition :-)
* ùíÆimplicity ùí∞nderlies ùíûomplexity
:PROPERTIES:
:header-args: :tangle "PathCat.agda"
:END:

** Intro :ignore:

#+BEGIN_QUOTE
One way is to make it so ùíÆimple that there are obviously no deficiencies, and the other way is to
make it so ùíûomplicated that there are no obvious deficiencies. The first method is far more
difficult. It demands the same skill, devotion, insight, and even inspiration as the discovery of
the simple physical laws which ùí∞nderlie the complex phenomena of nature.

‚îÄ[[https://en.wikiquote.org/wiki/C._A._R._Hoare][C.A.R. Hoare]]
#+END_QUOTE

#+HTML: <small>
#+BEGIN_CENTER
( The ùíûomplex philosophy behinds games such as Chess and
[[http://playgo.to/iwtg/en/][Go]] arise from some ùíÆimple board game rules.
)
#+END_CENTER
#+HTML: </small>

In this section we discuss what it means to be a ‚Äòforgetful functor‚Äô?
--Also called an `ùí∞nderlying functor'.

The modifier ‚Äòforgetful‚Äô is meaningful when there‚Äôs a notion of extra structure.
Indeed any functor /F : ùíû ‚ü∂ ùíÆ/ can be thought of as forgetful by construing the objects of
ùíû as objects of ùíÆ with extra structure.
Mostly: /You know it (to be forgetful) when you see it!/

** Being forgetful: from injections to faithful functors

A common example from set theory is the ‚Äòinclusion‚Äô of a subset $A$ of $B$, the injection
$Œπ : A ‚Ü™ B : a ‚Ü¶ a$ ---it is essentially a form of ‚Äòtype casting‚Äô: $a ‚àà A$ and $Œπ a \;=\; a ‚àà B$.
Such injections ‚Äòforget‚Äô the property that the argument is actually a member of a specified
subset. Indeed, construing sets as categories then functions becomes functors and inclusions
are then forgetful functors!

Since a functor /F/ consists of two maps /(F‚ÇÄ, F‚ÇÅ) ‚âî (obj F, mor F)/ and some properties, we can speak about properties of the
functor and about properties of either of its maps.
The common definitions are a functor $F$ is:
+ faithful :: If its operation on morphisms is /injective/, and it is
+ full     :: If morphisms starting and ending at /F/ are a result of applying $F$; \\
              i.e., /F‚ÇÅ/ is surjective /on/ the image of /F‚ÇÄ/: \\
              $‚àÄ x,y ‚à∂ Obj \;‚Ä¢\; ‚àÄ g ‚à∂ F‚ÇÄ x ‚ü∂ F‚ÇÄ y \;‚Ä¢\; ‚àÉ f ‚à∂ x ‚ü∂ y \;‚Ä¢\; F‚ÇÅ f = g$.

Now we can generalize the previous example.
Every faithful functor /F : ùíû ‚ü∂ ùíü/ can be construed as forgetful:
The ùíû-maps can be embedded into the ùíü-maps, since F is faithful, and so can be thought of
as a special sub-collection of the ùíü-maps; then $F$ ‚Äòforgets‚Äô the property of being in this
special sub-collection.

Are faithful functors in abundance? Well any functor forgetting only axioms
(and/or structure) is faithful:

  0. Suppose ùíû consists of ùíü objects satisfying some axioms and ùíü maps preserving this structure.
  1. That is, ùíû has pairs of ùíü objects/morphisms with a proof that it satisfies the axioms/preserves-structure.
  2. Then ‚Äú$F : ùíû ‚ü∂ ùíü$ forgets only axioms‚Äù means $F\, (f, \mathsf{proof}) \;=\; f$.
  3. Now given, $F (f , prf) = F (g , prf) \;‚áî\; f = g \;‚áî\; (f , prf) = (g , prf)$
     -- equality does not (extensionally) depend on proof components.
  
     Hence, faithful :-)

    (Likewise for forgetting extra structure).

Of course we‚Äôre not saying all forgetful functors are necessarily faithful.
A simple counterexample is the absolute value function:
Given a real number $x$ it‚Äôs absolute value $‚à£x‚à£$ is obtained by totally ignoring its sign
---of course $x$ and $‚à£x‚à£$ are equidistant from 0, the relation equidistant-from-0 is an equivalence
relation --Exercise!--, and so the the two are isomorphic in some sense.

:Solution:
E is an equivalence, where x E y ‚â° ‚à£ x - y ‚à£ = 0

+ Refl: x E x ‚áê ‚à£ x - x ‚à£ = 0 ‚áê ‚ä§
+ Sym:  x E y ‚áí ‚à£x - y‚à£ = 0 ‚áí ‚à£y - x‚à£ = 0 ‚áí y E x
+ Trans: x E y E z ‚áí ‚à£x - y‚à£ = ‚à£y - z‚à£ = 0 ‚áí ‚à£x - z‚à£ = ‚à£x - y + y - z‚à£ ‚â§ ‚à£x - y‚à£ + ‚à£y - z‚à£ = 0 + 0 = 0

A simpler definition of E is x E y ‚â° ‚à£x‚à£ = ‚à£y‚à£
and that is the kernel of the absolute function and so an equivalence.
:End:

Motivated by this, given a set $S$ it‚Äôs size is denoted $‚à£ S ‚à£$ which totally forgets about the
elements of the set ---of course it can be shown that two sets are isomorphic precisely if they are
equinumerous.

I assume it is with these as motivators, some people write $‚à£¬∑‚à£$ for a forgetful functor.

( Exercise: A functor ~F : ùíû ‚âÉ ùíü~ is (part of) an equivalence iff it is full, 
faithful, and ‚Äò‚Äòessentially surjective on objects‚Äô‚Äô:
 ~‚àÄ D : Obj ùíü ‚Ä¢ Œ£ C : Obj ùíû ‚Ä¢ F C ‚âÖ D~ ---note the iso. )

** Of basis vectors
If you‚Äôve ever studied abstract algebra ---the math with vector spaces--- then you may recall that
a collection of vectors ‚Ñ¨ is called a ‚Äòbasis‚Äô if every vector can be written as a linear
combination of these vectors: For any vector $v$, there are scalars $c‚ÇÅ, ‚Ä¶, c‚Çô$ and vectors
$b‚ÇÅ, ‚Ä¶, b‚Çô$ in ‚Ñ¨ with $v \;=\; c‚ÇÅ¬∑b‚ÇÅ + ‚ãØ + c‚Çô¬∑b‚Çô$. That is, a basis is a collection of ‚Äòbuilding
blocks‚Äô for the vector space. Then any function $f$ between basis sets immediately lifts to a
linear transformation (think vector space morphism) $F$ as follows: Given a vector $v$, since we
have a basis, we can express it as $c‚ÇÅ¬∑b‚ÇÅ + ‚ãØ + c‚Çô¬∑b‚Çô$, now define
$F v \;‚âî\; c‚ÇÅ¬∑(f\, b‚ÇÅ) + ‚ãØ + c‚Çô¬∑(f\, b‚Çô)$. 

Sweet! 

Thus, to define a complicated linear transformation of vector
spaces, it more than suffices to define a plain old simple function of basis sets.
Moreover, by definition, such $F$ maps basis vectors to basis vectors: $f \;=\; Œπ ‚®æ F$ where
$Œπ : ‚Ñ¨ ‚Ü™ ùí±$ is the inclusion that realises basis vectors as just usual vectors in the vector
space ùí±.  *Slogan:* 
/Vector space maps are determined by where they send their basis, and basis-vectors
are preserved./

In the case of ~(List A, ++, [])~ we may consider ~A~ to be a ‚Äòbasis‚Äô of the monoid ---indeed,
every list can be written as a linear combination of elements of ~A~, given list
~[x‚ÇÅ, ‚Ä¶, x‚Çô] : List A~ we have ~[x‚ÇÅ, ‚Ä¶, x‚Çô] = x‚ÇÅ + ‚ãØ + x‚Çô~ where ~x + y ‚âî [x] ++ [y]~.
Reasoning similarly as above, or if you have familiarity with ~foldr , reduce~, we have a *slogan:*
/Monoid homomorphisms from lists are determined by where they send their basis and basis-vectors are preserved./

Now the general case: /$F ‚ä£ U$ is a (free-forgetful) ‚Äòadjunction‚Äô/ means
for functors ‚Äòforget‚Äô $U : ùíû ‚ü∂ ùíÆ$ and ‚Äòfree‚Äô $F : ùíÆ ‚Üí ùíû$, we have that
for a given ùíÆimple-object $S$ there‚Äôs ùíÆimple-map $Œπ : S ‚ü∂_ùíÆ U\,(F\, S)$ ---a way to realise ‚Äòbasis
vectors‚Äô--- such that for any ùíûomplicated-object $C$ and ùíÆimple-maps $œÜ : S ‚ü∂_ùíÆ U\, C$, there is a
unique ùíûomplicated-map $Œ¶ : F\, S ‚ü∂_ùíû C$ that preserves the basis vectors: $œÜ = Œπ ‚®æ U Œ¶$.

By analogy to the previous two cases, we may
consider $U\, X$ to be a ‚Äòbasis‚Äô, and make the *slogan*: 
ùíûomplicated-maps from free objects are
determined by where they send their basis and ‚Äòbasis vectors‚Äô are preserved.

[ In more categorical lingo, one says $Œπ$ is the ‚Äòinsertion of generators‚Äô.
  
  Question: Does the way we took $Œπ$ in the previous graph show that it is a natural
  transformation $Œπ : \Id ‚ü∂ F ‚®æ U$?
  ---The naturality just says that a ‚Äòhomomorphism‚Äô $F f$ on the free object is 
  completely determined by what $f$ does to the generators ;-)
]
 
** Of adjunctions

An adjunction $L ‚ä£ U$, where the ~L~-ower adjoint is from ùíÆ to ùíû and the ~U~-pper adjoint is in
the opposite direction, lends itself to an elemntary interpretation if we consider ùíû 
to be some universe of ùíûomplicated items of study, while ùíÆ to be a universe of ùíÆimple
items of study. Then adjointness implies that given a simple-object $S$ and a complicated-object
$C$, a simple-map $X ‚ü∂ U\, C$ corresponds to a complicated-map $L\, S ‚ü∂ C$. To work with
complicated-maps it is more than enough to work with simple-maps!

Formally this correspondence, saying $F : ùíû ‚ü∂ ùíü$ is adjoint to $G : ùíü ‚ü∂ ùíû$, written $F ‚ä£ G$,
holds precisely when $(F ‚àò X ‚ü∂ Y) \;‚âÖ\; (X ‚ü∂ G ‚àò Y)$ in a functor category:

#+BEGIN_SRC agda
 _‚ä£‚ÇÄ_ : ‚àÄ {i j} {ùíû ùíü : Category {i} {j}} ‚Üí Functor ùíû ùíü ‚Üí Functor ùíü ùíû ‚Üí Set (i ‚äç j)
 _‚ä£‚ÇÄ_ {ùíû = ùíû} {ùíü} F G 
    =
      (F ‚Ä≤ ‚àò X  ‚ü∂‚Çô‚Çê‚Çú Y)  ‚âÖ  (X ‚ü∂‚Çô‚Çê‚Çú G ‚àò Y)  within  Func (ùíû ·µí·µñ ‚äó ùíü) ùíÆeùìâ
   where
     X = Fst ; Y = Snd ; _‚Ä≤ = opify -- only changes types
          
     infix 5 _‚ü∂‚Çô‚Çê‚Çú_
     _‚ü∂‚Çô‚Çê‚Çú_ : ‚àÄ {i j} {ùíú : Category {i} {j}} ‚Üí
            Functor (ùíû ·µí·µñ ‚äó ùíü) (ùíú ·µí·µñ) ‚Üí Functor (ùíû ·µí·µñ ‚äó ùíü) ùíú ‚Üí Functor (ùíû ·µí·µñ ‚äó ùíü) ùíÆeùìâ
     _‚ü∂‚Çô‚Çê‚Çú_ {i} {j} {ùíú} = pointwise (Hom {i} {j} {ùíú})
#+END_SRC
Note that if we use Agda's built-in rewrite mechanism to add the rule,
#+BEGIN_EXAMPLE
{ùíû ùíü : Category {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ}} ‚Üí Functor (ùíû ·µí·µñ) (ùíü ·µí·µñ) ‚â° Functor ùíû ùíü
#+END_EXAMPLE
then we might be able to get away without using ~opify~.

Anyhow, this says for any objects $X$ and $Y$, the collection of morphisms $(F\, A ‚ü∂ B)$ 
is isomorphic to the collection $(A ‚ü∂ G\, B)$ and naturally so in $A$ and $B$.

Unfolding it, we have
#+BEGIN_SRC agda
 record _‚ä£_ {i j i‚Äô j‚Äô} {ùíû : Category {i} {j}} {ùíü : Category {i‚Äô} {j‚Äô}} 
        (F : Functor ùíû ùíü) (G : Functor ùíü ùíû)
        : Set (j‚Äô ‚äç i‚Äô ‚äç j ‚äç i) where

   open Category ùíü renaming (_‚®æ_ to _‚®æ‚ÇÇ_)
   open Category ùíû renaming (_‚®æ_ to _‚®æ‚ÇÅ_)
   field
     -- ‚Äòleft-adjunct‚Äô  L ‚âà ‚åä  and  ‚Äòright-adjunct‚Äô  r ‚âà ‚åà
     ‚åä_‚åã : ‚àÄ {X Y} ‚Üí   obj F X ‚ü∂ Y ‚à∂ ùíü   ‚Üí   X ‚ü∂ obj G Y ‚à∂ ùíû
     ‚åà_‚åâ : ‚àÄ {X Y} ‚Üí   X ‚ü∂ obj G Y ‚à∂ ùíû   ‚Üí   obj F X ‚ü∂ Y ‚à∂ ùíü

     -- Adjuncts are inverse operations
     lid : ‚àÄ {X Y} {d : obj F X ‚ü∂ Y ‚à∂ ùíü} ‚Üí ‚åà ‚åä d ‚åã ‚åâ ‚â° d
     rid : ‚àÄ {X Y} {c : X ‚ü∂ obj G Y ‚à∂ ùíû} ‚Üí ‚åä ‚åà c ‚åâ ‚åã ‚â° c

     -- That for a fixed argument, are natural transformations between Hom functors
     lfusion : ‚àÄ {A B C D} {f : A ‚ü∂ B ‚à∂ ùíû} {œà : obj F B ‚ü∂ C ‚à∂ ùíü} {g : C ‚ü∂ D ‚à∂ ùíü}
             ‚Üí  ‚åä mor F f ‚®æ‚ÇÇ œà ‚®æ‚ÇÇ g ‚åã  ‚â°  f ‚®æ‚ÇÅ ‚åä œà ‚åã ‚®æ‚ÇÅ mor G g
     rfusion : ‚àÄ {A B C D} {f : A ‚ü∂ B ‚à∂ ùíû} {œà : B ‚ü∂ obj G C ‚à∂ ùíû} {g : C ‚ü∂ D ‚à∂ ùíü}
             ‚Üí  ‚åà f ‚®æ‚ÇÅ œà ‚®æ‚ÇÅ mor G g ‚åâ  ‚â°  mor F f ‚®æ‚ÇÇ ‚åà œà ‚åâ ‚®æ‚ÇÇ g
#+END_SRC

# It is interesting to note that here if we omit the types of ~A, B, C, D~ in ~rfusion~
# they can be inffered but that takes too much time for my taste, so I've annotated the types everywhere.
# The more likely to be more costly in terms of resolution time is the composition operation.

This is easier for verifying an adjunction, while the former is easier for remembering and understanding what an adjunction actually is.

:RecallingTypes:
#+BEGIN_EXAMPLE
  Hom : {ùíû : Category {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ} } ‚Üí Functor (ùíû ·µí·µñ ‚äó ùíû) ùíÆeùìâ
  Y : ‚àÄ {ùíû ùíü} ‚Üí Functor (ùíû ‚äó ùíü) ùíü
  X : ‚àÄ {ùíû ùíü} ‚Üí Functor (ùíû ‚äó ùíü) ùíû
   pointwise : ‚àÄ {ùíû ùí≥ ùí¥ : Category {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ}} {i j} {ùíü : Category {i} {j}}
   (_‚äï_ : Functor (ùí≥ ‚äó ùí¥) ùíü) (F : Functor ùíû ùí≥) (G : Functor ùíû ùí¥) ‚Üí Functor ùíû ùíü

  Hom {ùíú} : ùíú ·µí·µñ ‚äó ùíú ‚ü∂ ùíÆeùìâ
  F : ùíû ·µí·µñ ‚ü∂ ùíü
  X : ùíû ·µí·µñ √ó ùíü ‚ü∂ ùíû ·µí·µñ
  X ‚®æ F : ùíû ·µí·µñ √ó ùíü ‚ü∂ ùíü
  Y : ùíû ·µí·µñ √ó ùíü ‚ü∂ ùíü
#+END_EXAMPLE
:End:

As the slogan goes ‚Äòadjunctions are everywhere‚Äô.
They can be said to capture the notions of optimization and efficiency, but also that of simplicity.

For example, the supremum of a function is defined to be an upper bound of its image set and the least such bound.
Formally, this definition carries a few quantifiers and so a bit lengthy.
More elegantly, we can say the supremum operation is left-adjoint to the constant function: \[ \mathsf{sup} ‚ä£ ùí¶ \]
which means \[ ‚àÄ z ‚Ä¢\qquad \mathsf{sup}\, f \,‚â§\, z \quad‚áî\quad f \overset{.}{‚â§} ùí¶\, z\] 
Where $ùí¶\, x\, y \,=\, x$ and the $\overset{.}{‚â§}$ on the right is the point-wise ordering on functions.
This formulation of supremum is not only shorter to write but easier to use in calculational proofs.

For the efficiency bit, recall that it is efficient to specify a ùíÆimple-map, then use the adjuction, to obtain
a ùíûomplicated-map. Recall in the last paragraph how we define the super complicated notion of supremum of a function
in terms of the most elementary constant function!

Adjunctions over poset categories are called ‚ÄòGalois connections‚Äô and a good wealth of
material on them can be found in nearly any writing by [[http://www.cs.nott.ac.uk/~psarb2/papers/papers.html][Backhouse et. al.]],
while a very accessible introduction is by [[http://www.cs.nott.ac.uk/~psarb2/MPC/galois.ps.gz][Aarts]],
and there is also an Agda mechanisation by [[http://relmics.mcmaster.ca/RATH-Agda/AContext-2.1.pdf][Kahl & Al-hassy]].

Regarding forgetful functors:
Generally, but not always, forgetful functors are faithful and have left adjoints
---because the notion of ‚Äòforget‚Äô ought to have a corresponding notion of ‚Äòfree‚Äô.
An exception to this is the category of fields, which has a forgetful functor to the
category of sets with no left adjoint. 
# [Source: Wikipedia]
 
** Adjunctions and Representable Functors

Another awesome thing about adjunctions ~L ‚ä£ U~ is that they give us ‚Äòrepresentable functors‚Äô,
  a.k.a. ‚Äòthe best kind of functors‚Äô, when terminal objects exist.

  - An object ~ùüô~ is ‚Äòterminal‚Äô if for any object ~A~ there is a unique morphism ~! {A} : A ‚ü∂ ùüô~. 
    In ùíÆ‚ÑØùìâ we have ~(A ‚ü∂ ùüô) ‚âÖ ùüô~ and ~(ùüô ‚ü∂ A) ‚âÖ A~. 

  - Specialising the adjunction, where ~U : ùíû ‚ü∂ ùíÆeùìâ~, to
    a given set ~A~ and ~ùüô~ we obtain ~(L ùüô ‚ü∂ A) ‚âÖ (ùüô ‚ü∂ U A) ‚âÖ U A~ and so one says
    ‚Äò ~U~ is represented by ~L ùüô~ ‚Äô. 

  - In particular, if ùíû is built on ùíÆ‚ÑØùìâ by adding some structure
    and we are interested in utilising the elements of an object ~A~ 
    then it suffices to utilise the maps ~L ùüô ‚ü∂ A~.
  
In the case of a free-forgetful adjunction, this says that 
  /a forgetful functor is represented by the free object with generator ~ùüô~./
  
For example, for monoids the one-point monoid is the terminal object: ~ùüô ‚âî ({*}, ‚äï, *)~ with ~x ‚äï y ‚âî ‚ãÜ~.
Then every monoid-homomorphism from ~ùüô~ just picks out an element of the carrier of a monoid and so
~(ùüô ‚ü∂ M) ‚âÖ ùí∞ M~ where ~ùí∞~ is the forgetful functor for monoids mentioned in the introduction.

** Concluding remarks
A final note about ‚Äòfree objects‚Äô ---arising from an adjoint to a forgetful functor.

*‚Äò‚ÄòThe free object is generic‚Äô‚Äô*: The only truths provable for the free
object are precisely those that hold for every complicated-object.

(Begin squinting eyes)
\\
This follows from the
definition of adjunction which says we can construct a unique morphism between complicated-objects
from a simple-map and by naturality we may transport any proof for the free object to any
complicated object.
\\
(Feel ‚Äòfree‚Äô to stop squinting your eyes)
 

For futher reading consider reading the adjoint article at [[http://www.comicbooklibrary.org/articles/Left_adjoint][the comic book library]]
and for more on the adjective ‚Äòforgetful‚Äô see [[https://ncatlab.org/nlab/show/forgetful+functor][ncatlab]] or [[http://mathworld.wolfram.com/ForgetfulFunctor.html][mathworld]]
A nice list of common free objects can be found on [[https://en.wikipedia.org/wiki/Free_object#List_of_free_objects][wikipedia]].

# ‚ü¶ Challenge; true or false: For forgetful $U : ùíû ‚ü∂ ùíÆ‚ÑØùìâ$, 
# a free functor exists when ùíû is a monad category over ùíÆ‚ÑØùìâ? ‚üß

You might be asking,
 /musa, when am I ever going to encounter this in daily life? In a popular setting?/ 
This concept is everywhere, even inclusions as mentioned earlier are an
instance. For the second question, enjoy listening to
[[https://www.youtube.com/watch?v=BipvGD-LCjU][this lovely musical group]] --they use the words ‚Äòforgetful functors‚Äô ;)

The remainder of this document can be seen as one fully-worked out example of constructing a
free functor for the forgetful ùí∞ defined above from ùíûùí∂ùìâ to ùí¢ùìáùí∂ùìÖùíΩ.

** COMMENT Free first-order logics                               :Abandoned:

#+BEGIN_EXAMPLE
module RSD where

  data ùüô : Set where ‚ãÜ : ùüô

  open import Data.Vec renaming (_‚à∑_ to _,,_) -- , already in use for products :/

  data Term (ùíÆ : Signature) (Carrier : Set) (Var : Set) : Set where
    var : Var ‚Üí Term ùíÆ Carrier Var
    con : Carrier ‚Üí Term ùíÆ Carrier Var
    app : (i : Fin ar) ‚Üí Vec (Term ùíÆ Carrier Var) (lookup i ar) ‚Üí Term ùíÆ Carrier Var
    -- ~app i [t‚ÇÅ, ‚Ä¶, t‚Çñ]~ read as: apply i-th function-symbol ~f·µ¢~ to ~k = arity (f·µ¢)~ terms ~t‚ÇÅ, ‚Ä¶, t‚Çñ~

  infix 10 _‚âà_
  _‚âà_ : {A B : Set} ‚Üí A ‚Üí B ‚Üí A √ó B
  _‚âà_ = _,_
  
  record Logic (ùíÆ : Signature) (Carrier : Set) (Var : Set) : Set where
    field
      #Eqns : ‚Ñï
      eqns : Vec ((Term ùíÆ Carrier Var) √ó (Term ùíÆ Carrier Var)) #Eqns

  -- use integers as varaibles
  MyVars = ‚Ñï
  x y z : MyVars
  x = 0
  y = 1
  z = 2
  -- alternative is to parameterise module by a universe of variables.

  MonoidThry : {X : Set} ‚Üí Logic MonSig X MyVars
  MonoidThry {X} = record { #Eqns = 3 ;
    eqns = Œµ ¬∑ var x ‚âà var x
      ,, var x ¬∑ Œµ ‚âà var x
      ,, (var x ¬∑ var y) ¬∑ var z ‚âà var x ¬∑ (var y ¬∑ var z)
      ,, [] }
    where
      -- the function symbols
      u = from‚Ñï‚â§ {0} {2} (s‚â§s z‚â§n)
      m = from‚Ñï‚â§ {1} {2} (s‚â§s (s‚â§s z‚â§n))

      -- conventional monoid notation
      Œµ : Term MonSig X MyVars
      Œµ = app u []
      _¬∑_ : (l r : Term MonSig X MyVars) ‚Üí Term MonSig X MyVars
      _¬∑_ = Œª l r ‚Üí app m (l ,, r ,, [])
#+END_EXAMPLE
* Designing Paths
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

# Path definition

#+BEGIN_CENTER
/The ‚Äúright‚Äù definition is hard to obtain!/
#+END_CENTER

** Intro :ignore:

We can now define a ‚Äòpath‚Äô of length ~n~ in a graph ~G~ to be a graph-map
~[ n ] ‚ü∂ G~.

#+BEGIN_SRC agda
Path‚ÇÄ : ‚Ñï ‚Üí Graph‚ÇÄ ‚Üí Set (‚Ñìsuc ‚Ñì‚ÇÄ)
Path‚ÇÄ n G = [ n ]‚ÇÄ ùí¢‚ü∂‚ÇÄ G
#+END_SRC

Unfolding the definition of graph-morphisms, this just says that a path of length ~n~
consists of a sequence ~[v‚ÇÄ, v‚ÇÅ, v‚ÇÇ,  ‚Ä¶, v‚Çô]~ of vertices of ~G~ and a sequence ~[e‚ÇÄ, e‚ÇÅ, ‚Ä¶, e‚Çô‚Çã‚ÇÅ]~ 
of edges of ~G~ with typing ~e·µ¢ : v·µ¢ ‚ü∂ v·µ¢‚Çä‚ÇÅ~.

The definition is pretty slick! However, as the name suggests, perhaps we can concatenate paths
and it‚Äôs not at all clear how to do this for the vertex- and edge- morphisms of the graph-maps
involved, whereas it‚Äôs immediately clear how to do this with sequences: We just concatenate the
sequences and ensure the result is coherent.

Since the vertices can be obtained from the edges via ~src~ and ~tgt~, we can dispense with them
and use the definition as outlined above.

#+BEGIN_SRC agda
open import Data.Vec using (Vec ; lookup)

record Path‚ÇÅ (n : ‚Ñï) (G : Graph‚ÇÄ) : Set (‚Ñìsuc ‚Ñì‚ÇÄ) where
  open Graph‚ÇÄ
  field
    edges     : Vec (E G) (suc n)
    coherency : {i : Fin n} ‚Üí tgt G (lookup (` i) edges) ‚â° src G (lookup (fsuc i) edges)
#+END_SRC
That is, edges ~[e‚ÇÄ, ‚Ä¶, e‚Çô]~ with coherency ~tgt e·µ¢ ‚â° src e·µ¢‚Çä‚ÇÅ~.

Great, we‚Äôve cut the definition of ~Path‚ÇÄ~ in half but that fact that we get a raw list of edges
and then need coherency to ensure that it is a well-formed path is still not terribly lovely.
After all, we‚Äôre in Agda, we‚Äôre among kings, we should be able to form the list in such a way that
the end result is a path. Let‚Äôs do that!

Enough of this repetition, let us fix a graph ~G~,
#+BEGIN_SRC agda
module Path-definition-2 (G : Graph‚ÇÄ) where
  open Graph‚ÇÄ G

  mutual
    data Path‚ÇÇ : Set where
      _!   : V ‚Üí Path‚ÇÇ
      cons : (v : V) (e : E) (ps : Path‚ÇÇ) (s : v ‚â° src e) (t : tgt e ‚â° head‚ÇÇ ps) ‚Üí Path‚ÇÇ

    head‚ÇÇ : Path‚ÇÇ ‚Üí V
    head‚ÇÇ (v !) = v
    head‚ÇÇ (cons v e p s t) = v
#+END_SRC

Defining paths for the parallel-pair approach to graphs leaves us with the need to carry
proofs around, and this is a tad too clunky in this case. Let's try yet again.

#+BEGIN_SRC agda
module Path-definition-3 (G : Graph) where

  open Graph G

  -- handy dandy syntax
  infixr 5 cons
  syntax cons v ps e = v ‚ü∂[ e ]‚ü∂ ps -- v goes, by e, onto path ps

  -- we want well-formed paths
  mutual
    data Path‚ÇÉ : Set where
      _!   : (v : V) ‚Üí Path‚ÇÉ
      cons : (v : V) (ps : Path‚ÇÉ) (e : v ‚ü∂ head‚ÇÉ ps) ‚Üí Path‚ÇÉ

    head‚ÇÉ : Path‚ÇÉ ‚Üí V
    head‚ÇÉ (v !) = v
    head‚ÇÉ (v ‚ü∂[ e ]‚ü∂ ps) = v

  -- motivation for the syntax declaration above
  example : (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) (e‚ÇÅ : v‚ÇÅ ‚ü∂ v‚ÇÇ) (e‚ÇÇ : v‚ÇÇ ‚ü∂ v‚ÇÉ) ‚Üí Path‚ÇÉ
  example v‚ÇÅ v‚ÇÇ v‚ÇÉ e‚ÇÅ e‚ÇÇ = v‚ÇÅ ‚ü∂[ e‚ÇÅ ]‚ü∂ v‚ÇÇ ‚ü∂[ e‚ÇÇ ]‚ü∂ v‚ÇÉ !

  end‚ÇÉ : Path‚ÇÉ ‚Üí V
  end‚ÇÉ (v !) = v
  end‚ÇÉ (v ‚ü∂[ e ]‚ü∂ ps) = end‚ÇÉ ps

  -- typed paths; squigarrowright
  record _‚áù_ (x y : V) : Set where
    field
      path   : Path‚ÇÉ
      start  : head‚ÇÉ path ‚â° x
      finish : end‚ÇÉ path  ‚â° y
#+END_SRC
This seems great, but there‚Äôs always room for improvement:


- Since the ~cons~ constructor's third argument depends on its first, we must
  use a syntax declaration to get the desired look. Such aesthetic is not only
  pleasing but reminiscent of diagrammatic paths;
  moreover, it‚Äôs guaranteed to be an actual path and not just an
  alternating lists of vertices and edges.
  Using the clunky ~Path‚ÇÇ~, we‚Äôd write
  #+BEGIN_EXAMPLE
  v‚ÇÅ ‚ü∂[ v‚ÇÅ‚âàse‚ÇÅ , e‚ÇÅ , te‚ÇÅ‚âàv‚ÇÇ ]‚ü∂ v‚ÇÇ ‚ü∂[ v‚ÇÇ‚âàse‚ÇÇ , e‚ÇÇ , te‚ÇÇ‚âàv‚ÇÉ ]‚ü∂ v‚ÇÉ !
  where
  syntax cons v e ps s t = v ‚ü∂[ s , e , t ]‚ü∂ ps
#+END_EXAMPLE
  yuck!

  Finally, the syntax-declaration does not make the emacs agda-mode auto-case using
  the syntax, and so I have to write it out by hand, each time I want to use the syntax.

- Again since ~cons~'s third argument depends on the second argument, we need a mutual
  definition to extract the item of the dependence. Perhaps if we embed this item at
  the type level we may avoid the need of an auxiliary mutually-defined function.

- By defining what the start and finish of a path are, we can assign types to it.
  However, this approach is reminiscent of the parallel-pair approach to graphs,
  as in ~Graph‚ÇÄ~, which we argued is less preferable to the typed-approach to graphs.
  Perhaps defining paths with types by default, we can reap the benefits and simplicity
  of the typed-approach to graphs.

#+BEGIN_SRC agda
module TypedPaths (G : Graph) where

  open Graph G hiding(V)
  open Graph   using (V)
  
  data _‚áù_ : V G ‚Üí V G ‚Üí Set where
    _!      : ‚àÄ x ‚Üí x ‚áù x
    _‚ü∂[_]‚ü∂_ : ‚àÄ x {y œâ} (e : x ‚ü∂ y) (ps : y ‚áù œâ) ‚Üí x ‚áù œâ
#+END_SRC

One might think that since we can write
#+BEGIN_EXAMPLE
  src : {x y : V G} (e : x ‚ü∂ y) ‚Üí V G
  src {x} {y} e = x
#+END_EXAMPLE
we can again ignore vertices and it suffices to just keep a coherent list of edges.
Then what is an empty path at a vertex? This‚Äô enough to keep vertices around
---moreover, the ensuing terms look like diagrammatic paths! Cool!

#+BEGIN_CENTER
Finding this definitional /form/ was a major hurdle in this endeavour.
#+END_CENTER

** Aside: An Adjunction between ùíÆ‚ÑØùìâ and ùíûùí∂ùìâ

With paths in hand, we can now consider a neat sequence of [[https://math.stackexchange.com/questions/1640298/coforgetful-functors][exercises]] :-)

0. Show that graphmaps preserve paths: ~(f : G ‚ü∂ H)  ‚Üí x ‚áù y ‚Üí f·µ• x ‚áù f·µ• y~;
   this is nothing more than type-preservation for ~f~ to be a functor ~ùí´G ‚ü∂ ùí´H~ ;)
   
   Hint: This is ~lift~ from the next section.

1. Define
  #+BEGIN_EXAMPLE
a connected b  ‚â°  (a ‚áù b) ‚äé (b ‚áù a)  --  path ‚Äúbetween‚Äù a and b; not ‚Äòfrom a to b‚Äô.
#+END_EXAMPLE

2. This is an equivalence relation whose equivalence classes are called /the connected components of G/;
   denote them by ~ùí¶G~.

3.  For any category ~ùíû~, define ~ùí¶ ùíû ‚âî ùí¶ (ùí∞‚ÇÄ ùíû)~ which is a subcategory of ~ùíû~.

4.  Phrase the connected components subcategory using a universal property,
   thereby avoiding the need for quotient types.

5. Since graphmaps preserve paths, every graph map can be extended to connected components,
  ~ùí¶f : ùí¶G ‚ü∂ ùí¶H : (connected component of x) ‚Ü¶ (connected component of f·µ• x)~.

7. Hence, we have a functor ~ùí¶ : Graph ‚ü∂ Set~.

8. Then there is a natural transformation ~ùí± ‚ü∂ ùí¶~, where ùí± is the vertices functor.

  Hint: Such a transformation means we can realise vertices as connected components and this suggests
  taking assigning a vertex to the connected-component block that contains it.

  :Solution:

Such a transformation means we can realise vertices as connected components and this suggests
taking ~Œ≤G : ùí±G ‚Üí ùí¶G~ which takes a vertix to the connected-component Œ≤lock that contains it.
Then given graph map ~f : G ‚ü∂ H~,
#+BEGIN_EXAMPLE
  ùí± f ‚®æ Œ≤G
‚â° Œª a ‚Üí the block containing f·µ• a
‚â° Œª a ‚Üí ùí¶f (the block containg a)
‚â° Œ≤H ‚®æ ùí¶f
#+END_EXAMPLE
:End:

  yeah!

Finally, if we let ~ùíü : ùíÆ‚ÑØùìâ ‚Üí ùíûùí∂ùìâ~ be the free category functor that associates each set with
the discrete category over it, then we have ~ùí¶~ is the associated forgetful functor.

:Solution:

Given a set map ~f : S ‚ü∂ ùí¶ C~, this assigns a connected component for each s of S.
Let ~R c~ be a choice of Representative for an equivalence block, then
f can be made iinto a functor by sending each s, now construed as an object, to the ~C~-object
~R (f s)~.

given a functor ~F : ùíü S ‚ü∂ C~, define a set-map that sends each s to the connected component
that contains it, ie ~Œ≤~.

now verify the needed laws.

I saw this someplace on stack exchange for the adjoint to the free category functor.
Anyhow, should consider the intution(?) behind this construction since it‚Äôs not immediately clear
why the connected components, that or cuz is nearly 6 in the morning and i am needs of sleep.

src :: \url{http://math.stackexchange.com/questions/1640298/coforgetful-functors}

:End:

** Equality Combinators for Paths

Here's a handy-dandy combinator for forming certain equality proofs of paths.
#+BEGIN_SRC agda
  -- Preprend preserves path equality
  ‚ü∂-‚â° : ‚àÄ{x y œâ} {e : x ‚ü∂ y} {ps qs : y ‚áù œâ} 
      ‚Üí ps ‚â° qs ‚Üí (x ‚ü∂[ e ]‚ü∂ ps) ‚â° (x ‚ü∂[ e ]‚ü∂ qs)
  ‚ü∂-‚â° {x} {y} {œâ} {e} {ps} {qs} eq = ‚â°-cong (Œª r ‚Üí x ‚ü∂[ e ]‚ü∂ r) eq
#+END_SRC
Less usefully, we leave as exercises:
#+BEGIN_EXAMPLE
  edges : ‚àÄ {x œâ} (p : x ‚áù œâ) ‚Üí List (Œ£ s ‚à∂ V G ‚Ä¢ Œ£ t ‚à∂ V G ‚Ä¢ s ‚ü∂ t)
  edges = {! exercise !}

  path-eq : ‚àÄ {x y} {p q : x ‚áù y} ‚Üí edges p ‚â° edges q ‚Üí p ‚â° q
  path-eq = {! exercise !}
#+END_EXAMPLE
Given time, ~path-eq~ could be rewritten so as to be more easily applicable.
For now, two path equality proofs occur in the document and both are realised by
quick-and-easy induction.

:Solution:
#+BEGIN_SRC agda
  open import Data.List using (List ; [] ; _‚à∑_)
  edges : ‚àÄ {x œâ} (p : x ‚áù œâ) ‚Üí List (Œ£ s ‚à∂ V G ‚Ä¢ Œ£ t ‚à∂ V G ‚Ä¢ s ‚ü∂ t)
  edges {x} (.x !) = []
  edges {x} (.x ‚ü∂[ e ]‚ü∂ ps) = (x , _ , e) ‚à∑ edges ps

  path-eq : ‚àÄ {x y} {p q : x ‚áù y} ‚Üí edges p ‚â° edges q ‚Üí p ‚â° q
  path-eq {x} {p = .x !} {q = .x !} pf = ‚â°-refl
  path-eq {x} {p = .x !} {q = .x ‚ü∂[ e ]‚ü∂ q} ()
  path-eq {x} {p = .x ‚ü∂[ e ]‚ü∂ p} {q = .x !} ()
  path-eq {x} {p = .x ‚ü∂[ e ]‚ü∂ p} {q = .x ‚ü∂[ e‚ÇÅ ]‚ü∂ q} pf with edges p | pf
  path-eq {x} {p = .x ‚ü∂[ e ]‚ü∂ p} {q = .x ‚ü∂[ .e ]‚ü∂ q} pf | .(edges q) | ‚â°-refl = ‚ü∂-‚â° (path-eq (uncons pf))
    where uncons : ‚àÄ{A : Set} {x y : A} {xs ys : List A} ‚Üí x ‚à∑ xs ‚â° y ‚à∑ ys ‚Üí xs ‚â° ys
          uncons {A} {x} {.x} {xs} {.xs} ‚â°-refl = ‚â°-refl
#+END_SRC            
:End:

** Category of paths over a graph

Now we turn back to the problem of [[https://english.stackexchange.com/a/125659/327685][catenating]] two paths.
#+BEGIN_SRC agda
  infixr 5 _++_

  _++_ : ‚àÄ{x y z} ‚Üí x ‚áù y ‚Üí y ‚áù z ‚Üí x ‚áù z
  x ! ++ q           = q                         -- left unit
  (x ‚ü∂[ e ]‚ü∂ p) ++ q = x ‚ü∂[ e ]‚ü∂ (p ++ q)     -- mutual-associativity
#+END_SRC
Notice that the the base case indicate that ~!~ forms a left-unit for ~++~,
while the inductive case says that path-formation associates with path catenation.
Both observations also hold for the definition of list catenation ;-)

If we had not typed our paths, as in ~Path‚ÇÇ~, we would need to carry around a
proof that paths are compatible for concatenation:
#+BEGIN_EXAMPLE
  catenate : (p q : Path) (coh : end p ‚â° head q) ‚Üí Path
  syntax catenate p q compatibility = p ++[ compatibility ] q
#+END_EXAMPLE
Even worse, to show ~p ++[ coh ] q ‚â° p ++[ coh‚Äô ] q~ we need to invoke proof-irrelevance of
identity proofs to obtain ~coh ‚â° coh‚Äô~, each time we want such an equality! Moving the proof
obligation to the type level removes this need.

As can be seen, being type-less is a terrible ordeal.

Just as the first clause of ~_++_~ indicates ~_!~ is a left unit,
#+BEGIN_SRC agda
  leftId : ‚àÄ {x y} {p : x ‚áù y} ‚Üí x ! ++ p ‚â° p
  leftId = ‚â°-refl
#+END_SRC
Is it also a right identity?
#+BEGIN_SRC agda
  rightId : ‚àÄ {x y} {p : x ‚áù y} ‚Üí p ++ y ! ‚â° p
  rightId {x} {.x} {.x !} = ‚â°-refl
  rightId {x} {y } {.x ‚ü∂[ e ]‚ü∂ ps} = ‚â°-cong (Œª q ‚Üí x ‚ü∂[ e ]‚ü∂ q) rightId
#+END_SRC

Is this operation associative?
#+BEGIN_SRC agda
  assoc : ‚àÄ{x y z œâ} {p : x ‚áù y} {q : y ‚áù z} {r : z ‚áù œâ} 
        ‚Üí (p ++ q) ++ r ‚â° p ++ (q ++ r)
  assoc {x} {p = .x !} = ‚â°-refl
  assoc {x} {p = .x ‚ü∂[ e ]‚ü∂ ps} {q} {r} = ‚â°-cong (Œª s ‚Üí x ‚ü∂[ e ]‚ü∂ s) (assoc {p = ps})
#+END_SRC
 
Hence, we‚Äôve shown that the paths over a graph ~G~ constitute a category! Let‚Äôs call it ~ùí´ G~.

** The ùí´ath to freedom
In the last section, we showed that the paths over a graph make a category,
#+BEGIN_SRC agda
ùí´‚ÇÄ : Graph ‚Üí Category
ùí´‚ÇÄ G = let open TypedPaths G in
    record
      { Obj     = Graph.V G
      ; _‚ü∂_     = _‚áù_
      ; _‚®æ_     = _++_
      ; assoc   = Œª {x y z œâ p q r} ‚Üí assoc {p = p}
      ; Id      = Œª {x} ‚Üí x !
      ; leftId  = leftId
      ; rightId = rightId
      }
#+END_SRC

Can we make ~ùí´~ into a functor by defining it on morphisms?
That is, to lift graph-maps to category-maps, i.e., functors.

#+BEGIN_SRC agda
ùí´‚ÇÅ : ‚àÄ {G H} ‚Üí GraphMap G H ‚Üí Functor (ùí´‚ÇÄ G) (ùí´‚ÇÄ H)
ùí´‚ÇÅ {G} {H} f = record 
    { obj  = ver f 
    ; mor  = amore
    ; id   = ‚â°-refl 
    ; comp = Œª {x} {y} {z} {p} ‚Üí comp {p = p} 
    }
    where
      open TypedPaths ‚¶É...‚¶Ñ public
      instance G' : Graph ; G' = G
               H' : Graph ; H' = H

      amore : {x y : Graph.V G} ‚Üí  x ‚áù y ‚Üí (ver f x) ‚áù (ver f y)
      amore (x !) = ver f x !
      amore (x ‚ü∂[ e ]‚ü∂ p) = ver f x ‚ü∂[ edge f e ]‚ü∂ amore p

      comp : {x y z : Graph.V G} {p : x ‚áù y} {q : y ‚áù z} 
          ‚Üí  amore (p ++ q)  ‚â°  amore p ++ amore q
      comp {x} {p = .x !} = ‚â°-refl    -- since ! is left unit of ++
      comp {x} {p = .x ‚ü∂[ e ]‚ü∂ ps} = ‚ü∂-‚â° (comp {p = ps})
#+END_SRC
Sweet!

With these two together, we have that ~ùí´~ is a functor.

#+BEGIN_SRC agda
ùí´ : Functor ùí¢ùìáùí∂ùìÖùíΩ ùíûùí∂ùìâ
ùí´ = record { obj   = ùí´‚ÇÄ 
            ; mor  = ùí´‚ÇÅ 
            ; id   = Œª {G} ‚Üí funcext ‚â°-refl (id ‚¶É G ‚¶Ñ) 
            ; comp = funcext ‚â°-refl comp 
            }
    where
      open TypedPaths ‚¶É...‚¶Ñ
      open Category   ‚¶É...‚¶Ñ

      module ùíûùí∂ùìâ   = Category ùíûùí∂ùìâ
      module ùí¢ùìáùí∂ùìÖùíΩ = Category ùí¢ùìáùí∂ùìÖùíΩ

      id : ‚àÄ ‚¶É G ‚¶Ñ {x y} {p : x ‚áù y} 
        ‚Üí   mor (ùíûùí∂ùìâ.Id {ùí´‚ÇÄ G}) p  ‚â°  mor (ùí´‚ÇÅ (ùí¢ùìáùí∂ùìÖùíΩ.Id)) p
      id {p = x !} = ‚â°-refl
      id {p = x ‚ü∂[ e ]‚ü∂ ps} = ‚ü∂-‚â° (id {p = ps})

      comp : {G H K : Graph} {f : GraphMap G H} {g : GraphMap H K}
           ‚Üí {x y : Graph.V G} {p : TypedPaths._‚áù_ G x y}
           ‚Üí  mor (ùí´‚ÇÅ f ùíûùí∂ùìâ.‚®æ ùí´‚ÇÅ g) p  ‚â°  mor (ùí´‚ÇÅ (f ùí¢ùìáùí∂ùìÖùíΩ.‚®æ g)) p
      comp {p = x !} = ‚â°-refl
      comp {p = x ‚ü∂[ e ]‚ü∂ ps} = ‚ü∂-‚â° (comp {p = ps})
#+END_SRC

It seemed prudent in this case to explicitly delimit where the compositions lives
---this is for clarity, since Agda can quickly resolve the appropriate category instances.

Exercise: Show that we have a natural transformation ~Id ‚ü∂ ùí∞ ‚àò ùí´~.
* Free at last 
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

** Intro                                                            :ignore:
#+BEGIN_QUOTE 
Free at last, free at last, thank God almighty we are free at last.

-- Martin Luther King Jr.
#
# Martin Luther King Jr., I Have a Dream: Writings and Speeches That Changed the World
#+END_QUOTE

Recall why lists give the ‚Äòfree monoid‚Äô: We can embed a type $A$ into $\List A$ by the map $[\_{}]$,
and we can lift any map $f : A ‚ü∂ B$ to a monoid map
\[\foldr \; (Œª a b ‚Üí f\, a ‚äï b)\; e \;:\; (\List A ,\_{}++\_{} , []) \,‚ü∂\, (B,\_{}‚äï\_{} , e)\]
I.e., $[a‚ÇÅ, ‚Ä¶, a‚Çñ] \;‚Ü¶\; f\, a‚ÇÅ ‚äï ‚ãØ ‚äï f\, a‚Çñ$. Moreover
this ‚Äòpreserves the basis‚Äô $A$
-- i.e., $‚àÄ a ‚Ä¢\; f\, a \,=\, \foldr \,f \,e \, [ a ]$ --
and this lifted map is unique.

Likewise, let us show that $ùí´G$ is the ‚Äòfree category‚Äô over the graph $G$.
This amounts to saying that there is a way, a graph-map, say $Œπ$, that embeds $G$ into $ùí´G$,
and a way to lift any graph-map $f \,:\, G \,ùí¢‚ü∂\, ùí∞‚ÇÄ ùíû$ to a functor $\mathsf{lift}\, f : ùí´G ‚ü∂ ùíû$
that ‚Äòpreserves the basis‚Äô $f \;=\; Œπ ‚®æ ùí∞‚ÇÅ (\mathsf{lift}\, f)$ and uniquely so.

Let‚Äôs begin!

#+BEGIN_SRC agda
module freedom (G : Obj ùí¢ùìáùí∂ùìÖùíΩ) {ùíû : Category {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ} } where

  open TypedPaths G using (_! ; _‚ü∂[_]‚ü∂_ ;  _‚áù_ ; _++_)
  open Category ‚¶É...‚¶Ñ

  module ùí¢ùìáùí∂ùìÖùíΩ = Category ùí¢ùìáùí∂ùìÖùíΩ
  module ùíÆ‚ÑØùìâ = Category (ùíÆeùìâ {‚Ñì‚ÇÄ})
  module ùíû = Category ùíû
  instance ùíû‚Ä≤ : Category ; ùíû‚Ä≤ = ùíû
#+END_SRC

** Defining the needed operations
The only obvious, and most natural, way to embed a graph into its ‚Äògraph of paths‚Äô is to send
vertices to vertices and edges to paths of length 1.

#+BEGIN_SRC agda
  Œπ : G ‚ü∂ ùí∞‚ÇÄ (ùí´‚ÇÄ G)
  Œπ = record { ver = Id ; edge = Œª {x} {y} e  ‚Üí  x ‚ü∂[ e ]‚ü∂ (y !) }
#+END_SRC

Given a graph map $f$, following the list-analagoue of $[a‚ÇÅ, ‚Ä¶, a‚Çñ] \;‚Ü¶\; f\, a‚ÇÅ ‚äï ‚ãØ ‚äï f\, a‚Çñ$
we attempt to lift the map onto paths by taking the edges $e‚ÇÅ, ‚Ä¶, e‚Çñ$ of a path
to a morphism $\edge\, f\, e‚ÇÅ ‚®æ ‚ãØ ‚®æ \edge\, f\, e‚Çñ$.
That is, a path of the form
\[x_0 \xrightarrow{e_1} x_1 \xrightarrow{e_2} x_2 \xrightarrow{e_3} ‚ãØ \xrightarrow{e_k} x_k \]
Is lifted to the composition of morphisms
\[\mathsf{ver}\, f\, x_0 \xrightarrow{\edge\, f\, e_1} 
   \mathsf{ver}\, f\, x_1 \xrightarrow{\edge\, f\, e_2} 
   \mathsf{ver}\, f\, x_2 \xrightarrow{\edge\, f\, e_3} ‚ãØ \xrightarrow{\edge\, f\, e_k} 
   \mathsf{ver}\, f\, x_k \]

Of course, we then need to verify that this construction is indeed
functorial.

#+BEGIN_SRC agda
  lift : G ‚ü∂ ùí∞‚ÇÄ ùíû  ‚Üí  ùí´‚ÇÄ G ‚ü∂ ùíû
  lift f = record 
     { obj  = Œª v ‚Üí ver f v -- Only way to obtain an object of ùíû; hope it works!
     ; mor  = fmap 
     ; id   = ‚â°-refl 
     ; comp = Œª {x y z p q} ‚Üí proof {x} {y} {z} {p} {q}
     }
     where
          fmap : ‚àÄ {x y} ‚Üí x ‚áù y ‚Üí ver f x ùíû.‚ü∂ ver f y
          fmap (y !) = ùíû.Id
          fmap (x ‚ü∂[ e ]‚ü∂ p) = edge f e ùíû.‚®æ fmap p

          -- homomorphism property
          proof : ‚àÄ{x y z} {p : x ‚áù y} {q : y ‚áù z} ‚Üí fmap (p ++ q) ‚â° fmap p ùíû.‚®æ fmap q
          proof {p = ._ !} = ‚â°-sym ùíû.leftId
          proof {p = ._ ‚ü∂[ e ]‚ü∂ ps} =  ‚â°-cong (Œª m ‚Üí edge f e ùíû.‚®æ m) (proof {p = ps}) 
                                     ‚ü®‚â°‚â°‚ü© ‚â°-sym assoc
                                     -- Exercise: Rewrite this calculationally!
#+END_SRC

Now we have the embedding and the lifting, it remains to show that the aforementioned
‚Äòpreserves basis‚Äô property holds as does uniqueness.

** Realising the proof-obligations

Let's begin with the ‚Äòbasis preservation‚Äô property:

#+BEGIN_SRC agda
  property : ‚àÄ{f : G ‚ü∂ ùí∞‚ÇÄ ùíû}  ‚Üí  f  ‚â°  (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ (lift f))
  property {f} = graphmapext
    -- Proving: ‚àÄ {v} ‚Üí ver f v ‚â° ver (Œπ ùíû.‚®æ ùí∞‚ÇÅ (lift f)) v
    -- by starting at the complicated side and simplifying
    (Œª {v} ‚Üí ‚â°-sym (begin
              ver (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ (lift f)) v
            ‚â°‚ü®" definition of ver on composition "‚ü©‚Ä≤
              (ver Œπ ùíÆ‚ÑØùìâ.‚®æ ver (ùí∞‚ÇÅ (lift f))) v
            ‚â°‚ü®" definition of ùí∞‚ÇÅ says: ver (ùí∞‚ÇÅ F) = obj F "‚ü©‚Ä≤ 
              (ver Œπ ùíÆ‚ÑØùìâ.‚®æ obj (lift f)) v
            ‚â°‚ü®" definition of lift says: obj (lift f) = ver f "‚ü©‚Ä≤
              (ver Œπ ùíÆ‚ÑØùìâ.‚®æ ver f) v
            ‚â°‚ü®" definition of Œπ on vertices is identity "‚ü©‚Ä≤
              ver f v
            ‚àé))
    
    -- Proving: edge (Œπ ‚®æg ùí∞‚ÇÅ (lift f)) e ‚â° edge f e
    (Œª {x} {y} {e} ‚Üí begin
               edge (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ (lift f)) e
             ‚â°‚ü®" definition of edge on composition "‚ü©‚Ä≤
               (edge Œπ ùíÆ‚ÑØùìâ.‚®æ edge (ùí∞‚ÇÅ (lift f))) e
             ‚â°‚ü®" definition of ùí∞ says: edge (ùí∞‚ÇÅ F) = mor F "‚ü©‚Ä≤
               (edge Œπ ùíÆ‚ÑØùìâ.‚®æ mor (lift f)) e
             ‚â°‚ü®" definition chasing gives: mor (lift f) (edge Œπ e) = edge f e ‚®æ Id "‚ü©‚Ä≤
               edge f e ùíû.‚®æ Id
             ‚â°‚ü® ùíû.rightId ‚ü©
               edge f e
             ‚àé)
#+END_SRC

Observe that we simply chased definitions and as such ~graphmapext ‚â°-refl rightId~ suffices as a proof,
but it‚Äôs not terribly clear why, for human consumption, and so we choose to elaborate with the
detail.

Finally, it remains to show that there is a unique way to preserve ‚Äòbasis‚Äô:

#+BEGIN_SRC agda 
  uniqueness : ‚àÄ{f : G ‚ü∂ ùí∞‚ÇÄ ùíû} {F : ùí´‚ÇÄ G ‚ü∂ ùíû} ‚Üí f ‚â° (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F) ‚Üí lift f ‚â° F
  uniqueness {.(Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)} {F} ‚â°-refl = funcext ‚â°-refl (‚â°-sym pf)
    where
      pf : ‚àÄ{x y} {p : x ‚áù y} ‚Üí  mor (lift (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)) p  ‚â°  mor F p
      pf {x} {.x} {p = .x !} = ‚â°-sym (Functor.id F)
      pf {x} {y} {p = .x ‚ü∂[ e ]‚ü∂ ps} = begin
         mor (lift (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)) (x ‚ü∂[ e ]‚ü∂ ps)
       ‚â°‚ü®" definition of mor on lift, the inductive clause "‚ü©‚Ä≤       
         edge (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F) e ùíû.‚®æ mor (lift (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)) ps
       ‚â°‚ü® ‚â°-cong‚ÇÇ ùíû._‚®æ_ ‚â°-refl (pf {p = ps}) ‚ü© -- inductive step
         edge (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F) e ùíû.‚®æ mor F ps
       ‚â°‚ü®" definition of edge says it preserves composition "‚ü©‚Ä≤
         (edge Œπ ùíÆ‚ÑØùìâ.‚®æ edge (ùí∞‚ÇÅ F)) e ùíû.‚®æ mor F ps
       ‚â°‚ü®" definition of ùí∞ gives: edge (ùí∞‚ÇÅ F) = mor F "‚ü©‚Ä≤
         (edge Œπ ùíÆ‚ÑØùìâ.‚®æ mor F) e ùíû.‚®æ mor F ps
       ‚â°‚ü®" definition of functional composition ùíÆ‚ÑØùìâ "‚ü©‚Ä≤
          mor F (edge Œπ e) ùíû.‚®æ mor F ps
       ‚â°‚ü® ‚â°-sym (Functor.comp F) {- i.e., functors preserve composition -} ‚ü©
          mor F (edge Œπ e ++ ps)
       ‚â°‚ü®" definition of embedding and concatenation "‚ü©‚Ä≤
         mor F (x ‚ü∂[ e ]‚ü∂ ps)
       ‚àé
#+END_SRC

Challenge:
Define graph-map equality ‚Äò‚âàg‚Äô by /extensionality/ --two graph maps are equal iff
their vertex /and/ edge maps are extensionally equal. This is far more relaxed
than using propositional equality ‚Äò‚â°‚Äô. Now show the stronger uniqueness claim:
#+BEGIN_EXAMPLE
‚àÄ{f : G ‚ü∂ ùí∞‚ÇÄ ùíû} {F : ùí´‚ÇÄ G ‚ü∂ ùíû}   ‚Üí   f  ‚âàg  (Œπ ‚®æ ùí∞‚ÇÅ F)   ‚Üí   lift f  ‚â°  F
#+END_EXAMPLE

:Solution:
Below is the uniqueness proof before making postulates.

Before postulating extensionality, I used the following notions.

To talk of equations, we need appropriate equalities.

#+BEGIN_SRC agda
  _‚âàg_ : ‚àÄ{G H : Graph} (f g : G ‚ü∂ H) ‚Üí Set
  _‚âàg_ {G} {H} f g = Œ£ veq ‚à∂ (‚àÄ {v} ‚Üí ver f v ‚â° ver g v) ‚Ä¢
    (‚àÄ {x y e} ‚Üí edge g {x} {y} e ‚â° ‚â°-subst‚ÇÇ (Œª a b ‚Üí Graph._‚ü∂_ H a b) veq veq (edge f {x} {y} e))

  _‚âã_ : ‚àÄ{ùíû ùíü : Category} (f g : ùíû ‚ü∂ ùíü) ‚Üí Set
  F ‚âã G = ùí∞‚ÇÅ F ‚âàg ùí∞‚ÇÅ G   -- proofs (x , y) now replaced with: funcext x y
#+END_SRC

Spelled-out:
#+BEGIN_EXAMPLE
_‚âã_ {G} {H} f g = Œ£ veq ‚à∂ (‚àÄ {v} ‚Üí obj f v ‚â° obj g v) ‚Ä¢
  (‚àÄ {x y e} ‚Üí mor g {x} {y} e ‚â° ‚â°-subst‚ÇÇ (Œª a b ‚Üí Category._‚ü∂_ H a b) veq veq (mor f e))
#+END_EXAMPLE

#+BEGIN_SRC agda
-- Since equality of functors makes use of ~subst~s all over the place, we will need
-- a lemma about how ~subst~ factors/distributes over an operator composition.
  subst-dist : ‚àÄ {S : Set} {v v‚Äô : S ‚Üí Category.Obj ùíû} (veq : ‚àÄ {z} ‚Üí v z ‚â° v‚Äô z)
         ‚Üí ‚àÄ x t y {ec : v x ùíû.‚ü∂ v t} {psc : v t ùíû.‚ü∂ v y}
         ‚Üí  
           ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq ec ùíû.‚®æ ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq psc
         ‚â° ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq (ec ùíû.‚®æ psc)
  subst-dist veq x t y rewrite veq {x} | veq {t} | veq {y} = ‚â°-refl

  uniquenessOld : ‚àÄ{f : G ‚ü∂ ùí∞‚ÇÄ ùíû} {F : ùí´‚ÇÄ G ‚ü∂ ùíû} ‚Üí f ‚âàg (Œπ ‚®æ ùí∞‚ÇÅ F) ‚Üí lift f ‚â° F
  uniquenessOld {f} {F} (veq , eeq) = funcext veq pf
    where
    
      ùíÆ : ‚àÄ{x y} ‚Üí ver f x ùíû.‚ü∂ ver f y ‚Üí obj F x ùíû.‚ü∂ obj F y
      ùíÆ m = ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq m
      
      pf : ‚àÄ{x y} {p : x ‚áù y} ‚Üí mor F p ‚â° ùíÆ( mor (lift f) p )
      pf {x} {.x} {.x !} rewrite (veq {x})= Functor.id F
      pf {x} {y}  {.x ‚ü∂[ e ]‚ü∂ ps} rewrite (eeq {e = e}) =  begin
          mor F (x ‚ü∂[ e ]‚ü∂ ps)
       ‚â°‚ü®" definition of embedding and concatenation "‚ü©‚Ä≤
          mor F (edge Œπ e ++ ps)
       ‚â°‚ü® functor F preserves-composition ‚ü©
          mor F (edge Œπ e) ùíû.‚®æ mor F ps
       ‚â°‚ü® ‚â°-cong‚ÇÇ ùíû._‚®æ_ eeq (pf {p = ps}) ‚ü© -- inductive step
          ùíÆ(edge f e) ùíû.‚®æ ùíÆ(mor (lift f) ps)
       ‚â°‚ü® subst-dist veq x _ y ‚ü©
          ùíÆ( edge f e ùíû.‚®æ mor (lift f) ps )
       ‚â°‚ü®" definition of ‚Äúmor‚Äù on ‚Äúlift‚Äù, the inductive clause "‚ü©‚Ä≤
          ùíÆ( mor (lift f) (x ‚ü∂[ e ]‚ü∂ ps) )
       ‚àé
#+END_SRC       
:End:

** Another freedom proof

However, saying each graph-map gives rise to exactly one unique functor is tantamount to
saying the type ~GraphMap G (ùí∞‚ÇÄ ùíû)~ is isomorphic to ~Functor (ùí´‚ÇÄ G) ùíû~, that is
~(ùí´‚ÇÄ G ‚ü∂ ùíû) ‚âÖ (G ‚ü∂ ùí∞‚ÇÄ ùíû)~ ---observe that this says we can ‚Äòmove‚Äô ~ùí´‚ÇÄ~ from the left to
the right of an arrow at the cost of it (and the arrow) changing.

A few healthy exercises,

#+BEGIN_EXAMPLE
  liftÀò : Functor ùí´G ùíû ‚Üí GraphMap G (ùí∞‚ÇÄ ùíû)
  liftÀò F = Œπ ‚®æg ùí∞‚ÇÅ F  --  i.e., record {ver = obj F , edge = mor F ‚àò edge Œπ}

  rid : ‚àÄ{f : GraphMap G (ùí∞‚ÇÄ ùíû)} ‚Üí ‚àÄ{x y} {e : x ‚ü∂g y} ‚Üí liftÀò (lift f) ‚â° f
  rid = {! exercise !}

  lid : ‚àÄ{F : Functor ùí´G ùíû} ‚Üí lift (liftÀò F) ‚â° F
  lid = {! exercise !}
#+END_EXAMPLE

One can of course obtain these proofs from the other ones without recourse to definitions,
however for comprehension one would do well to prove them from first principles.
The worked out solutions are available in the literate source file of this document.

:Solutions:
#+BEGIN_SRC agda
  liftÀò : Functor (ùí´‚ÇÄ G) ùíû ‚Üí GraphMap G (ùí∞‚ÇÄ ùíû)
  liftÀò F =  Œπ ‚®æ ùí∞‚ÇÅ F  -- ‚â° record {ver = obj F , edge = mor F ‚àò edge Œπ}

  rid‚ÇÄ : ‚àÄ {f : GraphMap G (ùí∞‚ÇÄ ùíû)} ‚Üí ver (liftÀò (lift f)) ‚â° ver f
  rid‚ÇÄ {f} = begin
      ver (liftÀò (lift f))
    ‚â°‚ü®" ver of liftÀò ; defn of liftÀò "‚ü©‚Ä≤ 
      obj (lift f)
    ‚â°‚ü®" defn of lift.obj "‚ü©‚Ä≤
      ver f
    ‚àé
-- note that ‚â°-refl would have suffcied, but we show all the steps for clarity, for human consumption!

  open Graph G renaming (_‚ü∂_ to _‚ü∂g_)
  rid‚ÇÅ : ‚àÄ{f : GraphMap G (ùí∞‚ÇÄ ùíû)} ‚Üí ‚àÄ{x y} {e : x ‚ü∂g y} ‚Üí edge (liftÀò (lift f)) e ‚â° edge f e
  rid‚ÇÅ {f} {x} {y} {e} = begin
      edge (liftÀò (lift f)) e
    ‚â°‚ü® "liftÀò.edge definition" ‚ü©‚Ä≤
      mor (lift f) (edge Œπ e)
    ‚â°‚ü® "lift.mor~ on an edge; i.e., the inductive case of fmap" ‚ü©‚Ä≤
      edge f e ùíû.‚®æ Id
    ‚â°‚ü® ùíû.rightId ‚ü©
      edge f e
    ‚àé

  rid : ‚àÄ{f : GraphMap G (ùí∞‚ÇÄ ùíû)} ‚Üí liftÀò (lift f) ‚â° f
  rid {f} = graphmapext ‚â°-refl (‚â°-sym (rid‚ÇÅ {f}))

  lid‚ÇÄ : ‚àÄ{F : Functor (ùí´‚ÇÄ G) ùíû} ‚Üí obj (lift (liftÀò F)) ‚â° obj F
  lid‚ÇÄ {F} =  begin
      obj (lift (liftÀò F))
    ‚â°‚ü® "obj of lift" ‚ü©‚Ä≤
      ver (liftÀò F)
    ‚â°‚ü® "ver of liftÀò" ‚ü©‚Ä≤
       obj F
    ‚àé

  lid‚ÇÅ : ‚àÄ{F : Functor (ùí´‚ÇÄ G) ùíû} ‚Üí ‚àÄ {x y} {p : x ‚áù y} ‚Üí mor (lift (liftÀò F)) p ‚â° mor F p
  lid‚ÇÅ {F} {x} {.x} {p = (.x) !} = begin
      mor (lift (liftÀò F)) (x !)
    ‚â°‚ü® "mor of lift on !" ‚ü©‚Ä≤
      ùíû.Id
    ‚â°‚ü® ‚â°-sym (Functor.id F) ‚ü© -- ! is identity path in ~ùí´G~ and functor preserve identites
       mor F (x !)
    ‚àé
  lid‚ÇÅ {F} {x} {y} {p = .x ‚ü∂[ e ]‚ü∂ ps} = begin
      mor (lift (liftÀò F)) (x ‚ü∂[ e ]‚ü∂ ps)
    ‚â°‚ü®‚ü© -- mor on lift on inductive case
      edge (liftÀò F) e ùíû.‚®æ mor (lift (liftÀò F)) ps
    ‚â°‚ü®  ‚â°-cong (Œª w ‚Üí edge (liftÀò F) e ùíû.‚®æ w) (lid‚ÇÅ {F}) ‚ü©
      edge (liftÀò F) e ùíû.‚®æ mor F ps
    ‚â°‚ü® "edge on liftÀò" ‚ü©‚Ä≤
      mor F (edge Œπ e) ùíû.‚®æ mor F ps
    ‚â°‚ü® ‚â°-sym (Functor.comp F) ‚ü© -- factor out Functor.mor
      mor F (edge Œπ e ++ ps)
    ‚â°‚ü® "defn of ++" ‚ü©‚Ä≤
      mor F (x ‚ü∂[ e ]‚ü∂ ps)
    ‚àé

  lid : ‚àÄ {F : Functor (ùí´‚ÇÄ G) ùíû} ‚Üí lift (liftÀò F) ‚â° F
  lid  {F} = funcext ‚â°-refl (‚â°-sym (lid‚ÇÅ {F}))

  -- old version
  lift-‚âà : ‚àÄ{f f‚Äô : GraphMap G (ùí∞‚ÇÄ ùíû)} ‚Üí f ‚âàg f‚Äô ‚Üí lift f ‚âã lift f‚Äô
  lift-‚âà  {f} {f‚Äô} (veq , eeq) = veq , (Œª {x} {y} {p} ‚Üí pf {x} {y} {p})
    where
      pf : {x y : V} {p : x ‚áù y} ‚Üí mor (lift f‚Äô) p ‚â° ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq (mor (lift f) p)
      pf {x} {.x} {p = .x !} rewrite (veq {x}) = ‚â°-refl
      pf {x} {y} {p = .x ‚ü∂[ e ]‚ü∂ ps} = begin 
           mor (lift f‚Äô) (x ‚ü∂[ e ]‚ü∂ ps)
         ‚â°‚ü®‚ü©
           edge f‚Äô e ùíû.‚®æ mor (lift f‚Äô) ps
         ‚â°‚ü® ‚â°-cong‚ÇÇ ùíû._‚®æ_ eeq (pf {p = ps}) ‚ü©
           ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq (edge f e) ùíû.‚®æ ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq (mor (lift f) ps) 
         ‚â°‚ü® subst-dist veq x _ y ‚ü©
            ‚â°-subst‚ÇÇ ùíû._‚ü∂_ veq veq (mor (lift f) (x ‚ü∂[ e ]‚ü∂ ps))
         ‚àé
#+END_SRC    
:End:
 
We can then provide an alternative, and more succinct, proof of uniqueness for ‚Äòbasis preservation‚Äô:

#+BEGIN_SRC agda
  uniqueness‚Äô  :  ‚àÄ{f h}   ‚Üí    f  ‚â°  (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ h)   ‚Üí   lift f  ‚â°  h
  uniqueness‚Äô {f} {h} f‚âàŒπ‚®æùí∞‚ÇÅh = begin
      lift f
    ‚â°‚ü® ‚â°-cong lift f‚âàŒπ‚®æùí∞‚ÇÅh ‚ü©
      lift (Œπ ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ h)
    ‚â°‚ü®" definition of liftÀò "‚ü©‚Ä≤
      lift (liftÀò h)
    ‚â°‚ü® lid ‚ü©
      h
    ‚àé
#+END_SRC

The difference between this proof and the original one is akin
to the difference between heaven and earth! That or it's much more elegant ;-)
 
** ~ùí´ ‚ä£ ùí∞~

:RecallingDefinitions:
Following is probably full of type errors, since it‚Äôs all by hand!

Anyhow, let‚Äôs recall the notion of natural isomorphism, then apply it to adjunctions then to our
particular adjunction for paths.

~F ‚âÖ G~ means ~‚àÄ A : Obj ùíû ‚Ä¢ ‚àÉ Œ¶ : F A ‚âÖ G A ‚Ä¢ ‚àÄ X Y : Obj ùíû ‚Ä¢ ‚àÄ f : X ‚ü∂ Y ‚Ä¢ F f ‚®æ Œ¶ {Y} ‚âà Œ¶ {X} ‚®æ G f~
Given f we have two ways to get from F X to G Y:
first lift f to ~F f : F X ‚Üí F Y~ then shift to ~F f ‚®æ Œ¶ {Y} : F X ‚Üí G Y~,
alternatively we shift then lift to obtain ~Œ¶ {X} ‚®æ G f : F X ‚Üí G Y~
and ideally we‚Äôd like to avoid having to make a choice and so request
these two approaches to be the same.

For the case ~F ‚ä£ G~.

FF := F _ ‚ü∂ _ : ùíû·µí·µñ√óùíü ‚Üí ùíü‚Äô : Œª (A , B) ‚Üí F A ‚ü∂ B ; where ùíü‚Äô is the cats of arrows of ~ùíü~.
                            : Œª (m : Mor ùíû, n : Mor ùíü) ‚Üí Œª k : F (Tgt m) ‚ü∂ùíü Src n ‚Üí F m ‚®æ k ‚®æ n 


Given m : X‚Çò ‚ü∂ùíû Y‚Çò and n : X‚Çô ‚ü∂ùíü Y‚Çô, we have ~(m , n) : (Y‚Çò , X‚Çô) ‚ü∂ (X‚Çò , Y‚Çô)~ is an arrow of ~ùíû·µí·µñ √ó ùíü~.
we have FF (m , n) : (F Y‚Çò ‚ü∂ùíü X‚Çô) ‚Üí (F X‚Çò ‚ü∂ùíü Y‚Çô)
        Œ¶ {A} {B} : (F A ‚ü∂ùíü B) ‚âÖ (A ‚ü∂ùíû G B)
then
FF (m , n) ‚®æ Œ¶ {Y‚Çò} {X‚Çô} : (F Y‚Çò ‚ü∂ùíü X‚Çô) ‚Üí (X‚Çò ‚ü∂ùíü G Y‚Çô) : k ‚Ü¶ Œ¶ {Y‚Çò} {X‚Çô} (F m ‚®æ k ‚®æ n)

Likewise,
GG (m, n) : (Y‚Çò ‚ü∂ùíû G X‚Çô) ‚Üí (X‚Çò ‚ü∂ùíü G Y‚Çô) : k ‚Ü¶ m ‚®æ k ‚®æ G n
and thus
Œ¶ {X‚Çò} {Y‚Çô} ‚®æ GG (m, n) : (F Y‚Çò ‚ü∂ùíü X‚Çô) ‚Üí (X‚Çò ‚ü∂ùíü G Y‚Çô) : k ‚Ü¶ m ‚®æ Œ¶ {Y‚Çò} {X‚Çô} k ‚®æ G n

Hence we need,
~‚àÄ k : F Y‚Çò ‚ü∂ùíü X‚Çô ‚Ä¢ Œ¶ {Y‚Çò} {X‚Çô} (F m ‚®æ k ‚®æ n) ‚âà m ‚®æ Œ¶ {Y‚Çò} {X‚Çô} k ‚®æ G n~

For our case ~ùí´ ‚ä£ ùí∞~.
Naturality becomes, using ~ùí¢~ for ~ùí¢ùìáùí∂ùìÖùíΩ~ and ~ùíû~ for ~ùíûùí∂ùìâ~,
~‚àÄ G H : Obj ùí¢ùìáùí∂ùìÖùíΩ ‚Ä¢ ‚àÄ ùíû ùíü : Obj ùíûùí∂ùìâ ‚Ä¢ ‚àÄ g : GraphMap G H ‚Ä¢ ‚àÄ F : Functor ùíû ùíü ‚Ä¢ 
‚àÄ k : Functor (ùí´ H) ùíû ‚Ä¢ liftÀò {G} {ùíû} (ùí´ g ‚®æ k ‚®æ F) ‚âà g ‚®æ liftÀò {H} {ùíû} k ‚®æ ùí∞ F~

That is, for every graph map g and functor F, for appropriate functor k we have
~liftÀò (ùí´ g ‚®æ k ‚®æ F) ‚âà g ‚®æ liftÀò k ‚®æ ùí∞ F~ in the category of graphs.
:End:
 
Thus far, we have essentially shown 
\[(ùí´‚ÇÄ\, G \,‚ü∂\, ùíû) \quad‚âÖ\quad (G \,‚ü∂\, ùí∞‚ÇÄ\, ùíû)\]
We did so by finding a pair of inverse maps:

#+BEGIN_EXAMPLE
lift   :  (    G ‚ü∂ ùí∞‚ÇÄ ùíû)  ‚Üí  (ùí´‚ÇÄ G ‚ü∂     ùíû)
liftÀò  :  (ùí´‚ÇÄ G  ‚ü∂    ùíû)  ‚Üí  (   G ‚ü∂  ùí∞‚ÇÄ ùíû)
#+END_EXAMPLE

This is nearly ~ùí´ ‚ä£ ùí∞~ which implies ~ùí´~ is a ‚Äòfree-functor‚Äô since it is left-adjoint to a forgetful-functor.

‚ÄòNearly‚Äô since we need to exhibit naturality:
For every graph map ~g~ and functors ~F, k~ we have
~liftÀò (ùí´ g ‚®æ k ‚®æ F) ‚âà g ‚®æ liftÀò k ‚®æ ùí∞ F~ in the category of graphs.

[[http://maartenfokkinga.github.io/utwente/mmf92b.pdf][Fokkinga (Theorem A.4)]], among others, would call these laws ‚Äòfusion‚Äô 
instead since they inform us how to compose, or ‚Äòfuse‚Äô, a morphism with a
~liftÀò~-ed morphism: Taking ~F~ to be the identity and remembering that functors preserve
identities, we have that ~g ‚®æ liftÀò K ‚â° liftÀò( ùí´‚ÇÅ g ‚®æ K)~ --we can push a morphism into a ~liftÀò~
at the cost of introducing a ~ùí´‚ÇÅ~; dually for ~lift~-ed morphisms.

First the setup,
#+BEGIN_SRC agda
module _ {G H : Graph} {ùíû ùíü : Category {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ}} 
          (g : GraphMap G H) (F : Functor ùíû ùíü) where

  private
    liftÀò = Œª {A} {C} B ‚Üí freedom.liftÀò A {C} B
    lift = Œª {A} {C} B ‚Üí freedom.lift A {C} B
  open Category ‚¶É...‚¶Ñ

  module ùíû     = Category ùíû
  module ùíü     = Category ùíü
  module ùí¢ùìáùí∂ùìÖùíΩ = Category ùí¢ùìáùí∂ùìÖùíΩ
  module ùíûùí∂ùìâ   = Category (ùíûùí∂ùìâ {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ})
  module ùíÆ‚ÑØùìâ   = Category (ùíÆeùìâ {‚Ñì‚ÇÄ})
#+END_SRC

Just as we needed to prove two inverse laws for ~lift~ and ~liftÀò~, 
we need two naturality proofs.

#+BEGIN_SRC agda
  naturalityÀò : ‚àÄ {K : Functor (ùí´‚ÇÄ H) ùíû} 
              ‚Üí  liftÀò (ùí´‚ÇÅ g ùíûùí∂ùìâ.‚®æ K ùíûùí∂ùìâ.‚®æ F)  ‚â°  (g ùí¢ùìáùí∂ùìÖùíΩ.‚®æ liftÀò K ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)
  naturalityÀò = graphmapext ‚â°-refl ‚â°-refl
#+END_SRC

That was easier than assumed! 
Hahaha: Hard to formalise but so easy to prove lolz!
It says we can ‚Äòshunt‚Äô ~liftÀò~ into certain compositions at the cost
of replacing functor instances.

Now for the other proof:
#+BEGIN_SRC agda
  naturality : ‚àÄ {k : GraphMap H (ùí∞‚ÇÄ ùíû)} ‚Üí     lift (g ùí¢ùìáùí∂ùìÖùíΩ.‚®æ k ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F) 
                                              ‚â°  (ùí´‚ÇÅ g ùíûùí∂ùìâ.‚®æ lift k ùíûùí∂ùìâ.‚®æ F)
  naturality {k} = funcext ‚â°-refl (Œª {x y p} ‚Üí proof {x} {y} {p})
    where
      open TypedPaths ‚¶É...‚¶Ñ
      instance G‚Ä≤ : Graph ; G‚Ä≤ = G
               H‚Ä≤ : Graph ; H‚Ä≤ = H
      proof : ‚àÄ {x y : Graph.V G} {p : x ‚áù y}
            ‚Üí    mor (ùí´‚ÇÅ g ùíûùí∂ùìâ.‚®æ lift {H} {ùíû} k ùíûùí∂ùìâ.‚®æ F) p 
               ‚â°  mor (lift {G} {ùíü} (g ùí¢ùìáùí∂ùìÖùíΩ.‚®æ k ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)) p
      proof {p = _ !} = functor (ùí´‚ÇÅ g ùíûùí∂ùìâ.‚®æ lift {H} {ùíû} k ùíûùí∂ùìâ.‚®æ F) preserves-identities
      proof {p = x ‚ü∂[ e ]‚ü∂ ps} = begin
            mor (ùí´‚ÇÅ g ùíûùí∂ùìâ.‚®æ lift {H} {ùíû} k ùíûùí∂ùìâ.‚®æ F) (x ‚ü∂[ e ]‚ü∂ ps)
         ‚â°‚ü®" By definition, ‚Äúmor‚Äù distributes over composition "‚ü©‚Ä≤
            (mor (ùí´‚ÇÅ g) ùíÆ‚ÑØùìâ.‚®æ mor (lift {H} {ùíû} k) ùíÆ‚ÑØùìâ.‚®æ mor F) (x ‚ü∂[ e ]‚ü∂ ps)
         ‚â°‚ü®" Definitions of function composition and ‚Äúùí´‚ÇÅ ‚®æ mor‚Äù "‚ü©‚Ä≤
            mor F (mor (lift {H} {ùíû} k) (mor (ùí´‚ÇÅ g) (x ‚ü∂[ e ]‚ü∂ ps)))
                                                  -- This explicit path is in G
         ‚â°‚ü®" Lifting graph-map ‚Äúg‚Äù onto a path "‚ü©‚Ä≤
            mor F (mor (lift {H} {ùíû} k) (ver g x ‚ü∂[ edge g e ]‚ü∂ mor (ùí´‚ÇÅ g) ps))
                                                  -- This explicit path is in H
         ‚â°‚ü®" Definition of ‚Äúlift ‚®æ mor‚Äù on inductive case for paths "‚ü©‚Ä≤
            mor F (edge k (edge g e) ùíû.‚®æ mor (lift {H} {ùíû} k) (mor (ùí´‚ÇÅ g) ps))
         ‚â°‚ü® functor F preserves-composition ‚ü©
                mor F (edge k (edge g e))
           ùíü.‚®æ  mor F (mor (lift {H} {ùíû} k) (mor (ùí´‚ÇÅ g) ps))
         ‚â°‚ü®" Definition of function composition, for top part "‚ü©‚Ä≤            
               (edge g ùíÆ‚ÑØùìâ.‚®æ edge k ùíÆ‚ÑØùìâ.‚®æ mor F) e  -- ‚âà mor F ‚àò edge k ‚àò edge g
           ùíü.‚®æ (mor (ùí´‚ÇÅ g) ùíÆ‚ÑØùìâ.‚®æ mor (lift {H} {ùíû} k) ùíÆ‚ÑØùìâ.‚®æ mor F) ps
         ‚â°‚ü®" ‚Äúùí∞‚ÇÅ ‚®æ edge = mor‚Äù and ‚Äúedge‚Äù and ‚Äúmor‚Äù are functorial by definition "‚ü©‚Ä≤
                edge (g ùí¢ùìáùí∂ùìÖùíΩ.‚®æ k ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F) e 
           ùíü.‚®æ  mor (ùí´‚ÇÅ g ùíûùí∂ùìâ.‚®æ lift {H} {ùíû} k ùíûùí∂ùìâ.‚®æ F) ps
         ‚â°‚ü® {- Inductive Hypothesis: -} ‚â°-cong‚ÇÇ ùíü._‚®æ_ ‚â°-refl (proof {p = ps}) ‚ü©
                edge (g ùí¢ùìáùí∂ùìÖùíΩ.‚®æ k ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F) e 
           ùíü.‚®æ  mor (lift {G} {ùíü} (g ùí¢ùìáùí∂ùìÖùíΩ.‚®æ k ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)) ps
         ‚â°‚ü®" Definition of ‚Äúlift ‚®æ mor‚Äù on inductive case for paths "‚ü©‚Ä≤
            mor (lift {G} {ùíü} (g ùí¢ùìáùí∂ùìÖùíΩ.‚®æ k ùí¢ùìáùí∂ùìÖùíΩ.‚®æ ùí∞‚ÇÅ F)) (x ‚ü∂[ e ]‚ü∂ ps)
         ‚àé
#+END_SRC        

Formally, we now have an adjunction:
#+BEGIN_SRC agda
ùí´‚ä£ùí∞ : ùí´ ‚ä£ ùí∞
ùí´‚ä£ùí∞ = record{
    ‚åä_‚åã = liftÀò
  ; ‚åà_‚åâ = lift
  ; lid = lid
  ; rid = Œª {G ùíû c} ‚Üí rid {G} {ùíû} {c}
  ; lfusion = Œª {G H ùíû ùíü f F K} ‚Üí naturalityÀò {G} {H} {ùíû} {ùíü} f K {F}
  ; rfusion = Œª {G H ùíû ùíü f k F} ‚Üí naturality {G} {H} {ùíû} {ùíü} f F {k} }
  where
    module _ {G : Graph} {ùíû : Category} where open freedom G {ùíû} public
#+END_SRC
* Folds Over Paths
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

** Intro :ignore:
Observe that for the freedom proof we recalled
that ists determine a form of quantification, ‚Äòfolding‚Äô:
given an operation ‚äï, we may form the operation ~[x‚ÇÅ, ‚Ä¶, x‚Çñ] ‚Ü¶ x‚ÇÅ ‚äï ‚ãØ ‚äï x‚Çñ~.
Then used that to define our operation ~lift~, whose core was essentially,
#+BEGIN_SRC agda
module folding (G : Graph) where
  open TypedPaths G
  open Graph G
                                              -- Given:
  fold : {X : Set} (v : V ‚Üí X)               -- realise G's vertices as X elements
         (f : ‚àÄ x {y} (e : x ‚ü∂ y) ‚Üí X ‚Üí X) -- realise paths as X elements
       ‚Üí (‚àÄ {a b} ‚Üí a ‚áù b ‚Üí X)            -- Then: Any path is an X value
  fold v f (b !) = v b
  fold v f (x ‚ü∂[ e ]‚ü∂ ps) = f x e (fold v f ps)  
#+END_SRC            

For example, what is the length of a path?
#+BEGIN_SRC agda
  length : ‚àÄ{x y} ‚Üí x ‚áù y ‚Üí ‚Ñï
  length = fold (Œª _ ‚Üí 0)          -- single walks are length 0.
                (Œª _ _ n ‚Üí 1 + n)  -- edges are one more than the 
                                    -- length of the remaining walk
#+END_SRC
Let‚Äôs verify that this is actually what we intend by the length of a path.
#+BEGIN_SRC agda
  length-! : ‚àÄ{x} ‚Üí length (x !) ‚â° 0
  length-! = ‚â°-refl
  -- True by definition of ‚Äúlength‚Äù: The first argument to the ‚Äúfold‚Äù

  length-ind : ‚àÄ {x y œâ} {e : x ‚ü∂ y} {ps : y ‚áù œâ} 
            ‚Üí  length (x ‚ü∂[ e ]‚ü∂ ps)  ‚â°  1 + length ps
  length-ind = ‚â°-refl 
  -- True by definition of ‚Äúlength‚Äù: The second-argument to the ‚Äúfold‚Äù
#+END_SRC

Generalising on ~length~, suppose we have a ‚Äòcost function‚Äô ~c~ that assigns a cost of traversing
an edge. Then we can ask what is the total cost of a path:
#+BEGIN_SRC agda
  path-cost : (c : ‚àÄ{x y}(e : x ‚ü∂ y) ‚Üí ‚Ñï) ‚Üí ‚àÄ{x y}(ps : x ‚áù y) ‚Üí ‚Ñï
  path-cost c = fold (Œª _ ‚Üí 0)           -- No cost on an empty path.
                     (Œª x e n ‚Üí c e + n) -- Cost of current edge plus 
                                          -- cost of remainder of path.
#+END_SRC
Now, we have ~length = path-cost (Œª _ ‚Üí 1)~: Length is just assigning a cost of 1 to each edge.

Under suitable conditions, list fold distributes over list catenation, can we find an analogue
for paths? Yes. Yes, we can:
#+BEGIN_SRC agda
  fold-++ :  ‚àÄ{X : Set} {v : V ‚Üí X} {g : ‚àÄ x {y} (e : x ‚ü∂ y) ‚Üí X}
          ‚Üí (_‚äï_ : X ‚Üí X ‚Üí X)
          ‚Üí ‚àÄ{x y z : V} {p : x ‚áù y} {q : y ‚áù z}
          ‚Üí (unitl : ‚àÄ{x y} ‚Üí y ‚â° v x ‚äï y)        -- Image of ‚Äòv‚Äô is left unit of ‚äï
          ‚Üí (assoc : ‚àÄ {x y z} ‚Üí x ‚äï (y ‚äï z) ‚â° (x ‚äï y) ‚äï z )  -- ‚äï is associative 
          ‚Üí let f : ‚àÄ x {y} (e : x ‚ü∂ y) ‚Üí X ‚Üí X
                f = Œª x e ps ‚Üí g x e ‚äï ps
             in
               fold v f (p ++ q) ‚â° fold v f p ‚äï fold v f q
  fold-++ {g = g} _‚äï_ {x = x} {p = .x !} unitl assoc =  unitl
  fold-++ {g = g} _‚äï_ {x = x} {p = .x ‚ü∂[ e ]‚ü∂ ps} unitl assoc =
    ‚â°-cong (Œª exp ‚Üí g x e ‚äï exp) (fold-++ _‚äï_ {p = ps} unitl assoc) ‚ü®‚â°‚â°‚ü© assoc
#+END_SRC

Compare this with the proof-obligation of ~lift~.

** Lists are special kinds of paths
We called our path catenation ~_++_~, why the same symbol as that for 
list catenation?

How do we interpret a list over $A$ as a graph? 
Well the vertices can be any element of $A$
and an edge $x ‚ü∂ y$ merely indicates that 
‚Äò‚Äòthe item after $x$ in the list is the element $y$‚Äô‚Äô,
so we want it to be always true; or always inhabited 
without distinction of the inhabitant:
So we might as well use a unit type.
#+BEGIN_SRC agda
module lists (A : Set) where

  open import Data.Unit

  listGraph : Graph
  listGraph = record { V = A ; _‚ü∂_ = Œª a a‚Äô ‚Üí ‚ä§ }
#+END_SRC
I haven‚Äôt a clue if this works, you read my reasoning above.

The only thing we can do is test our hypothesis by looking at the 
typed paths over this graph. In particular, we attempt to show every 
non-empty list of $A$‚Äôs corresponds to a path. Since a typed path needs
a priori the start and end vertes, let us construe
~List A  ‚âÖ  Œ£ n ‚à∂ ‚Ñï ‚Ä¢ Fin n ‚Üí A~ 
--later note that ~Path G  ‚âÖ  Œ£ n ‚à∂ ‚Ñï ‚Ä¢ [n] ùí¢‚ü∂ G~.
#+BEGIN_SRC agda
  open TypedPaths listGraph
  open folding listGraph

  -- Every non-empty list [x‚ÇÄ, ‚Ä¶, x‚Çñ] of A‚Äôs corresonds to a path x‚ÇÄ ‚áù x‚Çñ.
  toPath : ‚àÄ{n} (list : Fin (suc n) ‚Üí A) ‚Üí  list fzero ‚áù list (from‚Ñï n)
  toPath {zero} list = list fzero !
  toPath {suc n} list = list fzero ‚ü∂[ tt ]‚ü∂ toPath {n} (Œª i ‚Üí list(fsuc i))
    -- Note that in the inductive case, ‚Äúlist : Fin (suc (suc n)) ‚Üí A‚Äù 
    -- whereas ‚Äúsuc ‚®æ list : Fin (suc n) ‚Üí A‚Äù.
    --
    -- For example, if ‚Äúlist ‚âà [x , y , z]‚Äù yields
    --          ‚Äúfsuc ‚®æ list ‚âà [y , z ]‚Äù and
    --   ‚Äúfsuc ‚®æ fsuc ‚®æ list ‚âà [z]‚Äù.
#+END_SRC
Hm! Look at that, first guess and it worked! Sweet.

Now let‚Äôs realize the list fold as an instance of path fold,
#+BEGIN_SRC agda
  -- List type former
  List = Œª (X : Set) ‚Üí Œ£ n ‚à∂ ‚Ñï ‚Ä¢ (Fin n ‚Üí X)

  -- Usual list folding, but it's in terms of path folding.
  foldr : ‚àÄ{B : Set} (f : A ‚Üí B ‚Üí B) (e : B) ‚Üí List A ‚Üí B
  foldr f e (zero , l) = e
  foldr f e (suc n , l) = fold (Œª a ‚Üí f a e) (Œª a _ rem ‚Üí f a rem) (toPath l)

  -- example
  listLength : List A ‚Üí ‚Ñï -- result should clearly be ‚Äúproj‚ÇÅ‚Äù of the list, anyhow:
  listLength = foldr 
    (Œª a rem ‚Üí 1 + rem) -- Non-empty list has length 1 more than the remainder.
    0                    -- Empty list has length 0.
#+END_SRC

Let‚Äôs prepare for a more useful example
#+BEGIN_SRC agda
  -- Empty list
  [] : ‚àÄ{X : Set} ‚Üí List X
  [] = 0 , Œª ()

  -- Cons for lists
  _‚à∑_ : ‚àÄ{X : Set} ‚Üí X ‚Üí List X ‚Üí List X
  _‚à∑_ {X} x (n , l) = 1 + n , cons x l
    where
      -- ‚Äúcons a l  ‚âà  Œª i : Fin (1 + n) ‚Üí if i ‚âà 0 then a else l i‚Äù
      cons : ‚àÄ{n} ‚Üí X ‚Üí (Fin n ‚Üí X) ‚Üí (Fin (suc n) ‚Üí X)
      cons x l fzero = x
      cons x l (fsuc i) = l i
  
  map : ‚àÄ {B} (f : A ‚Üí B) ‚Üí List A ‚Üí List B
  map f =  foldr (Œª a rem ‚Üí f a ‚à∑ rem) []  -- looks like the usual map don‚Äôt it ;)

  -- list concatenation
  _++‚Ñì_ : List A ‚Üí List A ‚Üí List A
  l ++‚Ñì r = foldr _‚à∑_ r l -- fold over ‚Äòl‚Äô by consing its elements infront of ‚Äòr‚Äô

  -- Exercise: Write path catenation as a path-fold.
#+END_SRC

These few adventures would suggest that much of list theory can be
brought over to the world of paths. It looks promising, let me know
dear reader if you make progress on related explorations!
* That was fun; Bye! 
:PROPERTIES:
:header-args: :tangle "PathCat.agda" 
:END:

This note took longer to write than I had initally assumed; perhaps I should have taken into
account 
+ Hofstadter‚Äôs Law :: 
  It always takes longer than you expect, even when you take into account Hofstadter‚Äôs Law.

  ‚îÄ[[https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach][G√∂del, Escher, Bach: An Eternal Golden Braid]]

Lessons learned:

+ In Agda, Use implicits when possible in-favour of instance variables
  since the former can be inferred from the local context,
  whereas the latter must be resolved using the entire global context
  thereby incurring possibly more unification problems to solve
  thereby costing more time.

+ If you really want to learn something, teach it to someone:
  A proof assistant wont let you get away with skipping over anything!

+ Coming up with the right data representation for the tasks being tackled
  is a matter of discovery!

The astute reader may have noticed that the tone of writing sometimes 
changes drastically. This is because some of this article was written
by me in March 2016 and I wished to preserve interesting writing style
I then had --if anything to contrast with my now somewhat semi-formal style.

This article was motivated while I was reading [[https://www.amazon.ca/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X][Conceptual Mathematics]]
for fun. One of the problems was to show that paths over a graph form
a category and do so freely. It took me about 20 minutes on paper and pencil,
but this resulting mechanisation took much more time --but it was also
much more fun!

I had fun writing this up & I hope you enjoy it too :-)

+ Highly Recommended Read ::  
  The diligent reader may be interested to know that Maarten Fokkinga has written a very
  accessible and [[http://maartenfokkinga.github.io/utwente/mmf92b.pdf][gentle introduction to category theory using the calculational approach]].

#+HTML: <small>
#+BEGIN_CENTER
( This article is not yet ‚Äòdone‚Äô, but good enough for now. )
#+END_CENTER
#+HTML: </small>

* COMMENT Setoid Approach                                         :solutions:
Herein are the solutions to a setoid approach going all the way to the
lifting of graphmaps to functors.

I wrote this rushedly; very rough solutions.

#+BEGIN_EXAMPLE
module _ where -- category definitions
 record Category‚Äô {i j k : Level} : Set (‚Ñìsuc (i ‚äç j ‚äç k)) where
  infixr 10 _‚®æ_
  infix 5 _‚âà_
  field
    -- graph structure
    Obj‚Äô  : Set i
    _‚ü∂_ : Obj‚Äô ‚Üí Obj‚Äô ‚Üí Set j

    -- setoid structure
    _‚âà_  : ‚àÄ {A B} (f g : A ‚ü∂ B) ‚Üí Set k
    ‚âà-refl  : ‚àÄ {A B} {f : A ‚ü∂ B} ‚Üí f ‚âà f
    ‚âà-sym   : ‚àÄ {A B} {f g : A ‚ü∂ B} ‚Üí f ‚âà g ‚Üí g ‚âà f
    ‚âà-trans : ‚àÄ {A B} {f g h : A ‚ü∂ B} ‚Üí f ‚âà g ‚Üí g ‚âà h ‚Üí f ‚âà h

    -- typed-monoid-like structure
    _‚®æ_     : ‚àÄ{A B C : Obj‚Äô} ‚Üí A ‚ü∂ B ‚Üí B ‚ü∂ C ‚Üí A ‚ü∂ C
    ‚®æ-cong  : ‚àÄ {A B C} {f f‚Äô : A ‚ü∂ B} {g g‚Äô : B ‚ü∂ C} ‚Üí f ‚âà f‚Äô ‚Üí g ‚âà g‚Äô ‚Üí f ‚®æ g ‚âà f‚Äô ‚®æ g‚Äô  
    assoc   : ‚àÄ{A B C D} {f : A ‚ü∂ B}{g : B ‚ü∂ C} {h : C ‚ü∂ D} ‚Üí (f ‚®æ g) ‚®æ h ‚âà f ‚®æ (g ‚®æ h)
    Id      : ‚àÄ{A : Obj‚Äô} ‚Üí A ‚ü∂ A
    leftId  : ‚àÄ {A B} {f : A ‚ü∂ B} ‚Üí Id ‚®æ f ‚âà f
    rightId : ‚àÄ {A B} {f : A ‚ü∂ B} ‚Üí f ‚®æ Id ‚âà f
 open Category‚Äô ‚¶É...‚¶Ñ renaming (_‚ü∂_ to _‚ü∂‚Äô_ ; _‚®æ_ to _‚®æ‚Äô_ ; Id to Id‚Äô ; leftId to leftId‚Äô ; rightId to rightId‚Äô ; assoc to assoc‚Äô ; _‚âà_ to _‚âà‚Äô_) public

 record Functor‚Äô {i j k i‚Äô j‚Äô k‚Äô} (ùíû : Category‚Äô {i} {j} {k}) (ùíü : Category‚Äô {i‚Äô} {j‚Äô} {k‚Äô}) : Set (‚Ñìsuc (i ‚äç j ‚äç k ‚äç i‚Äô ‚äç j‚Äô ‚äç k‚Äô)) where
  field
    -- graph-map structure
    obj‚Äô  : Category‚Äô.Obj‚Äô ùíû ‚Üí Category‚Äô.Obj‚Äô ùíü                               -- object map
    mor‚Äô  : ‚àÄ{x y : Category‚Äô.Obj‚Äô ùíû} ‚Üí x ‚ü∂‚Äô y ‚Üí obj‚Äô x ‚ü∂‚Äô obj‚Äô y    -- morphism preservation

    -- interaction with setoid structure
    cong : ‚àÄ {x y : Category‚Äô.Obj‚Äô ùíû} {f g : x ‚ü∂‚Äô y} ‚Üí f ‚âà‚Äô g ‚Üí mor‚Äô f ‚âà‚Äô mor‚Äô g

    -- preservation of finite compositions
    id   : ‚àÄ{x : Category‚Äô.Obj‚Äô ùíû} ‚Üí mor‚Äô (Id‚Äô {A = x}) ‚âà‚Äô Id‚Äô       -- identities preservation
    comp : ‚àÄ{x y z : Category‚Äô.Obj‚Äô ùíû} {f : x ‚ü∂‚Äô y} {g : y ‚ü∂‚Äô z} ‚Üí mor‚Äô (f ‚®æ‚Äô g) ‚âà‚Äô mor‚Äô f ‚®æ‚Äô mor‚Äô g  -- composition preservation

 subst-sym : ‚àÄ {a} {A : Set a} (P : A ‚Üí A ‚Üí Set) {x x‚Äô y y‚Äô : A} (xeq : x ‚â° x‚Äô) (yeq : y ‚â° y‚Äô) {p : P x y} {q : P x‚Äô y‚Äô} ‚Üí q ‚â° ‚â°-subst‚ÇÇ P xeq yeq p ‚Üí p ‚â° ‚â°-subst‚ÇÇ P (‚â°-sym xeq) (‚â°-sym yeq) q
 subst-sym P ‚â°-refl ‚â°-refl {p} {.p} ‚â°-refl = ‚â°-refl

 subst-trans : ‚àÄ {a} {A : Set a} (P : A ‚Üí A ‚Üí Set) {x x‚Äô x‚Äô‚Äô y y‚Äô y‚Äô‚Äô : A} (xeq : x ‚â° x‚Äô) (yeq : y ‚â° y‚Äô) (xeq‚Äô : x‚Äô ‚â° x‚Äô‚Äô) (yeq‚Äô : y‚Äô ‚â° y‚Äô‚Äô) {p : P x y} {q : P x‚Äô y‚Äô} {r : P x‚Äô‚Äô y‚Äô‚Äô} ‚Üí r ‚â° ‚â°-subst‚ÇÇ P xeq‚Äô yeq‚Äô q ‚Üí q ‚â° ‚â°-subst‚ÇÇ P xeq yeq p ‚Üí r ‚â° ‚â°-subst‚ÇÇ P (xeq ‚ü®‚â°‚â°‚ü© xeq‚Äô) (yeq ‚ü®‚â°‚â°‚ü© yeq‚Äô) p
 subst-trans P ‚â°-refl ‚â°-refl ‚â°-refl ‚â°-refl {p} {.p} {.p} ‚â°-refl ‚â°-refl = ‚â°-refl

       -- this‚Äô like subst-dist, with ~‚â°-cong~ of two equations using subst
 subst-compose : ‚àÄ {a} {A : Set a} (P : A ‚Üí A ‚Üí Set) {x x‚Äô y y‚Äô z z‚Äô : A} (xeq : x ‚â° x‚Äô) (yeq : y ‚â° y‚Äô) (zeq : z ‚â° z‚Äô) (p : P x y) (p‚Äô : P x‚Äô y‚Äô) (q : P y z) (q‚Äô : P y‚Äô z‚Äô) ‚Üí (_‚óá_  : ‚àÄ{m n k} ‚Üí P m n ‚Üí P n k ‚Üí P m k) ‚Üí p‚Äô ‚â° ‚â°-subst‚ÇÇ P xeq yeq p ‚Üí q‚Äô ‚â° ‚â°-subst‚ÇÇ P yeq zeq q ‚Üí (p‚Äô ‚óá q‚Äô) ‚â° ‚â°-subst‚ÇÇ P xeq zeq (p ‚óá q)
 subst-compose P ‚â°-refl ‚â°-refl ‚â°-refl p .p q .q _‚óá_ ‚â°-refl ‚â°-refl = ‚â°-refl
       -- taking cases ~p‚Äô = subst ... p~ and ~q‚Äô = subst ... q~ gives subst-dist ?

 subst-cong : ‚àÄ {a} {A : Set a} (P : A ‚Üí A ‚Üí Set) {x x‚Äô y y‚Äô : A} (xeq : x ‚â° x‚Äô) (yeq : y ‚â° y‚Äô) {p : P x y} {p‚Äô : P x‚Äô y‚Äô} ‚Üí p‚Äô ‚â° ‚â°-subst‚ÇÇ P xeq yeq p ‚Üí
                    ‚àÄ {b} {B : Set b} (Q : B ‚Üí B ‚Üí Set) {f‚ÇÄ : A ‚Üí B} (f : ‚àÄ {m n} ‚Üí P m n ‚Üí Q (f‚ÇÄ m) (f‚ÇÄ n)) {f‚Äô‚ÇÄ : A ‚Üí B} {f‚Äô : ‚àÄ {m n} ‚Üí P m n ‚Üí Q (f‚Äô‚ÇÄ m) (f‚Äô‚ÇÄ n)}
                    ‚Üí (eq‚ÇÄ : ‚àÄ {x} ‚Üí f‚ÇÄ x ‚â° f‚Äô‚ÇÄ x) (eq : ‚àÄ {m n} {r : P m n} ‚Üí f‚Äô r ‚â° ‚â°-subst‚ÇÇ Q eq‚ÇÄ eq‚ÇÄ (f r)) 
                    ‚Üí f‚Äô p‚Äô ‚â° ‚â°-subst‚ÇÇ Q (‚â°-cong f‚ÇÄ xeq ‚ü®‚â°‚â°‚ü© eq‚ÇÄ) (‚â°-cong f‚ÇÄ yeq ‚ü®‚â°‚â°‚ü© eq‚ÇÄ) (f p)
 subst-cong P ‚â°-refl ‚â°-refl {p} {.p} ‚â°-refl Q f eq‚ÇÄ eq rewrite eq {r = p} = ‚â°-refl

 open import Function using (_‚àò_)
 instance
  ùíûùí∂ùìâ‚Äô : Category‚Äô {‚Ñìsuc ‚Ñì‚ÇÄ} {‚Ñìsuc ‚Ñì‚ÇÄ} {_}
  ùíûùí∂ùìâ‚Äô =
   record
     { Obj‚Äô = Category‚Äô {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ} {_}
     ; _‚ü∂_ = Functor‚Äô
     ; _‚âà_ = Œª {ùíû} {ùíü} F G ‚Üí Œ£ oeq ‚à∂ (‚àÄ {o} ‚Üí Functor‚Äô.obj‚Äô F o ‚â° Functor‚Äô.obj‚Äô G o) ‚Ä¢ ((‚àÄ {X Y} {f : X ‚ü∂‚Äô Y} ‚Üí Functor‚Äô.mor‚Äô G f ‚â° ‚â°-subst‚ÇÇ _‚ü∂‚Äô_ oeq oeq (Functor‚Äô.mor‚Äô F f)))
     ; ‚âà-refl = ‚â°-refl , ‚â°-refl
     ; ‚âà-sym = Œª pf ‚Üí let (oeq , meq) = pf in ‚â°-sym oeq , subst-sym _‚ü∂‚Äô_ oeq oeq meq
     ; ‚âà-trans = Œª pf1 pf2 ‚Üí let (oeq‚ÇÅ , meq‚ÇÅ) = pf1 ; (oeq‚ÇÇ , meq‚ÇÇ) = pf2 in oeq‚ÇÅ ‚ü®‚â°‚â°‚ü© oeq‚ÇÇ , subst-trans _‚ü∂‚Äô_ oeq‚ÇÅ oeq‚ÇÅ oeq‚ÇÇ oeq‚ÇÇ meq‚ÇÇ meq‚ÇÅ
     ; _‚®æ_ = Œª {A} {B} {C} F G ‚Üí record { obj‚Äô = Functor‚Äô.obj‚Äô G ‚àò Functor‚Äô.obj‚Äô F ; mor‚Äô = Functor‚Äô.mor‚Äô G ‚àò Functor‚Äô.mor‚Äô F ; cong = Functor‚Äô.cong G ‚àò Functor‚Äô.cong F ; id = Œª {x} ‚Üí Category‚Äô.‚âà-trans C (Functor‚Äô.cong G (Functor‚Äô.id F)) (Functor‚Äô.id G) ; comp = Category‚Äô.‚âà-trans C (Functor‚Äô.cong G (Functor‚Äô.comp F)) (Functor‚Äô.comp G) }
     ; ‚®æ-cong = Œª {C D A} {F} {F‚Äô} {G} {G‚Äô} feq geq ‚Üí let (oeq‚ÇÅ , meq‚ÇÅ) = feq ; (oeq‚ÇÇ , meq‚ÇÇ) = geq in ‚â°-cong (Functor‚Äô.obj‚Äô G) oeq‚ÇÅ ‚ü®‚â°‚â°‚ü© oeq‚ÇÇ , subst-cong (Category‚Äô._‚ü∂_ D) oeq‚ÇÅ oeq‚ÇÅ meq‚ÇÅ (Category‚Äô._‚ü∂_ A) (Functor‚Äô.mor‚Äô G) oeq‚ÇÇ meq‚ÇÇ
     ; assoc = ‚â°-refl , ‚â°-refl
     ; Id = record { obj‚Äô = Œª x ‚Üí x ; mor‚Äô = Œª x ‚Üí x ; cong = Œª {x} {y} {f} {g} z ‚Üí z ; id = ‚âà-refl ; comp = ‚âà-refl }
     ; leftId = ‚â°-refl , ‚â°-refl
     ; rightId = ‚â°-refl , ‚â°-refl
     }
     where

 instance
  ùíÆet‚Äô : Category‚Äô
  ùíÆet‚Äô =
    record
      { Obj‚Äô = Set
      ; _‚ü∂_ = Œª A B ‚Üí (A ‚Üí B)
      ; _‚âà_ = Œª f g ‚Üí ‚àÄ {x} ‚Üí f x ‚â° g x
      ; ‚âà-refl = ‚â°-refl
      ; ‚âà-sym = Œª eq ‚Üí ‚â°-sym eq
      ; ‚âà-trans = Œª f‚âàg g‚âàh ‚Üí f‚âàg ‚ü®‚â°‚â°‚ü© g‚âàh
      ; _‚®æ_ = Œª f g ‚Üí g ‚àò f
      ; ‚®æ-cong = Œª {A B C} {f f‚Äô} {g g‚Äô} f‚âàf‚Äô g‚âàg‚Äô ‚Üí ‚â°-cong g f‚âàf‚Äô ‚ü®‚â°‚â°‚ü© g‚âàg‚Äô
      ; assoc = ‚â°-refl
      ; Id = Œª x ‚Üí x
      ; leftId = ‚â°-refl
      ; rightId = ‚â°-refl
      }

  -- make this as an excercise, since it is essentially CAT but without extra proof obligations for functors
  ùí¢ùìáùí∂ùìÖùíΩ‚Äô : Category‚Äô
  ùí¢ùìáùí∂ùìÖùíΩ‚Äô =
    record
      { Obj‚Äô = Graph
      ; _‚ü∂_ = GraphMap
      ; _‚âà_ = Œª {G} {H} f g ‚Üí Œ£ veq ‚à∂ (‚àÄ {v} ‚Üí ver f v ‚â° ver g v) ‚Ä¢
    (‚àÄ {x y e} ‚Üí edge g {x} {y} e ‚â° ‚â°-subst‚ÇÇ (Œª a b ‚Üí Graph._‚ü∂_ H a b) veq veq (edge f {x} {y} e))
      ; ‚âà-refl = ‚â°-refl , ‚â°-refl
      ; ‚âà-sym = Œª f‚âàg ‚Üí let (veq , eeq) = f‚âàg in ‚â°-sym veq , subst-sym (Graph._‚ü∂_ _) veq veq eeq
      ; ‚âà-trans = Œª f‚âàg g‚âàh ‚Üí let (veq‚ÇÅ , eeq‚ÇÅ) = f‚âàg ; (veq‚ÇÇ , eeq‚ÇÇ) = g‚âàh in veq‚ÇÅ ‚ü®‚â°‚â°‚ü© veq‚ÇÇ , subst-trans (Graph._‚ü∂_ _) veq‚ÇÅ veq‚ÇÅ veq‚ÇÇ veq‚ÇÇ eeq‚ÇÇ eeq‚ÇÅ
      ; _‚®æ_ = Œª f g ‚Üí record { ver = ver f ‚®æ‚Äô ver g ; edge = edge f ‚®æ‚Äô edge g } -- using ~ùíÆet~
      ; ‚®æ-cong = Œª {G} {H} {K} {f} {f‚Äô} {g} {g‚Äô} f‚âàf‚Äô g‚âàg‚Äô ‚Üí let (veq‚ÇÅ , eeq‚ÇÅ) = f‚âàf‚Äô ; (veq‚ÇÇ , eeq‚ÇÇ) = g‚âàg‚Äô in ‚â°-cong (ver g) veq‚ÇÅ ‚ü®‚â°‚â°‚ü© veq‚ÇÇ , subst-cong (Graph._‚ü∂_ _) veq‚ÇÅ veq‚ÇÅ eeq‚ÇÅ (Graph._‚ü∂_ _) (edge g) veq‚ÇÇ eeq‚ÇÇ
      ; assoc = ‚â°-refl , ‚â°-refl
      ; Id = record { ver = Category‚Äô.Id ùíÆet‚Äô ; edge = Category‚Äô.Id ùíÆet‚Äô }
      ; leftId = ‚â°-refl , ‚â°-refl
      ; rightId = ‚â°-refl , ‚â°-refl
      }

  ùí∞‚Äô : Functor‚Äô ùíûùí∂ùìâ‚Äô ùí¢ùìáùí∂ùìÖùíΩ‚Äô
  ùí∞‚Äô =  record {
     obj‚Äô = Œª ùíû ‚Üí record { V = Category‚Äô.Obj‚Äô ùíû ; _‚ü∂_ = Category‚Äô._‚ü∂_ ùíû }
   ; mor‚Äô = Œª F  ‚Üí record { ver = Functor‚Äô.obj‚Äô F ; edge = Functor‚Äô.mor‚Äô F }
   ; cong = Œª f‚âàg ‚Üí f‚âàg ; id = ‚â°-refl , ‚â°-refl ; comp = Œª {x} {y} {z} {f} {g} ‚Üí ‚â°-refl , ‚â°-refl }


ùí´‚Äô‚ÇÄ : Graph ‚Üí Category‚Äô
ùí´‚Äô‚ÇÄ G = let open TypedPaths G in 
  record
    { Obj‚Äô = Graph.V G
    ; _‚ü∂_ = _‚áù_
    ; _‚âà_ = _‚â°_
    ; ‚âà-refl = ‚â°-refl
    ; ‚âà-sym = ‚â°-sym
    ; ‚âà-trans = _‚ü®‚â°‚â°‚ü©_
    ; _‚®æ_ = _++_
    ; ‚®æ-cong = Œª p‚âàp‚Äô q‚âàq‚Äô ‚Üí ‚â°-cong‚ÇÇ _++_ p‚âàp‚Äô q‚âàq‚Äô
    ; assoc = Œª {x y z œâ p q r} ‚Üí assoc {p = p}
    ; Id = Œª {x} ‚Üí x !
    ; leftId = leftId
    ; rightId = rightId
    }

ùí´‚ÇÅ‚Äô : ‚àÄ{G H} ‚Üí GraphMap G H ‚Üí Functor‚Äô (ùí´‚Äô‚ÇÄ G) (ùí´‚Äô‚ÇÄ H)
ùí´‚ÇÅ‚Äô {G} {H} f = record { obj‚Äô = ver f ; mor‚Äô = fmap ; cong = ‚â°-cong fmap ; id = ‚â°-refl ; comp = Œª {x} {y} {z} {p} ‚Üí comp {p = p} }
    where
      open TypedPaths ‚¶É...‚¶Ñ public

      fmap : {x y : Graph.V G} ‚Üí  x ‚áù y ‚Üí (ver f x) ‚áù (ver f y)
      fmap (x !) = ver f x !
      fmap (x ‚ü∂[ e ]‚ü∂ p) = ver f x ‚ü∂[ edge f e ]‚ü∂ fmap p

      comp : {x y z : Graph.V G} {p : x ‚áù y} {q : y ‚áù z} ‚Üí fmap (p ++ q) ‚â° fmap p ++ fmap q
      comp {x} {p = .x !} = ‚â°-refl -- since ! is left unit of ++
      comp {x} {p = .x ‚ü∂[ e ]‚ü∂ ps} = ‚ü∂-‚â° (comp {p = ps})

ùí´‚Äô : Functor‚Äô ùí¢ùìáùí∂ùìÖùíΩ‚Äô ùíûùí∂ùìâ‚Äô
ùí´‚Äô = record { obj‚Äô = ùí´‚Äô‚ÇÄ ; mor‚Äô = ùí´‚ÇÅ‚Äô ; cong = Œª f‚âàg ‚Üí proj‚ÇÅ f‚âàg ,  gg f‚âàg ; id = ‚â°-refl , idm ; comp = ‚â°-refl , compmor }
    where
      open TypedPaths ‚¶É...‚¶Ñ public
         
      idm : ‚àÄ {G} {x y} {p : x ‚áù y} ‚Üí Functor‚Äô.mor‚Äô (Category‚Äô.Id ùíûùí∂ùìâ‚Äô {ùí´‚Äô‚ÇÄ G}) p ‚â° Functor‚Äô.mor‚Äô (ùí´‚ÇÅ‚Äô (Category‚Äô.Id ùí¢ùìáùí∂ùìÖùíΩ‚Äô)) p
      idm {G} {x} {p = .x !} = ‚â°-refl
      idm {G} {x} {p = .x ‚ü∂[ e ]‚ü∂ ps} = ‚ü∂-‚â° (idm {p = ps})    

      -- general version of gelping, keep it around, possibly as an excercise
      helping : ‚àÄ {a b} {A : Set a} (B : A ‚Üí A ‚Üí Set b) (P : A ‚Üí A ‚Üí Set) (cons : (s : A) (i : A) ‚Üí B s i ‚Üí (t : A) ‚Üí P i t ‚Üí P s t) ‚Üí
                  {x x‚Äô i i‚Äô t t‚Äô : A} {e : B x i} {e‚Äô : B x‚Äô i‚Äô} {ps : P i‚Äô t‚Äô}
                  (eqi : i‚Äô ‚â° i) (eqt : t‚Äô ‚â° t) (eqx : x‚Äô ‚â° x) (eqe : e‚Äô ‚â° ‚â°-subst‚ÇÇ B (‚â°-sym eqx) (‚â°-sym eqi) e)
                ‚Üí cons x i e t (‚â°-subst‚ÇÇ P eqi eqt ps) ‚â° ‚â°-subst‚ÇÇ P eqx eqt (cons x‚Äô i‚Äô e‚Äô t‚Äô ps) 
      helping B P cons ‚â°-refl ‚â°-refl ‚â°-refl ‚â°-refl = ‚â°-refl

      gelping :  {G : Graph} {x x‚Äô i i‚Äô t t‚Äô : Graph.V G} {e : Graph._‚ü∂_ G x i} {e‚Äô : Graph._‚ü∂_ G x‚Äô i‚Äô} {ps : i‚Äô ‚áù t‚Äô}
                  (eqi : i‚Äô ‚â° i) (eqt : t‚Äô ‚â° t) (eqx : x‚Äô ‚â° x) (eqe : e‚Äô ‚â° ‚â°-subst‚ÇÇ (Graph._‚ü∂_ G) (‚â°-sym eqx) (‚â°-sym eqi) e)
                ‚Üí x ‚ü∂[ e ]‚ü∂ (‚â°-subst‚ÇÇ _‚áù_ eqi eqt ps) ‚â° ‚â°-subst‚ÇÇ _‚áù_ eqx eqt (x‚Äô ‚ü∂[ e‚Äô ]‚ü∂ ps) -- read right-to-left this says we can shunt a subst over the inductive path constructor
      gelping ‚â°-refl ‚â°-refl ‚â°-refl ‚â°-refl = ‚â°-refl

      -- or in the case of graph maps
      gelpingg : {G H : Graph} {f g : GraphMap G H} {x i t : Graph.V G} {e : Graph._‚ü∂_ G x i} {ps : ver f i ‚áù ver f t}
                 (eq : Category‚Äô._‚âà_ ùí¢ùìáùí∂ùìÖùíΩ‚Äô f g)
                ‚Üí let veq = proj‚ÇÅ eq in
                  ver g x ‚ü∂[ edge g e ]‚ü∂ (‚â°-subst‚ÇÇ _‚áù_ veq veq ps) ‚â° ‚â°-subst‚ÇÇ _‚áù_ veq veq (ver f x ‚ü∂[ edge f e ]‚ü∂ ps)
      gelpingg (veq , eeq) = gelping veq veq veq (subst-sym (Graph._‚ü∂_ _) veq veq eeq)

      gg : ‚àÄ {x y} {f g : GraphMap x y} (f‚âàg : Category‚Äô._‚âà_ ùí¢ùìáùí∂ùìÖùíΩ‚Äô f g) {X Y : Category‚Äô.Obj‚Äô (ùí´‚Äô‚ÇÄ x)} {p : (ùí´‚Äô‚ÇÄ x Category‚Äô.‚ü∂ X) Y}
         ‚Üí Functor‚Äô.mor‚Äô (ùí´‚ÇÅ‚Äô g) p ‚â° ‚â°-subst‚ÇÇ (Category‚Äô._‚ü∂_ (ùí´‚Äô‚ÇÄ y)) (proj‚ÇÅ f‚âàg) (proj‚ÇÅ f‚âàg) (Functor‚Äô.mor‚Äô (ùí´‚ÇÅ‚Äô f) p)
      gg eq {X = X} {p = .X !} rewrite (proj‚ÇÅ eq) {X} = ‚â°-refl
      gg eq {X = X} {p = .X ‚ü∂[ e ]‚ü∂ ps} rewrite gg eq {p = ps} = gelpingg eq

      open Category ‚¶É...‚¶Ñ
      compmor : ‚àÄ {G H K} {f : G ‚ü∂ H} {g : H ‚ü∂ K} {x y} {p : x ‚áù y} ‚Üí Functor‚Äô.mor‚Äô (ùí´‚ÇÅ‚Äô f ‚®æ‚Äô ùí´‚ÇÅ‚Äô g) p ‚â° Functor‚Äô.mor‚Äô(ùí´‚ÇÅ‚Äô (f ‚®æ‚Äô g)) p
      compmor {x = x} {p = .x !} = ‚â°-refl
      compmor {x = x} {p = .x ‚ü∂[ e ]‚ü∂ ps} = ‚ü∂-‚â° (compmor {p = ps})

module freedom‚Äô (G : Obj ùí¢ùìáùí∂ùìÖùíΩ) {ùíû‚Äô : Category‚Äô {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ} {‚Ñì‚ÇÄ} } where

  open TypedPaths G using (_! ; _‚ü∂[_]‚ü∂_ ;  _‚áù_ ; _++_)
  open Category ‚¶É...‚¶Ñ

  Œπ‚Äô : G ‚ü∂ Functor‚Äô.obj‚Äô ùí∞‚Äô (ùí´‚Äô‚ÇÄ G)
  Œπ‚Äô = record { ver = Id ; edge = Œª {x} {y} e ‚Üí x ‚ü∂[ e ]‚ü∂ y ! }

  lift‚Äô : G ‚ü∂ (Functor‚Äô.obj‚Äô ùí∞‚Äô) ùíû‚Äô ‚Üí ùí´‚Äô‚ÇÄ G ‚ü∂‚Äô ùíû‚Äô
  lift‚Äô f = record { obj‚Äô = Œª v ‚Üí ver f v ; mor‚Äô = toMap ; cong = cong ; id = ‚âà-refl ; comp = Œª {x y z p q} ‚Üí proof {x} {y} {z} {p} {q} }
     where
          toMap : ‚àÄ {x y} ‚Üí x ‚áù y ‚Üí ver f x ‚ü∂‚Äô ver f y
          toMap (y !) = Id‚Äô
          toMap (x ‚ü∂[ e ]‚ü∂ p) = edge f e ‚®æ‚Äô toMap p
          cong : ‚àÄ {x y} {p q : x ‚áù y} ‚Üí p ‚â° q ‚Üí Category‚Äô._‚âà_ ùíû‚Äô (toMap p) (toMap q)
          cong ‚â°-refl = ‚âà-refl

          proof : ‚àÄ{x y z} {p : x ‚áù y} {q : y ‚áù z} ‚Üí Category‚Äô._‚âà_ ùíû‚Äô (toMap (p ++ q)) (toMap p ‚®æ‚Äô toMap q)
          proof {p = ._ !} = ‚âà-sym leftId‚Äô -- ‚â°-sym (Category‚Äô.leftId {!!})
          proof {p = ._ ‚ü∂[ e ]‚ü∂ ps} = ‚âà-trans (‚®æ-cong ‚âà-refl (proof {p = ps})) (‚âà-sym (Category‚Äô.assoc ùíû‚Äô))
{-
  property‚Äô : ‚àÄ{f : G ‚ü∂ (Functor‚Äô.obj‚Äô ùí∞‚Äô) ùíû‚Äô} ‚Üí Category‚Äô._‚âà_ ùí¢ùìáùí∂ùìÖùíΩ‚Äô f (Œπ‚Äô ‚®æ‚Äô (Functor‚Äô.mor‚Äô ùí∞‚Äô) (lift‚Äô f))
  property‚Äô {f} = ‚â°-refl , {!now need to add setoid structure to graphs!}
-}
#+END_EXAMPLE

* COMMENT Random thoughts on: Relations ‚âÖ Graph Paths
Can we turn any relation into a category? Well we know that preorder relations yield categories,
so let‚Äôs consider transforming arbitrary relations to preorders.

Suppose we have a relation ~R : X ‚Üí X ‚Üí Set~ and we want it to be a preorder such as
~‚â§ : ‚Ñï ‚Üí ‚Ñï ‚Üí Set~. Then we need it to be reflexive and transitivie; that is,
~‚àÄ x ‚à∂ X ‚Ä¢ R x x~, ~‚àÄ x y ‚à∂ X ‚Ä¢ R x y ‚Üí R y x~, and ~‚àÄ x y z ‚à∂ X ‚Ä¢ R x y ‚Üí R y z ‚Üí R x z~ are
provable, respectively.

(As it stands, this relation is precicely a graph-path!
If we want a relation in the traditional sense of ordered pairs, then we want a simple-graph.
#+BEGIN_EXAMPLE
simple : ‚àÄ {x y} (p q : R x y) ‚Üí p ‚â° q    -- at most one edge between any two pair
#+END_EXAMPLE
)


[[

above when defined poset category, or rather after hom is defined,

mention how intervals a..b are realised in the cat, say via hom??

]]

Then, ~‚â§R~ is a partial order.
#+BEGIN_EXAMPLE
data _‚â§R : X ‚Üí X ‚Üí Set where
  embed : ‚àÄ {x y} ‚Üí R x y ‚Üí x ‚â§R y                      -- existing edges
  refl  : ‚àÄ {x} ‚Üí x ‚â§R x                                 -- empty path
  trans : ‚àÄ {x y z} ‚Üí x ‚â§R y ‚Üí y ‚â§R z ‚Üí x ‚â§R z         -- path concatenation
#+END_EXAMPLE
Observe that ~embed~ says that the order ~‚â§R~ contains ~R~. 

(~‚â§R~ is also known as the "reachiability poset of R" ??)

Usual definition is ~‚â§R ‚âî R* = Œª x y ‚Üí Œ£ n ‚à∂ ‚Ñï ‚Ä¢ R‚Åø x y~ where
~R‚Å∞ x y = (x ‚â° y)~ and ~R‚Åø‚Å∫¬π x y ‚â° Œ£ i ‚Ä¢ R x y ‚àß R‚Åø i y~; the reflexive transitive closure of
~R~. While this is more compact, the Agda version is easier to work with and it is equivalent
since ~embed~ corresponds to ~n=1~, ~refl~ corresponds to ~n = 0~, and ~trans~ corresponds to
the ‚Äòmultiplication‚Äô operation since ~R‚Åø‚Å∫¬π x y ‚áî Œ£ a,b ‚à∂ ‚Ñï ‚Ä¢ a + b ‚â° n ‚àß Œ£ i ‚Ä¢ R·µÉ x i ‚àß R·µá i y~
---or so I claim!

For example, if ~R = { (1,2) , (3,4) }~ then
#+BEGIN_EXAMPLE
‚â§R =
{
  (1,2) , (3,2),               -- embed
  (1,1), (2,2), (3,3),         -- refl
  -- trans gives no new pairs
}
#+END_EXAMPLE
An example algorithm for finding the transitive closure is Warshall‚Äôs algorithm.

Notice that if ~R~ reflexive or transitive, then we do not have uniqunenss of proofs for
~‚â§R~. In particular, suppose ~R~ is reflexive and such proofs are constructed by ~r_~.
Then a proof of ~x ‚â§R x~ can be obtained in two ways: ~refl {x}~ or ~embed (r x)~.

Now the resulting category can be thought of as the free-category on ~R~; what‚Äôs the associated
adjunctin to this claim o mine? That is, functors from this free cat correspond to relational
homomorphisms?? Consider consulting Schmidt and Strohnelin.

Is this is the least preorder relation on R?
#+BEGIN_EXAMPLE
suppose ‚äë is a reflexive relation that contains R, then

given p : x ‚â§R y  --ignoring transitivity
there are two cases.

Case p = embed q. Then q yields a proof of x ‚äë y since ‚äë contians R and q is an R proof.
Case p = refl {x}. Then x ‚äë x holds since ‚äë is relfexive.

Hence, ‚â§R (ignoring transitivity) is the least reflexive relation contianing R.

Suppose ‚äë is also transitive.

Then the only remaining case is

Case p = trans q r, where q : x ‚â§R y, r : y ‚â§R z, Then by induction we have proofs
  x ‚äë y ‚äë z, but ‚äë is transitive and so we have a proof of x ‚äë z.

Thus, ‚â§R is the least preorder containing R!! Woah! Awesome!

#+END_EXAMPLE


Every preorder can be obtained as the closure of its Hasse/covers relation:
~‚àÄ R preorder ‚Ä¢ R ‚âÖ ‚â§[ R ] ‚âÖ ‚â§[ Covers R ]~ (in the category of relations and relation homomorphisms),
where ~Covers R x y ‚â° x ‚â† y ‚àß x R y ‚àß ¬¨ Œ£ z ‚Ä¢ z ‚â† x R z R y ‚â† z~. ?? Is this true, or do I just
think it to be true...

In particular, taking ~R = ‚Ñô‚Çô~, which is a hasse relation, yields the free preorder on R
which is essentially the free category on the poset ~‚â§[ R ]~.


----

Now R can be thought of as a directed graph.
If we take ~R = { (i, i+1) ‚à£ i ‚àà 0..n-1} ~
then ~‚â§R~ is the free graph on ~‚Ñô‚Çô~, right??

moreover it is a total order: we can show
#+BEGIN_EXAMPLE
total : ‚àÄ {x y} ‚Üí x ‚â§R y ‚äé y ‚â§R x
antisym : ‚àÄ {x y} ‚Üí x ‚â§R y ‚Üí y ‚â§R x ‚Üí x ‚â° y
#+END_EXAMPLE 
Also such categories of paths are known as simplicies??

\url{https://ncatlab.org/nlab/show/simplex+category}

\url{http://mathoverflow.net/questions/159989/internal-logic-of-the-topos-of-simplicial-sets}

* COMMENT Kopka D-poset                    :CategoryTheory:Functors:Examples:
They‚Äôre also instances of a structure known
as a \emph{Kopka D-poset}, or Kopka difference-poset:
such a structure ~(D, ‚â§, ‚à∏, *, 0, 1)~ consists of a poset ~(D, ‚â§)~ with least element ~0~,
greates element ~1~, abelian po-monoid ~(D, ‚â§, *, 1)~, and a binary operation
~_‚à∏_ : D √ó D ‚Üí D~ satisfying
begin{itemize}
\item ~a ‚â§ b ‚áí b ‚à∏ a~ is defined  %% contravariance.
\item ~a ‚à∏ 0 = a~ %% since ~0 ‚â§ a~ and what??
\item ~a ‚â§ b ‚â§ c ‚áí c - b ‚â§ c - a~ %% contravariance.
\item ~a ‚â§ b ‚â§ c ‚áí (c ‚à∏ a) ‚à∏ (c ‚à∏ b) = b ‚à∏ a~ %% composition via functoricality?
\item ~a ‚à∏ (a * b) ‚â§ 1 ‚à∏ b~, compare with $\frac{y}{y \times x} = \frac{1}{x}$.
\end{itemize}

The similarity is obtained as follows:
#+BEGIN_EXAMPLE
Assuming

(A0) a ‚à∏ 0 = a, for all a
(A1) a ‚â§ b ‚â§ c ‚áí c ‚à∏ b ‚â§ c ‚à∏ a
(A2) a ‚â§ b ‚â§ c ‚áí (c ‚à∏ a) ‚à∏ (c ‚à∏ b) = b ‚à∏ a

(i)
   a ‚â§ b
‚áí 0 ‚â§ a ‚â§ b         0 is bottom
‚áí b ‚à∏ a ‚â§ b ‚à∏ 0     (A1)
‚áí b ‚à∏ a ‚â§ b         (A0)

(ii) a ‚à∏ a = 0
Proof.
  Suffices to show a ‚à∏ a ‚â§ 0, since 0 is bottom element.

    a ‚à∏ a
  = (a ‚à∏ 0) ‚à∏ (a ‚à∏ 0)   (A0)
  = 0 ‚à∏ 0               (A2) since 0 ‚â§ 0 ‚â§ a , since 0 bottom
  = 0                   (A0)
#+END_EXAMPLE

* COMMENT footer

(org-babel-tangle)

---

Note the existence of: (agda2-restart)

eval: (progn (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1))

NOTE that AlBasmala calls the source file NAME.org, so below we change that to
this file‚Äôs name.

*WARNING* To use agda-mode to convert agda blocks to org blocks,
the blocks cannot contain any ~\~ within them!

(makunbound ‚Äôagda2-include-dirs)

# Local Variables:
# eval: (visual-line-mode t)
# eval: (load-file "~/alhassy.github.io/content/AlBasmala.el")
# eval: (setq NAMEorg (buffer-name))
# eval: (setq pdfsLocation "~/alhassy.github.io/assets/pdfs/")
# eval: (setq SOURCE "https://raw.githubusercontent.com/alhassy/CatsCheatSheet/master/PathCat.lagda")
# compile-command: (preview-article)
# eval: (org-mode)
# eval: (load-file "~/Projects/org-agda-mode/literate.el")
# End:
